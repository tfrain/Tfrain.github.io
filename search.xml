<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字节实习面经]]></title>
    <url>%2F2020%2F04%2Fyuque%2Foffer%2F</url>
    <content type="text"><![CDATA[疫情之下的实习面经？ 一面&amp;二面（3-24，2h）因为一二面连续面，问题可能会交叉。这些问题是我提取出来的关键词，可能面试官不是直接这么问，你需要理解他想要了解的是什么。 事务是什么？ 隔离机制，MVCC，又引出了 undo log，幻读 行锁是如何实现的 I/O 多路复用 段页式机制 JMM 内存模型 介绍 Java 中的锁，说了 synchronized 和 Reentrantlock 内部实现和区别 介绍项目 算法题：过期键值对的 LRU cache（写的不理想，然后时间差不多了，给了我一次机会） 大约十分钟后二面 TCP、UDP 的区别 awk 的用法（问我如何读取日志中的某一行，因为我简历说了会写简单的 shell 脚本） 线程与进程的区别，顺便问了他们各自的通信方式 介绍大数据量数据库应该如何维护（算是个场景题吧？我有点忘了我是怎么回答的了） 数据库查询一行数据的整个内部过程 树的层次遍历，DFS、BFS 的使用场景与区别 项目中是如何重构大查询的 介绍论文做了什么工作（水） 算法题：合并区间 三面（原定于 3-30，面试官改为 3-31，50 min） 自己实现一个 hashmap 的思路（说了 Java 的） TCP 三次握手、四次挥手，listen 函数的参数意义（没答出来） 用什么 shell，Linux 一些常用命令 redis 为什么这么快 GC 算法 一个系统调用的全过程（说了一些皮毛） 在学校实验室干什么（就是一个技术社团），对 C/C++ 了解吗？（写过垃圾贪吃蛇） 幻读，mysql 是如何解决幻读的？ git 的使用 单元测试写过吗？（说了一下 SpringBoot 里面的单元测试，但感觉没有回答到他想问的） 项目和数据库知识，哪个比较重要（鬼扯） select、poll、epoll 的区别 数据是如何从己端传输到对端（说了一下 SendFile，四次拷贝，两次系统调用等内容，但是记不太清楚了） 了解 go 的多线程知识吗？（不了解，只知道 go 开发速度等方面具有优势）了解 MongoDB 吗？（不了解，就知道是非关系型数据库） 了解分布式的知识吗？（说了分布式锁，然后他就知道我不了解相关的内容了(确实)） 算法题：最大连续子数组和。在调试过程中，面试官一直问我如何调试错误的。可能这一方面能力也很重要，写出了前缀子和的实现方式，又让我简单写了一下 dp 的解法（没有跑数据） 四面（4-8 那边说四面面试官调不开时间，推的比较靠后 33min）我的情况比较特殊，四面还是技术面，来自一个实习生的迷惑，为什么我有四轮技术面？后话是我 4-12 直接就收到 oc 那天晚上收到邮件，所以跳过了 hr 面？emmmm，有点迷。 对什么数据库比较了解？mysql 的事务隔离级别（每一个好像都要问问） 内部的实现方式？后来具体到 InnoDB 内部如何处理，处理流程（把服务端和存储引擎层说了说，说了一下 2pc） 哪些知识掌握比较好？（数据库和网络） 数据库学了那些东西？ 网络机制 RDMA 了解吗？（没听过这个名词。。。。）问我了解哪些东西 说一下网络的拥塞控制 操作系统了解吗？ 为什么来字节跳动实习？ 做了什么准备？刷题了吗？（太真实了，刷题是不可能不刷的，这辈子不可能不刷的）什么感觉？ 准备过程中除了压力和心态外，遇到的最大问题 最大的优点和缺点 对工作内容有什么诉求吗？有倾向吗？ 算法题：求二叉树的最小公共祖先节点，时间复杂度（指数倍的树高），空间复杂度 如何优化我的这个时间复杂度？（没打开思路，转问我一个场景题）海量节点树的查询（十亿个节点）遍历然后分治，最后用空间优化时间，我说当成满二叉树，利用数学关系来查找。 算法题：Top K（回答堆或快排）让我实现了堆的，最小十个数 有什么想问我的？ 实习完之后的计划？ oc（4-12 下午offer call，晚上邮件offer)问了一下入职时间，说了一下福利等信息，几分钟解决。 总结我自我介绍说了一下数据库了解多一些，可能问我这方面多一些，四面的 leader 问我的比较宏观，没问什么比较细的，算法题也没让我跑数据。关于字节的面试，有以下几点可以说一下： 我面了几家公司，字节比较看中基础，关于 Java 方面的知识基本没怎么问我 面试官都比较亲切，不会强人所难，不过尽量要会，因为不会很扣分 字节的面试效率和方式我都觉得比较好，所以我觉得体验还不错，就一二面特别紧张，三四面就好很多了 最好有一项拿得出手的，不怕他夺命连环问，另外不会了，也可以往自己擅长地方靠 算法题很重要，我算法准备不怎么充分，做了的几题都有点印象，算是运气了]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux 需记]]></title>
    <url>%2F2019%2F12%2Fyuque%2Fpd4aum%2F</url>
    <content type="text"><![CDATA[Linux 很少一部分知识 1 Linux的体系结构主讲过程 Linux的体系结构 体系结构主要分为用户态（用户上层活动）和内核态 内核：本质是一段管理计算机硬件设备的程序 系统调用：内核的访问接口，是一种能再简化的操作（man 2 syscalls、man 2 acct、man 2指查看系统调用，man 3是指查看公共库函数） 公共库函数：系统调用的组合拳（为了使程序员从具体的细节中解脱出来而提出一种有效方法，它实现对系统调用的封装，将简单的业务逻辑接口呈现给用户，返回给用户调用，这样一种组合方式，极大增强了程序设计的灵活性。对于简单的操作，我们可以直接调用系统调用来访问资源，而对于复杂的操作，我们借助于库函数来实现。库函数依据不同的标准，也可以有不同的实现版本） shell：命令解释器，可编程（从ls -lrs来说，涉及which ls的路径，将参数传给具体的调用的这个过程）补充：可以用一下 cat /etc/shells 来看一下支持的shell，使用chsh -s + shell的路径 来进行切换。 2 查找特定文件主讲过程 find find path [option] params作用：在指定目录下查找文件实例：find ~ -iname “target*”，使用了通配符，并且匹配大小写。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络记录]]></title>
    <url>%2F2019%2F12%2Fyuque%2Fgilftp%2F</url>
    <content type="text"><![CDATA[网络方面的知识 第6讲 | 交换机与VLAN：办公室太复杂，我要回学校自我总结 拓扑结构是怎么形成的？ 第一印象：交换机一开始是不知道任何拓扑信息的，收到某个广播后，出了广播包来的方向外，还要转发给其他所有的网口。例如在发送过程中，知道机器1是在左边这个网口，了解这些信息，就可以有选择的不广播给一些不可能发送信息的主机。重温：这个时候交换机 A 已经知道机器1是不可能在右边的网口了，所以这个广播信息就不会广播到局域网二和三。（交换机有一定的学习能力） 如何解决常见的环路问题？ 第一印象：环路的弊处：一开始不知道交换机在哪里，左转到一个局域网，这个局域网右转到原局域网，原局域网继续左转，一直转下去重温：每个机器都会广播包，交换机转发也会复制广播包，当广播包越来越多时，按照共享道路的算法，路会越来越堵，最后谁也别想走；环路风暴。 STP协议中难以理解的概念 第一印象：生成树算法。Root Bridge 根交换机、Designated Bridges 指定交换机、Bridge Protocol Data Units （BPDU） 网桥协议数据单元、Priority Vector 优先级向量 [Root Bridge ID, Root Path Cost, Bridge ID, and Port ID]重温：是其实这是一场血雨腥风的武林比武或者华山论剑，最终决出五岳盟主的方式。 STP的工作过程是怎样的？ 第一印象：根交换机是掌门人，指定交换机是小弟，网络交换协议单元（bpdu）只能由掌门来发，小弟转发，用于不同网络之间的比较，优先级向量可以理解成距离根交换机的距离，越小越牛🐂。第二个变量可以用于内部比较。重温：最终，生成一棵树，但是分久必合，合久必分。一共举了四个例子。 如何解决广播问题和安全问题？ 第一印象：物理隔离和虚拟隔离。后者又叫vlan；通过二层头上加一个tag，其中有vlan id，一共是12位。4096很大程度来说是不够的。重温：对于支持VLAN的交换机，有一种口叫作Trunk口。它可以转发属于任何VLAN的口。交换机 之间可以通过这种口相互连接 内容小结&amp;课后思考 第一印象：STP 对于跨地域甚至跨国组织的网络支持，就很难做了，计算量摆着呢。一个是某个交换机状态发生变化的时候，整个树需要重新构建，另一个是被破开的环的链路被浪费了重温：交换机会缓存 MAC 地址和转发端口的关系。第一次是不能单播，第二次就可以单播了。 额外知识 第7讲 | ICMP与ping：投石问路的侦察兵自我总结 ICMP协议的格式 第一印象：互联网控制报文协议，控制体现在通过侦察兵、哨探或传令兵控制整个战局。封装在ip包里。分为查询报文类型，差错报文类型重温：最常用的类型是主动请求为 8，主动请求的应答为 0 查询报文类型 第一印象：ping 命令就是查询报文，符合icmp格式，不过在后面增加了自己的格式重温：比起原生的icmp，多了标识符和序号 差错报文类型 第一印象：终点不可达为 3，源抑制为 4，超时为 11，重定向为 5，具体的原因在代码中表示就是，网络不可达代码为 0，主机 不可达代码为 1，协议不可达代码为 2，端口不可达代码为 3，需要进行分片但设置了不分片位代码为 4。重温：这类侦查兵特别恪尽职守，不但自己返回来报信，还把一部分遗物也带回来 ping：查询报文类型的使用 第一印象：源主机构建一份icmp请求数据包、数据部分插入发送时间、加入mac头、目的主机构建一个icmp应答包，类型字段为0，顺序号为请求数据包中的顺序。重温：不在局域网内，选择路由的下一跳，每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址，但是 ping 不通不 代表网络不通。这个时候就要使用 telnet，通过其他协议来测试网络是否通 Traceroute：差错报文类型的使用 第一印象：Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将 TTL 设置成 1，如果中间的路由器不止一个，当然碰到第一个就“牺牲”。于是，返回一个 ICMP 包，也就是网络差错包，类型是时间超时重温：，有的路由器压根不会回这个 ICMP，但它会 选择一个不可能的值作为 UDP 端口号（大于 30000）。当该数据报到达时，将使目的主机的 UDP 模块 产生一份“端口不可达（主机）”错误 ICMP 报文 总结与实践 第一印象：Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。这是人家故意的好 吧，每次收到 ICMP“不能分片”差错时就减小分组的长度，直到到达目标主机。重温：确定mtu是否可以 额外知识 1 tcpdumptcpdump 是一个运行在命令行下的嗅探工具。它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP/IP和其他数据包。tcpdump 是一个在BSD许可证下发布[2]的自由软件。tcpdump 适用于大多数的类Unix系统 操作系统：包括Linux、Solaris、BSD、Mac OS X、HP-UX和AIX 等等。在这些系统中，tcpdump 需要使用libpcap这个捕捉数据的库。其在Windows下的版本称为WinDump；它需要WinPcap驱动，相当于在Linux平台下的libpcap.https://www.iteye.com/blog/wezly-608177 windump 工具2 telnetTelnet是一种应用层协议，使用于网际网路及区域网中，使用虚拟终端机的形式，提供双向、以文字字串为主的命令列介面互动功能。属于TCP/IP协议族的其中之一，是Internet远端登录服务的标准协议和主要方式，常用于伺服器的远端控制，可供使用者在本地主机执行远端主机上的工作。Telnet在1969年开发出来，在 RFC 15 定义， RFC 854 定义了扩充功能。互联网工程任务组（IETF），在STD 8中，将其加以标准化，是最早形成的网际网路协议之一。 第8讲 | 世界这么大，我想出网关：欧洲十国游与玄奘西行自我总结 你了解 MAC 头和 IP 头的细节吗？ 第一印象：网关往往是一个路由器的一部分，三层转发设备：就是把MAC头和IP头都取下来，根据里面内容进行转发的设备。路由器每只手的IP地址都和局域网的IP地址有相同的网段，每只手都是它握住的那个局域网的网关。重温：如何发往默认网关，在同一个网段，将源地址和目标IP放入IP头中，通过ARP获得网关的MAC地址，将源 MAC 和网关 的 MAC 放入 MAC 头中，发送出去（这个动作是在路由器还是主机上）。如何判断同一个网段？通过CIDR和子网掩码。 静态路由是什么？ 第一印象：静态路由，其实就是在路由器上，配置一条一条规则。重温： IP 头和 MAC 头哪些变、哪些不变？ 第一印象：MAC地址是一个局域网内有效的地址，过了网关，就必定会改变（由此可以推断，这个东西是在路由器上进行更换的）重温：不改变IP地址的网关，我们称为转发网关，该白你ip地址的网关，我们称为NAT网关 “欧洲十国游”型 第一印象：IP头里面的地址是不变的，IP地址在三个局域网里面都是可见的。配置静态路由，它的解析是：要想访问 x.x.x.x 要从x.x.x.x这个口出去，下一条是 x.x.x.x 。所谓的下一跳是，某个IP要将这个ip地址转换为mac放入mac头重温：在三个网段之间传输包，IP 头不改变。这就 像在欧洲各国之间旅游，一个签证就能搞定。 “玄奘西行”型 第一印象：中国和印度的一个地方网址是一样的，这时候联系就需要NAT转换，当网络包发送到中间的局域网的时候，服务器 A 也需要有个国际身份，因而在国际上，源 IP 地址也不能 用 192.168.1.101，需要改成 192.168.56.1。（看下图）重温：路由器 B 是一个 NAT 网关，它上面配置了，要访问国际身份 192.168.56.2 对应国内身份 192.168.1.101，于是改为访问 192.168.1.101。当我们家里发出去的时候，都被家用路由器NAT成运营商的地址了 总结与实践 第一印象：如果离开本局域网，就需要经过网关，网关是路由器的一个网口； 路由器是一个三层设备，里面有如何寻找下一跳的规则；重温：经过路由器之后 MAC 头要变，如果 IP 不变，相当于不换护照的欧洲旅游，如果 IP 变，相当于换护 照的玄奘西行。 第9讲 | 路由协议：西出网关无故人，敢问路在何方自我总结 如何配置路由 第一印象：根据目的ip地址来配置路由，较简单的静态路由重温：通过route命令和ip route 命令都可以进行查询或者配置 如何配置策略路由 第一印象：更复杂点的静态路由，房东可以设置不同的路由表来让租客享受不同的网速，更复杂可能要设计NAT路由器， ip route list table main 可以设置，运营商二走eth3，运营商一走eth2，访问内网走eth1。重温：如果此时有用户想反悔，可以添加一个新的表，然后将表内容和eth3，和他的ip地址联系起来，最后 ip route flush cache就好了 动态路由算法之距离矢量路由算法 and 链路状态路由算法 第一印象：前者基于 Bellman-Ford 算法，rip利用这个算法，到了一定阈值，才能判断它挂了，比如15跳。重温：后者基于Dijkstra 算法。，收到邻居的信息，然后组成图，针对图来使用 Dijkstra 算法，找到两点间最短路径 动态路由协议之基于链路状态路由算法的 OSPF and 基于距离矢量路由算法的 BGP（基于距离的分明不好，BGP为何会用，因为改进了，属于升级版） 第一印象：广泛应用在数据中心，用于路由决策，称为内部网关协议。发现多个最短路径，就可以在多个路径中进行负载均衡，常被称为等价路由。重温：AS 自治系统，为了保证近，但是不能随便走的问题，每个自治系统都有边界路由器，通过它和外界联系。边界路由器之间使用 eBGP 广播路由，运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器，在BGP中除了下一跳 hop 之外，还包括自治系统 as 路径，避免了消息传得慢的问题，b到c通过a，但是a到不了c了，所以b也到不了c。 总结与实践 第一印象：动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP 协议和 OSPF 协议。重温：静态路由可以配置复杂的策略路由，控制转发策略； 额外知识 1 TOS (根据源 IP 地址、入口设备、TOS 等选择路由表) bit的TOS分别代表： 最小时延、最大吞吐量、最高可靠性和最小费用 。4 bit中只能置其中1 bit。如果所有4 bit均为0，那么就意味着是一般服务。 第10讲 | UDP协议：因性善而简单，难免碰到“城会玩”自我总结 tcp 与 udp 有哪些区别 第一印象：面向连接，非面向连接，udp简单，没有拥塞控制，udp是集成ip包的特性，udp是无状态服务重温：tcp 提供可靠交付，无差错、不丢失、不重复、按序到达。tcp 面向字节流，没头没尾、拥塞控制，发送快慢一定程度上可控制，有状态的，精确记住发送了没有，接受到没有等等。 udp包头是什么样的？ 第一印象：udp包取出mac地址，交给处理IP层的代码。IP头里有8为位协议，存放tcp还是udo的数据。重温：明白udp的格式，数据解析出来，交付给端口号对应的程序，udp包头的格式和tcp比起来很简单 udp 三大特点 第一印象：沟通简单、轻信他人、愣头青、做事不懂权变重温：默认是很容易到达，不容易被丢弃的、谁都可以传给他数据，它也可以传给任何人数据、不会进行拥塞控制，该如何仍旧如何 udp的三大使用场景 第一印象：需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用、不需要一对一交流，建立连接，而是可以广播的应用、需要处理速度快，时延低、可以容忍少数丢包，不支持拥塞控制的重温：操作系统镜像下载 TFTP、DHCP 广播、本来环境就差的，不能自断臂膀。 基于 UDP 的“城会玩”的五个例子 第一印象：网页或者app的访问、流媒体的协议、实时游戏、IoT物联网、移动通信领域重温：应用层的代表，QUIC、基于UDP实现自己的视频传输协议、自定义可靠udp协议，重传策略，减少丢包产生的延迟，减少网络问题对游戏体验的影响、嵌入式系统，实时性要求也高、移动网络协议已经相当复杂 总结与实践 第一印象：UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。 例如 DHCP、VXLAN、QUIC 等。重温：如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；TCP 维护连 接，UDP 谁都相信；TCP 会坚持知进退；UDP 愣头青一个，勇往直前； 额外知识 1 组播 https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%92%AD多播（英语：multicast，台湾又译作多点发送、多点广播或群播，中国大陆又译作组播）是指把信息同时传递给一组目的地址。它使用的策略是最高效的，因为消息在每条网络链路上只需传递一次，且只有在链路分叉的时候，消息才会被复制。与多播相比，常规的点到单点传递被称作单播。当以单播的形式把消息传递给多个接收方时，必须向每个接收者都发送一份数据副本。由此产生的多余副本将导致发送方效率低下，且缺乏可扩展性。不过，许多流行的协议——例如XMPP，用限制接收者数量的方法弥补了这一不足。 2 IGMP 包 网路群组管理协议（Internet Group Management Protocol或简写IGMP)是用于管理网路协议多播组成员的一种通信协议。IP主机和相邻的路由器利用IGMP来创建多播组的组成员。像ICMP用于单播连接一样，IGMP也是IP多播说明的一个完整部分。 IGMP为互联网协议的一种，属于开放系统链接(OSI) 模块的第三层协议，IP主机用它将主机的多点发送成员人数报告给临近的多点发送路由器。 3 RTMP 协议 https://mingyangshang.github.io/2016/03/06/RTMP%E5%8D%8F%E8%AE%AE/RTMP协议是应用层协议，是要靠底层可靠的传输层协议（通常是TCP）来保证信息传输的可靠性的。在基于传输层协议的链接建立完成后，RTMP协议也要客户端和服务器通过“握手”来建立基于传输层链接之上的RTMP Connection链接，在Connection链接上会传输一些控制信息，如SetChunkSize,SetACKWindowSize。 第13讲 | 套接字Socket：Talk is cheap, show me the code自我总结 前言 Socket 函数要指定ipv4 或者 ipv6 对应 AF_INET 和 AF_INET6。指定数据流tcp还是数据报udp，对应 SOCK_STREAM 和 SOCK_DGRAM。 基于 TCP 协议的 Socket 程序函数调用过程 第一印象：监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听 Socket，一个叫作已连接 Socket。重温：Socket 对应的 inode 不像真正的文件系统一样，保存在硬盘上的，而是在内存中的（具体过程不懂就看原文，是一系列指针调用的过程）。 基于 UDP 协议的 Socket 程序函数调用过程 第一印象：UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。正是因为没有连接状态，每次通信的时候，都调用 sendto 和 recvfrom，都可以传入 IP 地址和端口。重温：基于udp的socket编程好像是没有用过，相对于基于tcp，确实也比较简单。 服务器如何接更多的项目？ 第一印象：服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是文件描述符限制；另一个限制是内存，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的。重温：在资源有限的情况下，要想接更多的项目，就需要降低每个项目消耗的资源数目。 方式一：将项目外包给其他公司（多进程方式） 第一印象：你可以创建一个子进程，然后将基于已连接 Socket 的交互交给这个新的子进程来做。如何创建子公司，并如何将项目移交给子公司呢？重温：在 Linux 下，创建子进程使用 fork 函数。通过名字可以看出，这是在父进程的基础上完全拷贝一个子进 程。在 Linux 内核中，会复制文件描述符的列表，也会复制内存空间，还会复制一条记录当前执行到了 哪一行程序的进程。复制的时候在调用 fork，复制完毕之后，父进程和子进程都会记录当前刚刚 执行完 fork。这两个进程刚复制完的时候，几乎一模一样，只是根据 fork 的返回值来区分到底是父进 程，还是子进程。如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。因为复制了文件描述符列表，而文件描述符都是指向整个内核统一的打开文件列表的，因而父进程刚才 因为 accept 创建的已连接 Socket 也是一个文件描述符，同样也会被子进程获得。 方式二：将项目转包给独立的项目组（多线程方式） 第一印象：如果创建进程相当于成 立新公司，购买新办公家具，而创建线程，就相当于在同一个公司成立项目组。一个项目做完了，那这 个项目组就可以解散，组成另外的项目组，办公家具可以共用。重温：在 Linux 下，通过 pthread_create 创建一个线程，也是调用 do_fork。不同的是，虽然新的线程在 task 列表会新创建一项，但是很多资源，例如文件描述符列表、进程空间，还是共享的，只不过多了一 个引用而已。上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线 程。一台机器无法创建很多进程或者线程。有个C10K，它的意思是一台机器要维护 1 万个连接，就要创 建 1 万个进程或者线程，那么操作系统是无法承受的。如果维持 1 亿用户在线需要 10 万台服务器，成 本也太高了。 方式三：一个项目组支撑多个项目（IO 多路复用，一个线程维护多个 Socket） 第一印象：由于 Socket 是文件描述符，因而某个线程盯的所有的 Socket，都放在一个文件描述符集合 fd_set 中， 这就是项目进度墙，然后调用 select 函数来监听文件描述符集合是否有变化。一旦有变化，就会依次查看每个文件描述符。那些发生变化的文件描述符在 fd_set 对应的位都设为 1，表示 Socket 可读或者可 写，从而可以进行读写操作，然后再调用 select，接着盯着下一轮的变化。重温：一旦某个项目有了进展，就派人去盯一下。 方式四：一个项目组支撑多个项目（IO 多路复用，从“派人盯着”到“有事通知”） 第一印象：使用 select，能够同时盯的项目数量由 FD_SETSIZE 限制。项目组不需要通过轮询挨个盯着这些项目，而是当项目进 度发生变化的时候，主动通知项目组。函数叫 epoll，它在内核中的实现不是通过轮询的方式，而是通过注册 callback 函数 的方式，当某个文件描述符发送变化的时候，就会主动通知。 重温：如图所示，假设进程打开了 Socket m, n, x 等多个文件描述符，现在需要通过 epoll 来监听是否这些 Socket 都有事件发生。其中 epoll_create 创建一个 epoll 对象，也是一个文件，也对应一个文件描述 符，同样也对应着打开文件列表中的一项。在这项里面有一个红黑树，在红黑树里，要保存这个 epoll 要监听的所有 Socket。 当 epoll_ctl 添加一个 Socket 的时候，其实是加入这个红黑树，同时红黑树里面的节点指向一个结构， 将这个结构挂在被监听的 Socket 的事件列表中。当一个 Socket 来了一个事件的时候，可以从这个列表 中得到 epoll 对象，并调用 call back 通知它。这种通知方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数 目也非常的多了。上限就为系统定义的、进程打开的最大文件描述符个数。因而，epoll 被称为解决 C10K 问题的利器。 总结与实践 第一印象：你需要记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调用哪些函数； 写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而 epoll 机制能解决 C10K 问题。重温：1. epoll 是 Linux 上的函数，那你知道 Windows 上对应的机制是什么吗？如果想实现一个跨平台的程序，你知道应该怎么办吗？ 2. 自己写 Socket 还是挺复杂的，写个 HTTP 的应用可能简单一些。那你知道 HTTP 的工作机制吗？ 第14讲 | HTTP协议：看个新闻原来这么麻烦自我总结 HTTP 请求的准备 第一印象：在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样建立的 TCP 连接，就可以在多次请求中复用。重温：TCP 的三次握手和四次挥手，还是挺费劲的。好不容易建立了连接，然后就做了一点儿事情就结束了，有点儿浪费人力和物力。 HTTP 请求的构建 第一印象：连接以后，浏览器发送HTTP 请求，请求格式如下：重温：第一部分是请求行，第二部分是请求的首部，第三部分才是请求的正文实体。 第一部分：请求行 第一印象：版本1.1之类的，重要的是方法，有GET、POST、PUT、DELETE重温：GET 就是去服务器获取一些资源，到底要返回什么，是由服务器端的实现决定的；POST 需要主动告诉服务端一些信息，而非获取。要告诉服务端什么呢？一般会放 在正文里面。正文可以有各种各样的格式。常见的格式也是 JSON；PUT，就是向指定资源位置上传最新内容， PUT 和 POST 就都变成了要传给服务器东西的方法。POST 往往是用来创建一个资源的，而 PUT 往往是用来修改一个资源的；DELETE， 这个顾名思义就是用来删除资源的。 第二部分：首部字段 第一印象：首部是 key value，通过冒号分隔。保存了一些非常重要 的字段。 Accept-Charset，表示客户端可以接受的字符集。Content-Type是指正文的格式。重点说一下的就是缓存。缓存用于小部分内容更改需要更新整个页面，对于高并发场景下的系统。Nginx 这一层如何处理 HTTP 协议呢？对于静态资源，有 Vanish 缓存层。当缓存过期的时候，才会访问真正的 Tomcat 应用集群。 Cache-control是用来控制缓存的。重温：If-Modified-Since也是一个关于缓存的。我们仅仅是拼凑起了 HTTP 请求的报文格式，接下来，浏览器会把它交给下一层传输层。 HTTP 请求的发送 第一印象：到了 TCP 层，它会把二进制流变成一个的报文段发送给服务器。主要是 TCP 埋头苦干，涉及MAC、IP、ARP 等，这样路由器一跳一跳终于到达目标的局域网。在这个局域网上发送 ARP，获得这个目标地址的 MAC 地址，将包 发出去。重温：目标的机器发现 MAC 地址符合，就将包收起来；发现 IP 地址符合，根据 IP 头中协议项，知道自己上 一层是 TCP 协议，于是解析 TCP 的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是 就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号。于是，目标机器自然知道是 HTTP 服务 器这个进程想要这个包，于是将包发给 HTTP 服务器。HTTP 服务器的进程看到，原来这个请求是要访 问一个网页，于是就把这个网页发给客户端。 HTTP 返回的构建 第一印象：状态码会反应 HTTP 请求的结果。短语会大概说一下原因。 返回首部的key value。这前后说了发送和返回的完整过程。重温：Retry-After表示，告诉客户端应该在多长时间以后再次尝试一下。Content-Type，表示返回的是 HTML，还是 JSON。还是交给 Socket 去发送，还是交给 TCP 层，TCP 层将返回的 HTML，也分成一个个小的段，并且保证每个段都可靠到达。这些段加上 TCP 头后会交给 IP 层，然后把刚才的发送过程反向走一遍。 HTTP 2.0 第一印象：HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那样一去一回。这样在实时性、并发性上都存在问题。 HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引。 HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户 端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。 HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。重温：通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二 进制传输。这些帧可以打散乱序发送， 然后根据每个帧首部的流标识符重新组装，并且可以根据优先 级，决定优先处理哪个流的数据。假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发 送多个请求或回应，而且不用按照顺序一对一对应。HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多 条 TCP 连接来实现并行请求与响应；减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。 QUIC 协议的“城会玩” 第一印象：HTTP 2.0 虽然大大增加了并发性，但还是有问题的。因为 HTTP 2.0 也是基于 TCP 协议的，TCP 协议 在处理包时是有严格顺序的。重温：机制一：自定义连接机制；机制二：自定义重传机制；机制三：无阻塞的多路复用；机制四：自定义流量控制（这部分讲解过于详细，有用再看吧） 总结与实践 第一印象：HTTP 协议虽然很常用，也很复杂，重点记住 GET、POST、 PUT、DELETE 这几个方法，以及重要的首部字段；HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升 性能。重温：]]></content>
      <categories>
        <category>network</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法记录]]></title>
    <url>%2F2019%2F12%2Fyuque%2Fqrw3ty%2F</url>
    <content type="text"><![CDATA[算法的阅读学习 28|堆和堆排序：为什么说堆排序没有快速排序快？自我总结 如何理解“堆” 第一印象：堆是一个完全二叉树，堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值重温：如此分成了大项堆和小项堆 如何实现一个堆？ 1.往堆中插入一个元素 第一印象：调整的方法：堆化，从下往上的方法，插入一个元素时，使用从下往上的方法，对比然后交换。重温：堆化从上往下的方法：一般用于删除堆顶元素，不用于插入一个元素 2.删除堆顶元素 第一印象：删除堆顶元素后，如果不将尾元素上提， 就从上往下交换，可能堆化出来的堆并不满足完全二叉树的性质重温：所以只能采用堆化从上往下的方法：删除堆顶元素，将顶部元素删除，将最后一个元素提上去，从上往下对比交换。 如何基于堆实现堆排序 1.建堆 第一印象：第一种方式：采用插入的那种方法，从前往后处理数组数据，从下往上堆化。第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化（注意，没有排序就不是绝对有序，只是相对有序一点）重温：因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从第一个非叶子节点开始，依次堆化就行了。堆排序的建堆过程的时间复杂度是O(n)（采用递归树的方式来理解） 2.排序 第一印象：类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为n的元素放到堆顶，然后再通过堆化的方法，将剩下的n−1个元素重新构建成堆，堆化完成之后，我们再取堆顶的元素，放到下标是n−1的位置，一直重复这个过程，直到最后堆中只剩下标为1的一个元素（大项堆，数组结果是从小到达排列）重温：建堆过程的时间复杂度是O(n)，排序过程 的时间复杂度是O(nlog n)，所以，堆排序整体的时间复杂度是O(nlog n)。原地排序、不稳定算法。 解答开篇&amp;内容小结&amp;课后思考 第一印象：第一点，堆排序数据访问的方式没有快速排序友好。第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。重温：堆排序来说，数据是跳着访问的，对CPU缓存是不友好的、快速排序数据交换的次数不会比逆序度多。 但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。 额外知识 1 下标从n/2+1到n的都是叶子节点 使用数组存储表示完全二叉树时，从数组下标为1开始存储数据，数组下标为i的节点，左子节点为2i, 右子节点为2i + 1. 这个结论很重要（可以用数学归纳法证明)，将此结论记为『原理1』，以下证明会用到这个原理。为什么，对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点？ 使用反证法证明即可：如果下标为n/2 + 1的节点不是叶子节点，即它存在子节点，按照『原理1』，它的左子节点为：2(n/2 + 1) = n + 2，大家明显可以看出，这个数字已经大于n + 1，超出了实现完全二叉树所用数组的大小（数组下标从1开始记录数据，对于n个节点来说，数组大小是n + 1），左子节点都已经超出了数组容量，更何况 右子节点。以此类推，很容易得出：下标大于n/2 + 1的节点肯定都是也叶子节点了，故而得出结论：对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶 子节点备注下：用数组存储表示完全二叉树时，也可以从下标为0开始，只是这样做的话，计算左子节点时，会多一次加法运算 2 堆，你还能想到它的其他应用1）从大数量级数据中筛选出top n 条数据； 比如：从几十亿条订单日志中筛选出金额靠前的1000条数据 2） 在一些场景中，会根据不同优先级来处理网络请求，此时也可以用到优先队列(用堆实现的数据结构)；比如：网络框架Volley就用了Java中PriorityBlocking Queue，当然它是线程安全的 3） 可以用堆来实现多路归并，从而实现有序，leetcode上也有相关的一题：Merge K Sorted Lists。 29|堆的应用：如何快速获取到Top10最热门的搜索关键词？自我总结 堆的应用一：优先级队列 第一印象：合并小文件：假如有100个小文件，在100的数组中遍历出最小数，不如在100个数的小项堆进行删除然后添加最小文件中的下一个字符串，从上向下调整。重温：高性能计时器：越小越紧急，每一秒扫描一次或者执行任务后扫描数组有两个问题，一很多时间是不用扫描的，二，时间多太浪费时间。实质上和合并小文件一样。不一样就是删除后，要用尾元素补上堆顶元素，然后排序。 堆的应用二：利用堆求Top K 第一印象：静态集合：维护一个大小为 K 的堆，然后存储后，采用堆排序的方法，排序到数组中，就是按顺序的Top K，n个元素都入堆一次，时间复杂度就是 O(nlogK)。重温：动态集合：此时更能体现堆的好处，如果每次获取Top K都用静态的方法，实际上是 O(nlogk)，但是我们实际只需要将新插入的元素和堆顶进行比较即可，初次是O(nlogk)，后面是O(1)或O(logk) 堆的应用三：利用堆求中位数 第一印象：中位数：偶数：前n/2是大项堆，后n/2是小项堆，奇数：前n/2+1是大项堆，后n/2是小项堆。插入数据：小于等于大项堆顶放在大项堆，大于等于小项堆顶放在小项堆。数据不一致是要调整。维护要O(logk)，查询要O(1)重温：类中位数：如何快速求接口的99%响应时间？要点：注意保持 99:1 的关系。不管是维护还是区分要保持基本的中位数维护方式，数据不一致要调整，维护和查询一样。 解答开篇&amp;内容小结&amp;课后思考 第一印象：高级方法：MapReduce等，限制单机和内存为1G；考虑重复，使用散列表、平衡二叉树或者一些其他支持快速查找、插入的数据结构，前者将散列表前10取出可以解决问题，但是考虑内存，考虑将文件利用哈希算法分成10等分，就是哈希值对10取模，然后得到对应的文件编号。重温：有一个访问量非常大的新闻网站，我们希望将点击量排名Top 10的新闻摘要，滚动显示在网站首页banner上，并且每隔1小时更新一次。如果你是负责开发这个功 能的工程师，你会如何来实现呢？ 额外知识 30|图的表示：如何存储微博、微信等社交网络中的好友关系？自我总结 如何理解图？ 微信：无向图，引出顶点和边；微博：有向图，引出出度和入度；QQ：亲密度，引出带权图和权重 邻接矩阵的存储方法 第一印象：浪费存储空间，尤其是稀疏矩阵；但是有利于数学运算，方便存储管理重温：只有0和1，无向图对角线的另一半是无用的，微信几百个好友，但是用户上亿，就像稀疏矩阵一样浪费。 邻接表的存储方法 第一印象：表指链表，节省空间，重温：一排然后存值，有点像散列表，区别就是图的分布更合理点。空间换时间：2-4有无边，靠遍历2对应的链表。链表存储对缓存不友好，链表可以转换成平衡二叉树，红黑树，方便查找亮点是否有边，二叉查找树还可以变成跳表，链表可变为有序动态数组，二分查找来快速定位两个顶点是否存在变。 解答开篇：如何存储好友关系 第一印象：逆邻接表，哈希算法，外部存储重温：先考虑关系，再考虑粉丝列表和关注列表。按首字母排序，所以选择跳表，内部有序，排除了红黑树，有序动态数组和散列表。几十万用户存在内存还可以考虑，数据规模大，要通过哈希算法分片，先定位机器，再在相应机器上查找。利用外部存储，则使用数据库来持久化存储关系数据，我们可以建立两行索引，解决问题。 额外知识 1 Floyd-warshall算法 Floyd-Warshall算法是解决任意两点间的最短路径的一种算法。通常可以在任何图中使用，包括有向图、带负权边的图。 它需要用邻接矩阵来储存边，这个算法通过考虑最佳子路径来得到最佳路径。 2 31|深度和广度优先搜索：如何找出社交网络中的三度好友关系？自我总结 什么是“搜索”算法？ 第一印象：广度和深度都是暴力方法，要充分理解邻接表，针对无向图重温：要先实现无向图，并可以初始化，不是简单地定义就好，需要有一系列方法 广度优先搜索（BFS） 第一印象：visited：布尔类型数组，记录已经被访问的点，考虑邻接表中的情况；queue：用来记录已经被访问却没有以它开始访问的点，是整型数组；prev：反向存储路径，是整型数组重温：时间复杂度O(V+E) &lt;O(2E)=O(E)，空间复杂度是O(V) 深度优先搜索（Depth-First-Search） 第一印象：迷宫、递归、特殊变量found、回溯法重温：每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是O(E)；递归调用栈的最大深度不会超过顶点的个 数，所以总的空间复杂度就是O(V) 解答开篇：如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？ 第一印象：广度优先算法重温：用一个数组来记录每个顶点与起始顶点的距离，非常容易就可以找出三度好友关系 额外知识 2 考虑一下递归时，关键语句应该放在哪里，比如说dfs的 visited 的位置 3 4 我感觉用深度优先查找人脉的算法可能会把小于这个度数的数据查找出来吧，例如查找度数为3的顶点，用文中广度优先搜索的那个数据，使用深度优先的 算法会把0，1，4，3也给查出来。。 32|字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？自我总结 BF 算法？ 第一印象：brute force 暴力破解的方法，就是 n-m+1 个子串每一个都遍历子串的长度来匹配，nm，适合小规模的数据重温：nm ，中途遇到不能匹配的就停止了，所以实际要比理论快。KISS 原则：在满足性能要求的前提下，简单是首选。 RK 算法 第一印象：利用到了哈希算法，利用数学关系，可以将两个相邻的模式串用1的时间复杂度算出，整体是n-m+1。可以转换为26进制，能保障所有数字不重复。重温：每个模式串变成一个整型，比较时效率提高，但是哈希算法消耗了时间，因为哈希算法要遍历每一个字符，转换成26进制，将26的次方保存，计算哈希值利用推导公式将n*m降低到n。进制表示不会有散列冲突。但是要存储的值范围太大，可能不在整型范围内，可以每个字母对一个素数。可以利用哈夫曼树，给大素数分配小值，牺牲冲突，实现整型，冲突少，简单比较一下也是可以接受的。 解答开篇：那RK算法是如何借助哈希算法来实现 高效字符串匹配的呢？ 第一印象：数学、空间、时间相结合产生的巧妙哈希算法。问题中应该采用二层循环来求取哈希值匹配。时间复杂度为 M-m+1 * N-n+1。当N 和 n等于一是就是PK算法。重温：理想情况下是n。存在冲突可能会退化。大量冲突可能会变成 BF 。我觉得题目中的问题倒还挺难实现 33|字符串匹配基础（中）：如何实现文本编辑器中的查找功能？自我总结 BM算法的核心思想 第一印象：从后往前遍历，不像 BF、Rk算法一次遍历一个，而是尽量多跳过去不可能的字符移动重温：它的效率来自于这样的事实：对于每一次失败的匹配尝试，算法都能够使用这些信息来排除尽可能多的无法匹配的位置。 BM算法原理分析 坏字符规则 第一印象：从后往前遍历，但是可能会出现移动为负数的情况，这个时候加个判断语句好像是可以的哎，si-xi，记为最先，x记为未知。相减是为了产生移动的数字 好后缀规则 第一印象：一、好后缀中模式串遇到坏字符之后的后缀时，将模式串靠后匹配的一个匹配后缀，移动到主串匹配处。二、但是会出现主串后缀的后缀和模式串的前缀相重合的特例，此时不能因为无匹配直接移动，需要一点点查看后缀的后缀和模式串的前缀是否重合重温：我们可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数 BM算法代码实现之坏字符规则 第一印象：i = i+(j-bc[(int)a[i+j]]); 实质上是将i的值更新，是模式串和主串对齐的位置往前推进重温：先不考虑 si-xi 为负数的情况，因为要和好后缀原则取最大值，这里是巧用ascii码的方法很重要，基本上涉及字符串也没有说不涉及ascii码的地方吧 BM算法代码实现之好后缀规则 第一印象：通过长度我们可以确定一个唯一的后缀字串，prefix和suffix的计算非常巧妙，一个是长度索引值存最靠后下标，一个是存取的是能否使后缀子串和前缀子串匹配的布尔值。模式串和子串求公共后缀子串长度为k，若求得的起始值是0，则直接记录prefix[k]=true重温：好后缀的后缀子串b[r, m-1]（其中，r取值从j+2到m-1）的长度k=m-r，这里的r取值 j+2 是因为是子串。如果坏字符与好后缀都不匹配，则往后移动m位。suffix查找跟好后缀匹配的另一个子串，prefix记录模式串的后缀子串是否能匹配模式串的前缀子串 BM算法的性能分析及优化 第一印象：字符集很大，则坏字符算法会浪费内存，因为字符集可能大于255这个数字，只使用好后缀原则可以减少bc数组内存消耗，但是效率会下降一点。这还是初级版本。。。。重温：模式串是aaaaaaa这种包含很多重复的字符的模式串，预处理计算suffix数 组、prefix数组的时间复杂度就是O(m^2)。这种情况显然可以优化， 解答开篇&amp;内容小结&amp;课后思考 第一印象：一些文本编辑器中比较常用，坏字符与好后缀规则重温：核心思想，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位。 额外知识 1 BWT-FM算法 Burrows–Wheeler Transform（简称BWT，也称作块排序压缩），是一个被应用在数据压缩技术（如bzip2）中的算法。该算法于1994年被Michael Burrows和David Wheeler在位于加利福尼亚州帕洛阿尔托的DEC系统研究中心发明[1]。它的基础是之前Wheeler在1983年发明的一种没有公开的转换方法。当一个字符串用该算法转换时，算法只改变这个字符串中字符的顺序而并不改变其字符。如果原字符串有几个出现多次的子串，那么转换过的字符串上就会有一些连续重复的字符，这对压缩是很有用的。该方法能使得基于处理字符串中连续重复字符的技术（如MTF变换和游程编码）的编码更容易被压缩。举个例子： 算法输入 SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES 算法输出 TEXYDST.E.IXIXIXXSSMPPS.B..E.S.EUSFXDIIOIIIT 该算法的输出因为有更多的重复字符而更容易被压缩了。 34|字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法？自我总结 KMP算法的基本原理 第一印象：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？重温：最长可匹配前缀子串引出失效函数数组，KMP算法中其实相当于只有坏字符原则 失效函数计算方法 第一印象：利用次长可匹配前缀子串，来不断寻找下一个可以和b[i]相等的数的下表，一层一层，节约时间重温：如果最长匹配子串的下一个字符和b[i]不等，那么要利用次长可匹配子串的下一个字符来进行匹配b[i]，最大程度上节约时间 KMP算法复杂度分析 第一印象：空间：O(m)， 时间：O(m+n)重温：时间复杂度不好计算，需要利用变量来思考，while循环里面k=next[k]总的执行次数也不可能超过m，这就有点需要头脑了 解答开篇&amp;内容小结&amp;课后思考 第一印象：都是找规律尽量往后多滑动几位重温：平常的开发中，很少会遇见这么难分析的代码 额外知识 1 k = next[k]最难理解的地方是 k = next[k] 因为前一个的最长串的下一个字符不与最后一个相等，需要找前一个的次长串，问题就变成了求0到next(k)的最长串，如果下个字符与最后一个不等，继续求次长串，也就是下一个next(k)，直到找到，或者完全没有。 35|Trie树：如何实现搜索引擎的搜索关键词提示功能？自我总结 什么是“Trie 树” 第一印象：字典树，树形结构，根节点不存储任何数据，字符是从小到大存储从左到右存储的。重温：如 he，最后一个节点不是红色，表明他是某个字符串的前缀子串，但并不能完全匹配任何字符串，但是显然可以搜索出来，所有红色节点不一定是叶子节点，有点不理解 如何实现一棵 Trie 树 第一印象：一个是将字符串集合构造成 trie树，一个是在trie树中查询一个字符串。trie树显然是一个多叉树重温：构建时生成一个节点，这个时候就会不断初始化，仔细敲一遍就会感到神奇。K的时间复杂度，构建起来一个Trie树确实时不错的。 Trie树真的很耗内存吗？ 第一印象：字符很少的情况下，26的数组浪费内存，重复前缀少的情况下，浪费空间。通常会有压缩，比如叶子节点只有一个会合并，等等情况重温：我们可以稍微牺牲一点查询的效率，将每个节点中数组换成其他数据结构，来存储一个节点的子节点指针，有序数组、跳表、散列表等。（要注意这些数据结构是如何存储一个节点的子节点指针的） Trie树与散列表、红黑树的比较 第一印象：字符集不能太大，否则存储空间浪费很多。前缀重合最好要多，从零开始实现一个Trie树，保证没有bug，其实不太值得，10万行的字符串也重在比较消耗，不在于硬件的缓冲了。重温：Trie 树中用到了指针，对缓存并不友好，Java代码中好像没体会到指针的地方，莫不是说它底部的垃圾回收等优化？？？ 解答开篇&amp;内容小结&amp;课后思考 第一印象：不适合精确匹配，这问题设散列表或者红黑树 来解决，适合开篇的搜索引擎的那种场景。它在自己的场景中，还是很高效的。重温：平常的开发中，Trie树很难应用，中文，关键次很多，如何展示、拼写错误等问题，IDE 代码编辑器自动补全，利用的是语法树，也可以是字典树。 额外知识 36|AC自动机：如何用多模式串匹配实现敏感词过滤功能？自我总结 基于单模式串和Trie树实现的敏感词过滤 第一印象：基于Trie树的处理办法，有点类似单模式匹配的BF算法。（用户输入的所有字符形成主串，当匹配到Trie的叶子节点，或者中途遇到不匹配的时候，我们将主串的开始匹配位置后移一位）重温：KMP算法对BF算法进行改进，引入了nex数组，AC自动机算法改进的思路类似，引入了失败指针的思想。 经典的多模式串匹配算法：AC自动机 第一印象：构建包含两个操作：一、将多个模式串构建成 Trie 树；二、在Trie 树上构建失败指针（这个是重难点）4个模式串，分别是c，bc，bcd，abcd；主串是abcd，p的失败指针就是从root走到紫色节点形成的字符串abc，跟所有模式串前缀匹配的最长可匹配后缀子 串，就是箭头指的bc模式串。 字符串abc的后缀子串有两个bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前 缀，那我们就把这个后缀子串叫作可匹配后缀子串。我们从可匹配后缀子串中，找出最长的一个，就是刚刚讲到的最长可匹配后缀子串。如果我们把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上 一层。（这里为什么不可能是上两层呢）当我们要求某个节点的失败指针的时候，我们通过已经求得的、深度更小的那些节点的失败指针来推导。也就是说，我们可以逐层依 次来求解每个节点的失败指针。所以，失败指针的构建过程，是一个按层遍历树的过程。（较容易理解的倒推过程）如果节点q中没有子节点的字符等于节点pc包含的字符，则令q=q-&gt;fail（这里是较难理解的地方，结合下图可以看出，这里类似于KMP算法中的倒推过程，找到是上一层的优化结果，而不是一个个遍历，这也是优化的所在），继续上面的查找，直 到q是root为止，如果还没有找到相同字符的子节点，就让节点pc的失败指针指向root。过程简述： 如果p指向的节点有一个等于b[i]的子节点x，我们就更新p指向x，这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。这一 句不好理解，你可以结合代码看。处理完之后，我们将i加一，继续这两个过程； 如果p指向的节点没有等于b[i]的子节点，那失败指针就派上用场了，我们让p=p-&gt;fail，然后继续这两个过程。 重温：代码较为难以理解，要多看一下，多实践一下 解答开篇&amp;内容小结&amp;课后思考 第一印象：你只需要稍加改造，再遍历一遍文本内容（主串），就可以将文本中的所有敏感词替换成“”。（这里的模式和主串的关系和KMP中的好像正好相反），Trie树构建的时间复杂度是O(mlen)，其中len表示敏感词的平均长度，m表示敏感词的个数。（敏感词就是文中的模式串）Trie树中总的节点个数是k，整个失败指针的构建过程就是O(klen)，所以总的 匹配的时间复杂度就是O(nlen)，实际情况下，可能近似于O(n)，所以AC自动机做敏感 词过滤，性能非常高。重温**：从时间复杂度上看，AC自动机匹配的效率跟Trie树一样啊。实际上，因为失效指针可能大部分情况下都指向root节点，所以绝大部分情况下， 在AC自动机上做匹配的效率要远高于刚刚计算出的比较宽泛的时间复杂度。整个AC自动机算法包含两个部分，第一部分是将多个模式串构建成AC自动机，第二部分是在AC自动机中匹配主串。第一部分又分为两个小的步骤，一个是将模 式串构建成Trie树，另一个是在Trie树上构建失败指针。（最起码要说出这个过程，细节且不论） 37贪心算法：如何用贪心算法实现Huffman压缩编码？自我总结 如何理解贪心算法 第一印象：主要是两点：一、在最大的限制值中取得最大的效益（可能就是每单位取最大利益的优先这种，算个除法即可）。二、找几个例子验证一下即可。因为贪心算法验证比较困难。重温：前面的选择会影响后面的选择，所以不能使用贪心，动态规划可能可以解决。 贪心算法实战分析 第一印象：分糖果（一定量的糖果，满足更多小孩对糖的相应需求，需求小的优先）、钱币找零（满足花更少纸币获取物品的需求，面值大的优先，有点反过来的感觉）、区间覆盖（一个区间内，不相交的小区间数更多，和分糖果思想类似，细节要多点）重温：区间覆盖：教师排课，任务调度等（不能满足优先级的要求）。细节：左端点跟前面的已覆盖的不重合，右端点尽量小的。 解答开篇 第一印象：等长的压缩效率不高，不等长要考虑如何解压的问题。引出哈夫曼树的要点：为了避免解压缩过程中的歧义，任何一个字符的编码都不是另一个的前缀。解压缩时尽可能读，一般读到第一个1打住。构造用到优先级队列和二叉树。构造完毕，最靠前的分配给频率最高的，左0右1这样分配即可。重温：具体理解：1000字符，原本要8000bit，加入只有5种字母，3位等长二进制可描述，3000bit，根据哈夫曼变长存储，例子给的结果时2100bit。从优先级队列中取最小的两个形成3个结点，然后从队列中继续取最小的一个继续构造。 内容小结&amp;课后思考 第一印象：使用场景有限，最小生成树，单源最短路径算法用到了贪心算法。多练习才是最重要的，贪心的难点在构造模型，代码一般很简单。重温：非负整数a中，我们希望从中移除k个数字，让剩下的数字值最小，如何选择移除哪k个数字呢？由最高位开始，比较低一位数字，如高位大，移除，若高位小，则向右移一位继续比较两个数字，直到高位大于低位则移除，删除k次。如果高位到低位依次变大，则移除前k位（在尽量高的位置移除尽量大的数字，最后移除k位的位数是一定的，尽量高位，则跟前后比较即可。这个贪心算法有点模糊） 38分治算法：谈一谈大规模计算框架MapReduce中的分治思想自我总结 如何理解分治算法 第一印象：分而治之，将原问题划分成n个规模较小，并且结构与原问题相似的子问题，递归地解决这些 子问题，然后再合并其结果，就得到原问题的解。分治算法是一种处理问题的思想，递归是一种编程技巧。每一层递归都涉及：分解、解决、合并。重温：其能解决的问题一般满足下面几个条件：原问题与分解成的小问题具有相同的模式；原问题分解成的子问题可以独立求解，子问题之间没有相关性；具有分解终止条件；可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果。 分治算法应用举例分析 第一印象：逆序对数的求解。重温：还有两道比较经典的问题，你可以自己练习一下。暴力法的操作的时间复杂度是O(n^2)。我们套用分治的思想来求数组A的逆序对个数。我们可以将数组分成前后两半A1和A2，分别计算A1和A2的逆序对个数K1和K2，然后再 计算A1与A2之间的逆序对个数K3。那数组A的逆序对个数就等于K1+K2+K3。在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。 二维平面上有n个点，如何快速计算出两个距离最近的点对？ 第一个求最近的点对 分成两块 单独求其中一块点对最小距离 然后求这两块之间点对的最小距离 通过一些排序和删除 可以减少到6个点之间比较 很神奇https://www.jianshu.com/p/8bc681afbaff 中的反证法可以看一下理解一下，鸽舍原理也需要了解一下啊。 有两个nn的矩阵A，B，如何快速求解两个矩阵的乘积C=AB？ 第二个矩阵计算 v.斯特拉森提出了2*2分块矩阵的计算公式 从原来的8次乘法 缩减到了7次 当n规模很大的时候 缩减效果就很明显 （7/8）^(logn)https://blog.csdn.net/qq_18738333/article/details/51769524 可以参考这里说的原理，分治来算矩阵相乘的复杂度没有什么优化，而且要求是2的幂。但是确实减少了乘法和加法的运行。 分治思想在海量数据处理中的应用 第一印象：解决这种数据量大到内存装不下的问题，我们就可以利用分治的思想。将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集 合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。重温：如果订单数据存储在类似GFS这样的分布式系统上，当10GB的订单被划分成多个小文件的时候，每个文件可以并行加载到多台机器上处理，最后再将结果合并在 一起，这样并行处理的速度也加快了很多。 解答开篇&amp;内容小结&amp;课后思考 第一印象：对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用 集群并行处理显然是大势所趋。重温：两种分治算法的典型的应用场景，一个是用来指导编码，降低问题求解的时间复杂度，另一个是解决海量数据处理问题。比如MapReduce本质上就是 利用了分治思想。 39回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想自我总结 如何理解回溯算法 第一印象：有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。重温：回溯算法非常适合用递归代码实现。八皇后中的8^8次方，递归的方式值得学习一下 经典应用之0-1背包 第一印象：物品是不可分割的，要么装要么不装，所以叫0-1背包问题。对于n个物品来说，总的装法就有2^n种，去掉总重量超过Wkg的，从剩下的装法中选择总重量最 接近Wkg的。重温：这里还稍微用到了一点搜索剪枝的技巧，就是当发现已经选择的物品的重量超过Wkg之后，我们就停止继续探测剩下的物品。 经典应用之正则表达式 第一印象：假设正表达式中只包含“”和“?”这两种通配符，并且对这 两个通配符的语义稍微做些改变，其中，“”匹配任意多个（大于等于0个）任意字符，“?”匹配零个或者一个任意字符。重温：代码主要内容就是对这两个通配符进行回溯，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一 种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。 解答开篇&amp;内容小结&amp;课后思考 第一印象：在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。重温：深度优先搜索、八皇后、0-1背包问题、图的着色、旅行商问题、数独、全排列、 正则表达式匹配等等，你可以自己搜索研究一下，最好还能用代码实现一下。 40初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？自我总结淘宝的“双十一”购物节有各种促销活动，比如“满200元减50元”。假设你女朋友的购物车中有n个（n&gt;100）想买的商品，她希望从里面选几个，在凑够满减条件的 前提下，让选出来的商品价格总和最大程度地接近满减条件（200元），这样就可以极大限度地“薅羊毛” 动态规划学习路线 第一印象：求解问题的过程不太符合人类常规的思维方式。入门确实有点难度，但是难了不会，会了不难。这三节分别是，初识动态规划、动态规划理论、动态规划实战。重温：第一节，我会通过两个非常经典的动态规划问题模型，向你展示我们为什么需要动态规划，以及动态规划解题方法是如何演化出来的；第二节，我会总结动态规划适合解决的问题的特征，以及动态规划解题思路；第三节，我会教你应用第二节讲的动态规划理论知识，实战解决三个非常经典的动态规划问题，加深你对理论的理解。弄懂了这三节中的例子，对于动态规划这 个知识点，你就算是入门了。 0-1背包问题 第一印象：从回溯法展示递归树，重复的计算通过“备忘录”来标记，然后引入动态规划。我们把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。重温：我们用一个二维数组states[n][w+1]，来记录每层可以达到的不同状态。 我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的）， 然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。这也是动态规划这个名字的由来，你可以自己体会一下，是不是还挺形象的？ 动态规划状态转移的过程，都可以基于这个一维数组来操作 0-1背包问题升级版 第一印象：我们现在引入物品价值这一变量。对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品 装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？重温：同样是回溯法展示递归树，但是没法使用备忘录了，使用动态规划可以解决这个问题，但是存储数组不是boolean类型的了，而是当前状态对应的最大总价值。 解答开篇&amp;内容小结 第一印象：它跟第一个例子中讲的0-1背包问题很像，只不过是把“重量”换成了“价格”而已。购物车中有n个商品。我们针对每个商品都决策是否购买。每次决策之 后，对应不同的状态集合。我们还是用一个二维数组states[n][x]，来记录每次决策之后所有可达的状态。x根据情况来判断。状态(i, j)只有可能从(i-1, j)或者(i-1, j-value[i])两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是states[i-1][j]或者states[i-1][j-value[i]]是否 是true。重温：这两个例子都是非常经典的动态规划问题，只要你真正搞懂这两个问题，基本上动态规划已经入门一半了。所以，你要多花点时间，真正弄懂这两个问题。我个人觉得，贪心、分治、回溯、 动态规划，这四个算法思想有关的理论知识，大部分都是“后验性”的，也就是说，在解决问题的过程中，我们往往是先想到如何用某个算法思想解决问题，然后 才用算法理论知识，去验证这个算法思想解决问题的正确性。 课后思考 第一印象：“杨辉三角”不知道你听说过吗？我们现在对它进行一些改造。每个位置的数字可以随意填写，经过某个数字只能到达下面一层相邻的两个数字。 假设你站在第一层，往下移动，我们把移动到最底层所经过的所有数字之和，定义为路径的长度。请你编程求出从最高层移动到最底层的最短路径长度。重温： 41动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题自我总结主要讲动态规划的一些理论知识 “一个模型三个特征”理论讲解 第一印象：多阶段决策最优解模型：每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。什么是“三个特征”？它们分别是最优子结构、无后效性和重复子问题。重温：最优子结构指的是，问题的最优解包含子问题的最优解，可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来；无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响；重复子问题，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。 “一个模型三个特征”实例剖析 第一印象：假设我们有一个n乘以n的矩阵w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右 或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。重温：我们想要计算(i, j)位置对应的状态，只需要关心(i-1, j)，(i, j-1)两个位置 对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j)) 两种动态规划解题思路总结之状态转移表法 第一印象：通过回溯法画出状态的递归树，从递归树中找到重复子问题是如何产生的，来寻找规律。高维状态转移表不好画图表示，所以复杂的较难想到。重温：状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码。 两种动态规划解题思路总结之状态转移方程法 第一印象：状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解。如：min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))重温：写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。你要结合具体的题目来看，到底选择用哪种解题思路。 四种算法思想比较分析 第一印象：贪心、回溯、动态规划可以归为一类，都可以抽象多阶段决策最优解模型；而分治单独可以作为一类。尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。重温：回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索；并不是所有问题，都可以用动态规划来解决。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题；贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。 内容小结&amp;&amp;课后思考 第一印象：状态转移表法解题思路大致可以概括为，回溯算法实现-定义状态-画递归树-找重复子问题-画状态转移表-根据递推关系填表-将填表过程翻译成代码。状态转移方程法的大致思路可以概括为，找最优子结构-写状态转移方程-将状态 转移方程翻译成代码。重温：硬币找零问题，我们在贪心算法那一节中讲过一次。我们今天来看一个新的硬币找零问题。假设我们有几种不同币值的硬币v1，v2，……，vn（单位是元）。如 果我们要支付w元，求最少需要多少个硬币。比如，我们有3种不同的硬币，1元、3元、5元，我们要支付9元，最少需要3个硬币（3个3元的硬币）。 42动态规划实战：如何实现搜索引擎中的拼写纠错功能？自我总结当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。作为一名软件开发工程师，你是否想过，这个功能是怎么实现的呢？ 如何量化两个字符串的相似度？ 第一印象：有一个非常著名的量化方法，那就是编辑距离（Edit Distance）。编辑距离指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离有多种不同的计算方式，比较著名的有莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）。重温：莱文斯坦距离允许增加、删除、 替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。 如何编程计算莱文斯坦距离？ 第一印象：回溯是一个递归处理的过程。如果a[i]与b[j]匹配，我们递归考察a[i+1]和b[j+1]。如果a[i]与b[j]不匹配，那我们有多种处理方式可选： 可以删除a[i]，然后递归考察a[i+1]和b[j]； 可以删除b[j]，然后递归考察a[i]和b[j+1]； 可以在a[i]前面添加一个跟b[j]相同的字符，然后递归考察a[i]和b[j+1]; 可以在b[j]前面添加一个跟a[i]相同的字符，然后递归考察a[i+1]和b[j]； 可以将a[i]替换成b[j]，或者将b[j]替换成a[i]，然后递归考察a[i+1]和b[j+1]。重温：根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。如果：a[i]!=b[j]，那么：min_edist(i, j)就等于： min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1) 如果：a[i]==b[j]，那么：min_edist(i, j)就等于： min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))技巧：我们可以实例化几个测试数据，通过人脑去分析具体实例的解，然后总结规律，再尝试套用学过的算法，看是否能够解决；还有一个非常有效、但也算不上技巧的东西，我也反复强调过，那就是多练。 如何编程计算最长公共子串长度？ 第一印象：如果我们要求a[0…i]和b[0…j]的最长公共长度max_lcs(i, j)，我们只有可能通过下面三个状态转移过来： (i-1, j-1, max_lcs)，其中max_lcs表示a[0…i-1]和b[0…j-1]的最长公共子串长度； (i-1, j, max_lcs)，其中max_lcs表示a[0…i-1]和b[0…j]的最长公共子串长度； (i, j-1, max_lcs)，其中max_lcs表示a[0…i]和b[0…j-1]的最长公共子串长度。重温：用状态转移方程写出来，就是下面这个样子： 如果：a[i]==b[j]，那么：max_lcs(i, j)就等于： max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))； 如果：a[i]!=b[j]，那么：max_lcs(i, j) 就等于： max(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))； 解答开篇 第一印象：针对纠错效果不好的问题。我们并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。 我们还可以用多种编辑距离计算方法，比如今天讲到的两种，然后分别编辑距离最小的TOP 10，然后求交集，用交集的结果，再继续优化处理。 我们还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最长被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。 这样纠错的效果非常好。 我们还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，我们首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。重温：针对纠错性能方面，讲两种分治的优化思路。如果纠错功能的TPS不高，我们可以部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，我们通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词。 如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，我们可以将纠错的词库，分割到很多台机器。当有一个纠错请求的时候，我们就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并 行处理，分别得到编辑距离最小的单词，然后再比对合并，最终决定出一个最优的纠错单词。 内容小结&amp;&amp;课后思考 第一印象：这三节中，加上课后思考题，总共有8个动态规划问题。这8个问题都非常经典，是精心筛选出来的。只要弄懂了这几个问题，一般的动态规划问题，你应该都可以应付。对于动态规划这个知识点，你就算是入门了。重温：我们有一个数字序列包含n个不同的数字，如何求出这个序列中的最长递增子序列长度？比如2, 9, 3, 6, 5, 1, 7这样一组数字序列，它的最长递增子序列就是2, 3, 5, 7，所以最长递增子序列的长度是4。 额外知识 TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）43拓扑排序：如何确定代码源文件的编译依赖关系？自我总结 问题阐述 第一印象：编译器通过分析源文件或者程序员事先写好的编译配置文件（比如Makefile文件），来获取这种局部的依赖关系。那编译器又该如何通过源文件两两之间的局部依 赖关系，确定一个全局的编译顺序呢？重温： 算法解析 第一印象：拓扑排序本身就是基于有向无环图的一个算法。 Kahn算法：我们先从图中，找出一个入度为0的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来），并且把这个顶点从图中删除（也就是把这个顶点 可达的顶点的入度都减1）。我们循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。DFS算法：重温：第一部分是通过邻接表构造逆邻接表。邻接表中，边s-&gt;t表示s先于t执行，也就是t要依赖s。在逆邻接表中，边s-&gt;t表示s依赖于t，s后于t执行。为什么这么转化呢？ 这个跟我们这个算法的实现思想有关。 第二部分是这个算法的核心，也就是递归处理每个顶点。对于顶点vertex来说，我们先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己。复杂度都是O(V+E)（V表示顶点个数，E表示边的个 数） 总结引申 第一印象：凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。除此之外，拓扑排序还能检测图中环的存在。对于Kahn算法来说，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是0的顶点，那就说明，图中存在环。重温：只需要记录已经访问过的用 户ID，当用户ID第二次被访问的时候，就说明存在环，也就说明存在脏数据。 课后思考 第一印象：1. 在今天的讲解中，我们用图表示依赖关系的时候，如果a先于b执行，我们就画一条从a到b的有向边；反过来，如果a先于b，我们画一条从b到a的有向边，表 示b依赖a，那今天讲的Kahn算法和DFS算法还能否正确工作呢？如果不能，应该如何改造一下呢？ 2. 我们今天讲了两种拓扑排序算法的实现思路，Kahn算法和DFS深度优先搜索算法，如果换做BFS广度优先搜索算法，还可以实现吗？重温：1. a先于b执行，也就说b依赖于a，b指向a，这样构建有向无环图时，要找到出度为0的顶点，然后删除2. BFS也能实现，因为遍历只是实现拓扑排序的一个“辅助手段”，本质上是帮助找到优先执行的顶点1.kahn算法找出度为0的节点删除。dfs算法直接用正邻接表即可。2. BFS也可以。其实与DFS一样，BFS也是从某个节点开始，找到所有与其相连通的节点。区别在于BFS是一层一层找（递归函数在for循环外），DFS是先一 杆子插到底，再回来插第二条路、第三条路等等（递归函数在for循环内）。]]></content>
      <categories>
        <category>algo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JVM 记录]]></title>
    <url>%2F2019%2F12%2Fyuque%2Flhnbsd%2F</url>
    <content type="text"><![CDATA[JVM的知识记录 01 | Java代码是怎么运行的？自我总结 前言 第一印象：JRE，使Java代码可以双击执行jar文件运行，命令行运行，网页中运行等。JDK包含JRE、开发、诊断工具重温：运行 C++ 代码则无需额外的运行时环境，直接编译成机器码。 为什么要在Java虚拟机中运行？ 第一印象：通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，也称 Java 字节码；Java 字节码指令的操作码（opcode）被固定为一个字节。重温：JVM 带来了一个托管环境（Managed Runtime）、自动内存管理与垃圾回收、垃圾回收等调优，提供了数组越界、动态类型、安全权限等动态检测，使我们免于些无关业务逻辑的代码。 Java虚拟机是如何运行字节码的？ 第一印象：从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。Java 虚拟机会将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器。在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。重温：HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。 Java的运行效率究竟是怎么样的？ 第一印象：对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。重温：多个即时编译器：C1、C2 和 Graal。C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。 总结与实践 第一印象：可移植性、代码托管环境、运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。重温：了解使用了asmtools.jar的使用，Java 语言和 Java 虚拟机看待 boolean 类型的方式不同。JVM层次，(flag) 判断不为 0，则为true，所以输出；(flag == true) 判断不为1，不输出。 额外知识 Graal Graal 是 Java 10 正式引入的实验性即时编译器 02 | Java的基本类型]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL 记录]]></title>
    <url>%2F2019%2F12%2Fyuque%2Fthihkz%2F</url>
    <content type="text"><![CDATA[mysql 阅读记录 01 基础架构：一条SQL查询语句是如何执行的自我总结 整体概述 第一印象：客户端、连接器、查询缓存、分析器、优化器、执行器、存储引擎。不同的存储引擎共用一个server层，从连接器到执行器的部分。重温：存储引擎负责数据的存储和提取，架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。在create table语句中使用engine=memory, 来指定使用内存引擎创建表。 连接器 第一印象：show processlist命令可以展示连接的状态，如Sleep、Query；尽量使用长连接；你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。重温：长连接导致 MySQL 异常重启现象。（一般是线上问题）解决方法一：定期断开长连接。二：5.7 or 以上，mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，会将连接恢复到刚刚创建完时的状态。 查询缓存 第一印象：因为特别容易失效，所以尽量不要用。原理就是你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。命中缓存可以避免后续复杂操作，效率较高。但更新表则失效，压力大数据库很难命中。重温：除非系统配置表这种静态表可以考虑。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定。8.0将查询缓存删除。1mysql&gt; select SQL_CACHE * from T where ID=10； 分析器 第一印象：先词法分析，后语法分析。重温：词法分析比如select、字符串T识别成表名T；语法分析复合语法规则即可，关注报错语句中的use near即可。 优化器 第一印象：多个索引时，决定哪个索引；多表关联时，决定表连接顺序。重温：优化器和索引能扯上关系，后面应该会详细讲解这方面问题。 执行器 第一印象：首先，判断是否有权限，再者，打开表，会根据表的引擎定义，使用引擎接口；引擎扫描行数跟rows_examined并不是完全相同的。rows_examined字段，表示这个语句执行过程中扫描了多少行。在执行器每次调用引擎获取数据行的时候累加的。重温：使用引擎接口执行流程：调用引擎接口取此表第一行，不满足跳过，满足放入结果集（在执行器中？）；下一行执行相同操作，直至最后；满足条件的行组成的记录及作为结果集返回。 小结&amp;本期问题 第一印象：如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？重温： 额外知识 被系统强行杀掉（OOM） Out-of-Memory (OOM) Killer是一种保护机制，用于当内存严重不足时，为了系统的继续运转，内核迫不得已挑选一个进程，将其杀死，以释放内存，缓解内存不足的问题。可以看出这种方式对进程的保护是有限的，不能完全的保护进程的运行。 02 | 日志系统：一条SQL更新语句是如何执行的？自我总结更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。 重要的日志模块：redo log 第一印象：WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。重温：有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。 重要的日志模块：binlog 第一印象：1. redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的重温：最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。 两阶段提交 第一印象：先写 redo log 后写 binlog，binlog还没有写完的时候，MySQL进程异常重启。如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。先写binlog后写redo log，在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效。在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。重温：不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。 小结 第一印象：redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢。重温：那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？灾难发生的时候备份能救命，出现错误的时候备份能后悔。事情都有两面性，没有谁比谁好，只有谁比谁合适，完全看业务情况和需求而定。一天一备恢复时间更短，binlog更少，救命时候更快，但是后悔时间更短，而一周一备正好相反。我自己的备份策略是设置一个16小时延迟复制的从库，充当后悔药，恢复时间也较快。再两天一个全备库和binlog，作为救命药,最后时刻用。这样就比较兼顾了。 10.MySQL为什么有时候会选错索引？自我总结 为什么会选错索引 索引统计值（cardinality列）虽然不够精确。但大体上还是差不多的，选错索引一定还有别的原因。rows这个字段表示的是预计扫描行数。优化器为什么放着扫描37000行的执行计划不用，却选择了扫描行数是100000的执行计划呢？这是因为，如果使用索引a（37000），每次从索引a上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。而如果选择扫描10万行，是直接在主键索引上扫描的，没有额外的代价。优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的 优化器的逻辑 扫描的行数（是否排序，使用临时表），引出区分度、基数（索引的不同值的个数，个数越多基数越大，区分度越明显），如何统计基数，通过计算n个数据页，统计这些页上的不同值，求一个平均值，乘以索引的总页数。索引统计只是一个输入，重要的是优化器要判断要扫描多少行。所以3700不执行，执行10000的，因为优化器会判断回表的开销。analyst table t 可以重新进行索引统计，一般能够解决问题 索引选择异常和处理 force 来强行修改 但不利于及时性，不会评估其他索引的统计信息通过引导优化器避免排序的错误（第二个 sql语句是这个例证）删除原有索引，建立一个更为合理的索引 额外知识。 sql可以自己使用sql语句来添加数据 慢查询日志 MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。 普通索引的回表操作 先索引扫描，再通过ID去取索引中未能提供的数据，即为回表。 也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询 11.怎么给字符串字段加索引？自我总结 怎么给字符串字段加索引 第一印象：使用前缀索引，定义好长度，就可以即节省空间，又不用额外增加太多的查询成本重温：到主键上查到主键值为ID1的行，判断email的值，这算一次扫描，如果前缀不合适，甚至会每个都取出来，因为要判断取合集。索引选取的越长、占用磁盘空间就越大，相同数据页能放下的索引值就越少。 前缀索引对覆盖索引的影响 第一印象：前缀索引用不上覆盖索引的优化重温：覆盖索引的目的是判断是否唯一，而前缀索引的值不确定是否完整，所以还要回表查询，增加了IO操作。 其他方式 第一印象：倒序存储：reserve；hash字段：插入时和查询时使用crc32()这个函数，索引长度变成整型的4个字节。都不支持利用索引的范围查询，如果倒序则不需取出来数据，因为此时作业指的是完整的身份证数字重温：异同：倒序存储方式在主键索引上，hash字段要额外增加一个字段。倒序长而hash短，差不多；reserve比crc32消耗索引更少点；crc32冲突概率较小，倒序方式合集时还是会判断是否相等，还是可能增加扫描行数 总结与实践 第一印象：问题：采用hash表的方式最好了。重温：上期问题：37000+回表io，可能比100000更浪费时间，所以出现选错现象。是两份，还是100000左右，因为行数优化器采用了show table status的方法 额外知识 1 覆盖索引不知道覆盖索引的最左前缀原则，也不理解索引结构在叶子节点有数据，也不知道怎么回事就有io操作了，回去看之前的东西吧 12.为什么我的MySQL会“抖”一下？ 13.为什么表数据删掉一半，表文件大小不变？自我总结 参数innodb_file_per_table 第一印象：设置为on，则可以使drop table的直接删除文件，但是为off 则删除不掉重温：on代表每个表数据存储在一个.ibd为后缀的文件中，off放在系统共享表空间，和数据字典放在一起 数据删除流程 第一印象：数据页的复用和记录的复用是不同的，所有数据页都可以变成可复用的。此时磁盘空间没有减少。重温：不止删除，插入和更新要会造成空洞。插入：页分裂完成后，A页留下了空洞。更新：先删除后插入，也会产生空洞。增删改的表可能都是存在空洞的 重建表 第一印象：采用中间变量来交换表内容，实现重建，MySQL 5.5版本之前，使用alter table A engine=InnoDB命令(DDL)来重建表，可能就要被锁住,不能有更新。MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。重温：由于日志文件 row log 和重放操作功能，允许对表增删改。DDL之前是要拿MDL写锁的，但是退化成写锁了，时机如下，注意其实写锁的时间很短，就是启动alter语句时而已。(刚开始要写锁，是为了保证里面没有读锁) Online 和 inplace 第一印象：DDL过程如果是Online的，就一定是inplace的；反过来未必，也就是说inplace的DDL，有可能不是Online的。重温：alter table t engine=innodb,ALGORITHM=inplace; 重建表，在InnoDB内部完成，tmp_file。 alter table t engine=innodb,ALGORITHM=copy; 拷贝表，在server层创建 总结与实践 第一印象：收缩表的方法，5.6上alter 就可以，drop是没用的，内部流程可以支持增删改，Online DDL 是在业务低峰期使用的重温： 不影响增删改，就是 Online；相对 Server层没有新建临时表，就是 inplace，这里怎么判断是不是相对 Server 层没有新建临时表 从MySQL 5.6版本开始，alter table t engine = InnoDB（也就是recreate）默认的就是上面图4的流程了； analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁； optimize table t 等于recreate+analyze 额外知识 1 DDL MDL 阻塞DML DDL之前是要拿MDL写锁的https://www.cnblogs.com/henryhappier/archive/2010/07/05/1771295.html简单的的说，ddl（data definition language），dml（data manipulation language） 一个定义、一个操纵，还有，dcl和tclMDL 指表级别锁，一类是元数据锁（MDL），一种是表锁。完全没啥印象了，回去重新看一遍吧。。。。2 GitHub开源的gh-osthttps://github.com/github/gh-ost 解决刘建晓的项目也用不到这个吧简介：GitHub’s Online Schema Migrations for MySQL（在线模式迁移）3 数据字典放在系统共享表空间https://www.cnblogs.com/geaozhang/p/8478976.html简单阐述了系统表和独立表之间的区别4 留言精华5. 14.count(*)这么慢，我该怎么办？自我总结 count(*) 的实现方式 第一印象：因为会话多，别的事务在增删的情况，所以需要从头计数来准确返回值，InnoDB有事务支持，这个过程是引擎传数据给server层。MyISAM只是简单的存储，不需要判断过程。重温：优化：InnoDB索引组织表，普通索引树叶子节点是主键值。MySQL优化器找到最小的树遍历， show table status命令显示的行数也不能直接使用。很不准确 用缓存系统保存计数 第一印象：用redis如何都是逻辑不精确的，实际也肯定会出现问题。重温：异常重启问题成本可以考虑，就是重启时扫描一遍数据库，但是丢失更新问题解决，逻辑上还是不精确的 用数据库保存计数 第一印象：单独拿一个表 c 来存取。redo log可以保证崩溃恢复，可重复读的事务就可以保证查看数值和最近100条记录逻辑上一致。重温：利用事务这个特性将问题解决掉 不同的 count 用法 第一印象：InnoDB 会调出表给 server层。cout（）是最好的。id 和 字段都需要判断。1 是每一行都放数字1进去。重温：count(字段)&lt;count(主键id)&lt;count(1)≈count()，所以我建议你，尽量使用count(*)。 总结与实践 第一印象：InnoDB 支持事务，我们利用好事务的原子性和隔离性，就可以简化在业务开发时的逻辑。重温和留言： 额外知识 1 多版本并发控制（MVCC）多版本并发控制(Multiversion concurrency control， MCC 或 MVCC)，是数据库管理系统常用的一种并发控制，也用于程序设计语言实现事务内存。[1]MVCC意图解决读写锁造成的多个、长时间的读操作饿死写操作问题。每个事务读到的数据项都是一个历史快照（snapshot)并依赖于实现的隔离级别。写操作不覆盖已有数据项，而是创建一个新的版本，直至所在操作提交时才变为可见。快照隔离使得事物看到它启动时的数据状态。 15.答疑文章（一）：日志和索引相关问题自我总结 日志相关问题 第一印象：没有commit声明，默认也有commit提交，binlog写入才会发生从库备份，两阶段提交：写入redolog，处于prepare-&gt;写binlog-&gt;提交，两个横向两个时刻。第二个时刻，commit标识、prepare标识、判断binlog是否完整来判断是否回滚，一个事务binlog是有完整格式，5.6.2后引入binlog-checksum参数，保证完整性和正确性可以通过这来发现，redolog 和 binlog通过共同的XID关联。重温：两阶段提交是为了事务的持久性，两阶段是redolog和binlog都写好在提交，防止出现redolog写好，但是binlog没写，此时不能回滚，数据和binlog日志就不一样了。不引入两个日志，就没有两阶段提交的必要了。只使用binlog不支持崩溃恢复，因为binlog没有能力恢复内存数据页，它不记录数据页的更改。… -&gt; “数据更新到内存” -&gt; “写 binlog” -&gt; “提交事务”，一个事务可以提交，多个事务组成一个事务，binlog最多只能恢复最后一个，之前的它默认提交完毕，写在磁盘中了，数据页级别的丢失。InnoDB使用wal技术，可以将多个事务组成一个事务的情况处理了？（这里不确定），只有redolog不支持归档了，binlog复制也不能用，影响binlog的所有生态内容。redolog 不进行落盘，它内部记录逻辑，脏页的数据页写到磁盘是由操作系统搞的。它作用是崩溃恢复的时候，将页恢复成崩溃前的脏页。 redo log buffer 就是支持多事务不丢失的关键在内存中，先写redo log buffer，再写redolog，真正写redolog实在执行commit语句的时候（不是commit步骤） 业务设计问题 第一印象：同时关注的可能不能成为朋友的问题，A&lt; B是指他们的 userid，like表设计必须保证userid&lt;likerid，增加行锁冲突约束，利用强制添加，将最终朋友的功能通过判断实现重温：强行占住了行锁，确保在行锁保护下读操作，这个业务一定要用唯一索引。因为一定会插入重复记录。不懂： duplicate key sql语句是什么作用？使反向关系为什么出现行锁冲突，这个业务为什么“我一定会插入重复数据，数据库一定要由唯一约束”？唯一约束是什么逻辑，重复了键值，唯一索引怎么建立？回答：语句的作用，当insert已经存在的记录时，执行Update; 就是A &lt; B 带来的影响，不要这么花里胡哨；因为A和B的值一定在库中，并且关注动作发生一定要插入重复数据，之前ab和ba使两个不同数据，唯一索引就是指普通的 额外知识 1 事务的持久性原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。2 WAL技术 WAL的主要意思是说在将元数据的变更操作写入到持久稳定的db之前，先预先写入到一个log中，然后再由另外的操作将log apply到外部的持久db里去。这种模式会减少掉每次的db写入操作，尤其当系统要处理大量的transaction操作的时候，WAL的方式相比较于实时同步db的方式有着更高的效率。3 数据页级别的丢失我猜测是内存数据页级别的丢失，因为这个问题是在redo log不存在的时候提出来，binlog只能记录物理操作，逻辑上的恢复只能依靠redolog，他通过wal技术la4 排他锁排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据5 重复调用时的幂等性。幂等性原本是数学上的概念，即使公式：f(x)=f(f(x)) 能够成立的数学性质。用在编程领域，则意为对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。幂等性是分布式系统设计中十分重要的概念，具有这一性质的接口在设计时总是秉持这样的一种理念：调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。6 唯一索引主键索引是唯一索引的特殊类型。数据库表通常有一列或列组合，其值用来唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据。它们的一些比较：(1)对于主健/unique constraint ， oracle/sql server/mysql等都会自动建立唯一索引；(2)主键不一定只包含一个字段，所以如果你在主键的其中一个字段建唯一索引还是必要的；(3)主健可作外健，唯一索引不可；(4)主健不可为空，唯一索引可；(5)主健也可是多个字段的组合；(6)主键与唯一索引不同的是：a.有not null属性；b.每个表只能有一个。 16.“order by”是怎么工作的？自我总结 全字段排序 第一印象：将字段数据放到 sort_buffer 中进行排序，浪费内存，读表操作较多，会将里面数据完整排序，利用 OPTIMIZER_TRACE 可以看到 number_of_tmp_files中是否使用了临时文件。sort_buffer每个线程再内存中分配一个重温：分为7步，初始化 sort_buffer, 放入字段，找索引，回表取字段，索引找下一个字段，重复3、4，sort_buffer按name排序，将排序结果取前1000 给客户端。sort_buffer_size 可以控制内存排序和外部排序 rowid排序 第一印象：就是sort_buffer中只有一个要排序的那个字段，但是这样先让你就要回表，再将结果集返回。触发这个操作是因为 MySQL 认为排序的单行长度太大了。重温：测试方法可以掌握，临时文件因字段长度变小，select @b-@a 变成5000，因为4000在sort_buffer排序中读，回表还需要进行读1000行给客户端 全字段排序 VS rowid排序 第一印象：“Using index”，表示的就是使用了覆盖索引重温：覆盖索引，指索引上的信息足够满足查询请求，不需要回到主键索引上去取数据，这个就是将要取得数据放到索引中呗，没什么复杂的。 小结&amp;本期问题 第一印象：要学会分析 order by下面的sort_buffer操作，分析出每个语句的执行对系统资源的消耗。重温： 17.如何正确地显示随机消息？自我总结 内存临时表 第一印象：引擎是memory。内存表回表只是简单根据数据行位置，直接访问得到内存，根本不会导致多访问磁盘。原表到内存临时表(10000，按照R排序，因为R是随机的)，内存临时表到sort_buffer(10000，sort里面第二个字段是位置信息，作者说得很花里胡哨，谈及了索引主键，其实就是为了方便取出数据时，方便从内存临时表取数据。)，从临时表取3行，总共20003。重温：memory引擎不是索引组织表，你可以认为它就是一个数组，这个rowid（结合上一篇文章内容）其实就是数组的下标。mysql表时用什么方法定位一行数据的下图可知，order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。 磁盘临时表 第一印象：引擎是InnoDB，tmp_table_size这个配置限制了内存临时表的大小，默认值是16M。可以说 sort_buffer_size设置成 32768（如果选3个结果，根据选择数据量决定了优先队列排序还是归并排序，本身大小决定有无临时表生成）, 把 max_length_for_sort_data 设置成16（决定了rowid排序还是全字段进入sort）重温：优先队列和归并，要看堆这个大小是多少行，limit 1000 的话，显然维护堆大小1000行，超过32768，只能借用 外部文件来归并排序。 随机排序方法 第一印象：找出最大值、最小值，取其中的随机中间值可能出现空洞（可能出现bug），但是表重建可以解决这个问题。第二个方法，读取全行数，取随机行Y，limit Y,1 就是读了Y行，返回Y+1，总扫描 全行+Y+1重温：全行+Y+1行想扫描行数和order by rand()扫描行数很接近，为什么说前者代价小的多呢？ 小结&amp;本期问题 第一印象：使用order by rand()，这个语句需要Using temporary 和 Using filesort，查询的执行代价往往是比较大的。重温：我们不是仅仅在数据库内部解决问题，还会让应用代码配合拼接SQL语句。在实际应用的过程中，比较规范的用法就是：尽量将业务逻辑写在业务代码中，让数据库只做“读写数据”的事情。因此，这类方法的应用还是比较广泛的。所谓的 rowid 方法，就是指借助第三方排序，出现了回表操作的排序，这个过程利用了位置信息这个模糊概念，临时表显然用的更明显，order by的临时表f’geng 额外知识 1 memory引擎memory存储引擎相比前面的一些存储引擎，有点不一样，其使用存储在内从中的数据来创建表，而且所有的数据也都存储在内存中。每个基于memory存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为.frm。该文件只存储表的结构，而其数据文件，都是存储在内存中，这样有利于对数据的快速处理，提高整个表的处理能力。memory存储引擎默认使用哈希（HASH）索引，其速度比使用B-+Tree型要快，如果读者希望使用B树型，则在创建的时候可以引用。memory存储引擎文件数据都存储在内存中，如果mysqld进程发生异常，重启或关闭机器这些数据都会消失。所以memory存储引擎中的表的生命周期很短，一般只使用一次2 慢查询日志（slow log）MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。3 prepare+execute的方法预处理语句 18.为什么这些SQL语句逻辑相同，性能却差异巨大？自我总结 案例一：条件字段函数操作 第一印象：MySQL 规定，如果对字段做了函数操作，就用不上索引了。对索引字段做函数操作，可能会破坏索引值的有序性。优化器会放弃走树搜索功能。（但还是会使用索引，因为索引要小，大多数情况会用到覆盖索引）重温：改正 where month(t_modified)=7; 这个语句，就是用笨方法，7月份就 &gt;’XXXX-7-1’ and &lt; ‘XXXX-8-1’，优化器甚至不能优化 where id + 1 = 10000这个SQL语句，只能where id = 10000 -1才可以。（有点辣鸡） 案例二：隐式类型转换 第一印象：where tradeid=110717; tradeid的字段类型是varchar(32)，而输入的参数却是整型，所以需要做类型转换。CAST(tradid AS signed int) = 110717;重温： select “10” &gt; 9的结果，“将字符串转成数字”，那么就是做数字比较，结果应该是1；“将数字转成字符串”，那么就是做字符串比较，结果应该是0。select ‘a’ = 0 ; 的结果是1，说明无法转换成数字的字符串都被转换成0来处理了。 案例三：隐式字符编码转换 第一印象：用下面这种操作来理解关联，两侧都可能发生转换（往超集转换是根本），当左侧发生转换，就不能使用索引了。select l.operator from tradelog l , trade_detail d where d.tradeid=l.tradeid and d.id=4;select operator from tradelog where traideid =$R4.tradeid.value;select operator from tradelog where traideid =CONVERT($R4.tradeid.value USING utf8mb4);重温：优化方法，一：将较低的转换程较高的超集alter table trade_detail modify tradeid varchar(32) CHARACTER SET utf8mb4 default null; //把trade_detail表上的tradeid字段的字符集也改成utf8mb4二：通过SQL语句修改select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2; //但如果数据量比较大， 或者业务上暂时不能做这个DDL的话，那就只能采用修改SQL语句的方法了。 小结&amp;本期问题 第一印象：三个案列一件事：对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。索引字段不能进行函数操作，但是索引字段的参数可以玩函数。重温：每次你的业务代码升级时，把可能出现的、新的SQL语句explain一下，是一个很好的习惯。 19.为什么我只查一行的语句，也执行这么慢？ 20.幻读是什么幻读有什么问题？自我总结 幻读是什么？ 第一印象：幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。重温：在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。幻读仅专指“新插入的行”。 幻读有什么问题？ 第一印象：首先是语义上的，“我要把所有d=5的行锁住，不准别的事务进行读写操作”。而实际上，这个语义被破坏了。（0，0，0）、（5，5，5）中锁住的是555，如果update 000中的信息变成5，是锁不住的。其实，是数据一致性问题。这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。这个语句序列，不论是拿到备库去执行，还是以后用binlog来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100)和(5,5,100)。commit提交较晚，将其中几个事务的插入更新语句的相应的值更新为了100，造成了最终的不一致。重温：加写锁，可以解决id=0这一行更新的问题，但是id=1这一行还不存在，不存在也就加不上锁。解决不了id=1这一行的插入问题。即使把所有的记录都加上锁，还是阻止不了新插入的记录。 如何解决幻读？（InnoDB） 第一印象：InnoDB只好引入新的锁，也就是间隙锁(Gap Lock)。间隙锁，锁的就是两个值之间的空隙。跟行锁有冲突关系的是“另外一个行锁”。但是间隙锁不一样，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。重温：间隙锁和行锁合称next-key lock，每个next-key lock是前开后闭区间。InnoDB给每个索引加了一个不存在的最大值supremum，这样才符合我们前面说的“都是前开后闭区间”。间隙锁和next-key lock的引入，帮我们解决了幻读的问题，但同时也带来了一些“困扰”。任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据。这个业务在间隙锁的逻辑下并发出现死锁。间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置为row。这，也是现在不少公司使用的配置组合。 小结&amp;本期问题 第一印象：我们发现即使给所有的行都加上行锁，仍然无法解决幻读问题，因此引入了间隙锁的概念。行锁确实比较直观，判断规则也相对简单，间隙锁的引入会影响系统的并发度，也增加了锁分析的复杂度，但也有章可循。重温：这里session B和session C的insert 语句都会进入锁等待状态。你可以试着分析一下，出现这种情况的原因是什么？]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 虚拟机是如何加载Java类的]]></title>
    <url>%2F2019%2F10%2Fyuque%2Flgicea%2F</url>
    <content type="text"><![CDATA[脑子笨，还是捋一捋 问题提出通过 JVM 参数 -verbose:class 来打印类加载的先后顺序，并且在 LazyHolder 的初始化方法中打印特定字样。在命令行中运行下述指令（不包含提示符 $）：123456789101112131415161718192021$ echo 'public class Singleton &#123;private Singleton() &#123;&#125;private static class LazyHolder &#123;static final Singleton INSTANCE = new Singleton();static &#123;System.out.println("LazyHolder.&lt;clinit&gt;");&#125;&#125;public static Object getInstance(boolean flag) &#123;if (flag) return new LazyHolder[2];return LazyHolder.INSTANCE;&#125;public static void main(String[] args) &#123;getInstance(true);System.out.println("----");getInstance(false);&#125;&#125;' &gt; Singleton.java$ javac Singleton.java$ java -verbose:class Singleton 问题 1：新建数组（第 11 行）会导致 LazyHolder 的加载吗？会导致它的初始化吗？在命令行中运行下述指令（不包含提示符 $）：1234$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Singleton\$LazyHolder.class &gt; Singleton\$LazyHolder.jasm.1$ awk 'NR==1,/stack 1/&#123;sub(/stack 1/, "stack 0")&#125; 1' Singleton\$LazyHolder.jasm.1 &gt; Singleton\$LazyHolder.jasm$ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Singleton\$LazyHolder.jasm$ java -verbose:class Singleton 问题 2：新建数组会导致 LazyHolder 的链接吗？ 过程总结 加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。初始化，则是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。—引用自极客时间 运行分析123456789101112131415161718public class Singleton &#123; private Singleton() &#123;&#125; private static class LazyHolder &#123; static final Singleton INSTANCE = new Singleton(); static &#123; System.out.println("LazyHolder.&lt;clinit&gt;"); &#125; &#125; public static Object getInstance(boolean flag) &#123; if (flag) return new LazyHolder[2]; return LazyHolder.INSTANCE; &#125; public static void main(String[] args) &#123; getInstance(true); System.out.println("----"); getInstance(false); &#125;&#125; 改动前：改动后：显然可以看到，新建数组是不可以初始化元素类 LazyHolder，因为没有输出语句 “LazyHolder.“ ，而使用LazyHolder.INSTANCE 显然可以初始化元素类 LazyHolder。具体可以参考单例模式的实现，见下面的原文分析。123456789public class Singleton &#123; private Singleton() &#123;&#125; private static class LazyHolder &#123; static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; 我在文章中贴了一段代码，这段代码是在著名的单例延迟初始化例子中2，只有当调用 Singleton.getInstance 时，程序才会访问 LazyHolder.INSTANCE，才会触发对 LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。 截图中显然也能看到是加载了，但是有没有经过链接阶段呢？这就很关键了！如果经过了链接，又到了验证、准备、解析的哪个阶段呢？ 作业分析从结果来看，报错是因为 awk 把字节码改为不符合 jvm 规范，不符合规范会在验证阶段发生报错。而在运行 getInstance(true); 时，并未出现错误，而且 System.out.println(“—-“); 能正常运行，证明新建数组根本没有进行链接，因为它根本没有验证阶段。而 getInstance(false) 出现报错语句，证明到了这里才真正进行了链接和初始化，由此可得，新建数组会加载元素类LazyHolder，但不会链接和初始化，而 return LazyHolder.INSTANCE; 会加载、链接和初始化，这也符合作业提示的关于单例模式线程安全的原因。那么从 Java Singleton 可见报错出现在11行，代码中确实指向了 return LazyHolder.INSTANCE； 接下来，从结果往前推演，可以得到几个问题： 新建数组类为什么只加载而不进行链接和初始化？ LazyHolder.INSTANCE; 为什么会进行链接和初始化？ 要搞清楚这些问题必然要思考加载、链接和初始化触发的条件。引用原文的话（下面都是我的猜测）： 在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）—引用自极客时间 从上面的话分析，return new LazyHolder[2]; return LazyHolder.INSTANCE; 在 Singleton 类被解析时都会将 关于 LazyHolde 类的符号引用解析为实际引用。并且触发这个类的加载。可以分析出来的是，本例中只有在 main 中实际运行运行状态中才会触发 LazyHolder 类的链接和初始化。 那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况： 当虚拟机启动时，初始化用户指定的主类； 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类； 当遇到调用静态方法的指令时，初始化该静态方法所在的类； 当遇到访问静态字段的指令时，初始化该静态字段所在的类； 子类的初始化会触发父类的初始化； 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化； 使用反射 API 对某个类进行反射调用时，初始化这个类； 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。 结合作业关于单例模式的分析，我们可以明显看出，作业中 LazyHolder.INSTANCE 语句也是对 LazyHolder 的初始化（对应第 4 种情况）。new LazyHolder[2] 压根不会进行链接。因为学的不深，暂且猜测：解析阶段，符号引用解析成实际引用，一般都会触发类的加载、链接和初始化。LazyHolder[2] 不会进行链接可能因为这段代码是单例情形(static final)，生成 Singleton 的类只能有一个，而 LazyHolder[2] 数组类是由 Java 虚拟机直接生成的(文中说过，数组类没有相应的字节流)，虚拟机因为单例情形(static final)，中断了对其的链接和初始化。 总结不做大佬给的作业，我是无法消化对我来说比较多的知识点。作者的目的显然也是想让我们搞懂、记住基本的流程，大佬的一次作业做一遍，顶得上看十遍(虽然确实有点难啃)。答案引用某大佬的评论： 更多细节评论中指出： -XX:+TraceClassLoading 可以看到类加载过程(注：IDE使用此参数和 java -verbose:class Singleton 手动编译效果一样) 作者列出的几种情况都属于主动使用类。感觉应该有被动使用的举例，并告知大家这样做是不会执行初始化的 在加载阶段就已经生成class结构了，所以我认为应该已经写入了方法区，只是被标记为未链接而暂不能使用。 您在评论回复说.class在加载后已经写入方法区（元空间），但是我理解在方法区里类代码的方法调用应该是实际的调用地址吧？而取得实际调用地址不是在链接阶段吗？这里不太理解，求解答～ 回复：链接时取得的不是被加载类的地址，而且被加载类所调用的其它方法的地址。 类中的静态字段，如果没有被jvm标记为常量，那么这部分内存是如何分配的？ 回复：JVM都会分配内存的，只是初始化的过程不一样，一个是JVM直接赋值，一个是在clinit方法中赋值 Java中所有的非私有实例方法，都算是虚方法。调用这些方法的指令，也区分直接调用和虚调用 被final修饰的静态成员变量，如果不是基本类型或者字符串，也会放在clinit 来做 扩展类加载器的父类，是启动类加载器（X）这里我指的是扩展器类的 父-类加载器，而不是父类-(加载器)。 双重检查锁定模式的潜在问题 无解答 关于类初始化和类实例化有哪些区别呢？ 加载的字节码最终都被转换为了那些内容，都放到了哪里，执行时候如何进行链接的，如何去查找到的引用对象的 类的class文件中的所有内容全部会被加载到方法区中，还是class中的方法被加载到方法区 类加载时如果引用另外一个类，那么这个类会先加载，那么请教一下，如果循环引用呢，会发生什么事？ 类加载时候加锁 如果在里面进行多线程回出现死锁 请老师具体讲解下 更多好的总结：掘金：深入理解 Java 类加载机制掘金：Java类加载机制（全套）]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习笔记(一)]]></title>
    <url>%2F2019%2F08%2Fyuque%2Fgo8ivm%2F</url>
    <content type="text"><![CDATA[SpringBoot学习笔记 基础知识先看一下易百教程、学习了慕课网上的免费的 SpringBoot+MyBatis搭建迷你小程序课程、也可以学习付费的Java双版本（SSM到SpringBoot）校园商铺全栈开发课程（也可以不学），看完了之后就是动手实战了，结合Postman和易百教程（比较优秀），了解一些前端的传参等基础知识，基本上就可以开发一个后台管理界面了。当然最重要的就是动手实战。 开发流程导入pom.xml(使用插件别忘了添加相对应的pom文件)，先写Dao层，如果必要编写xml文件，然后进行测试，然后就是Service、Controller层的代码编写。因为基本上调用的是Dao层代码，测试可以省略，如果有回滚等操作，还是需要测试一下的。拦截器，工具类，异常处理，枚举类等要分类放在不同包下方便维护、管理。遇到问题先看报错，再谷歌思考。 参考学习因为开发的后台管理界面只需要很少的管理员，也没有啥有价值的内容，所以没有搞得很深，黑客如果想搞我我认了。网上参考学习了以下内容： kaptcha验证码关于验证码，参考这一篇 springboot整合kaptcha验证码 基本能解决问题，里面也有介绍Spring如何整合。掘金的这篇，可以参考改一下生成二维码的配置。 静态资源映射项目代码和图片等资源显然不能放在一起，采用映射就是将项目下可以访问的路径映射到指定的路径。可以先参考这篇，主要有两步，首先配置一个Config，这里取名为 UrlConfig 123456789101112131415161718import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class UrlConfig implements WebMvcConfigurer &#123; @Value("$&#123;upload_imgs_folder&#125;")//这里是指定的路径 private String uploadDir; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; //"/work/Images/**"是前端访问的路由，file:" + uploadDir + "work/"是映射的路径 registry.addResourceHandler("/work/Images/**").addResourceLocations("file:" + uploadDir + "work/"); registry.addResourceHandler("/team/Images/**").addResourceLocations("file:" + uploadDir + "team/"); registry.addResourceHandler("/member/Images/**").addResourceLocations("file:" + uploadDir + "member/"); &#125;&#125; 再就是在application.properties 进行配置 12345678IP=localhostupload_imgs_folder=E:/upload/#以下路径最后必须有“/”spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,\ file:$&#123;upload_imgs_folder&#125;work/,\ file:$&#123;upload_imgs_folder&#125;team/,\ file:$&#123;upload_imgs_folder&#125;member/ 这样就可以简单的进行相应路径的映射了。 拦截器和Token理解易百教程中的基本概念，参考 csdn 和 简书的代码，我们主要参考 CSDN的那篇写了逻辑，但是注意CSDN中secretKey 并没有给出完整代码，我们结合两篇设计了TokenUtil的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class TokenUtil &#123; //public static String DatabaseToken; // @Autowired // private TokenDao tokenDao; //应当可以随意设定 JWT_SECERT的值 public static final String JWT_SECERT = "0000df7f1234e88888999923c0005d"; public Token operateToken(Token token) &#123; //根据数据库的用户信息查询Token //Token token = tokenDao.findByUserId(userId); //为生成Token准备 Long userId = token.getUserId(); String TokenStr = ""; Date date = new Date(); //获得秒数 long nowTime = date.getTime() / 1000; //生成Token TokenStr = creatToken(userId, date); if (null == token.getToken()) &#123; //第一次登陆 token.setToken(TokenStr); token.setBuildTime(nowTime); //tokenDao.insertToken(token); &#125;else&#123; //登陆就更新Token信息 TokenStr = creatToken(userId, date); token.setToken(TokenStr); token.setBuildTime(nowTime); System.out.println(nowTime); //tokenDao.updateToken(token); &#125; //User queryForm = getUserInfo(user, TokenStr); /* 将用户信息存入session */ /*SessionContext sessionContext = SessionContext.getInstance(); HttpSession session = sessionContext.getSession(); httpSession.setAttribute("userInfo", user);*/ //返回Token信息给客户端 // successful(map); //map.put("data", queryForm); //DatabaseToken = tokenDao.findByUserId(userId).getToken(); return token; &#125; /** * 生成token(格式为token:设备-加密的用户名-时间-六位随机数) * @param username 用户登录名 * @return */ public String creatToken(Long userId, Date date) &#123; SecretKey secretKey = generalKey(); SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; JwtBuilder builder = Jwts.builder().setHeaderParam("typ", "JWT") // 设置header .setHeaderParam("alg", "HS256").setIssuedAt(date) // 设置签发时间 .setExpiration(new Date(date.getTime() + 1000 * 60 * 60)) .claim("userId",String.valueOf(userId) ) // 设置内容 .setIssuer("lws")// 设置签发人 .signWith(signatureAlgorithm, secretKey); // 签名，需要算法和key String jwt = builder.compact(); return jwt; &#125; public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.decode(JWT_SECERT); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, "AES"); return key; &#125;&#125; jwt可以完美的防止CSRF，因为基本用不上cookie了，所以使用jwt生成了token。设计的用户较少，又不想配置Redis需要的环境，索性把Token放到了数据库中，根据CSDN那篇博客的理念设计基于token的登录，主要就是设计实体类，以及各个层。 基于token的登录，是不存在回话状态，大概思路，在用户初次等路的时候，校验用户账号密码，成功后给其生成一个token，token=用户ID+时间戳+过期时间+一个自己平台规定的签名，使用jjwt生成一个令牌，然后对其进行存库，用户每次访问接口，都会在头部Headers中带上token，后来拦截器对其进行拦截，如果token为空或错误则让其登录，如果有token，获取token进行其解析，取出里面的用户ID，根据用户ID查询数据库中所存token，判断其是否正确，正确使其登录，错误则提示登录，大致思路就是这样. 拦截器的概念在其中有提及，其中拦截可以在config文件中进行如 1234567//注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns("/**")//拦截 .excludePathPatterns("/team/Images","/##/##");//不拦截 &#125; 也可以在具体得拦截器中截获url决定是否放行 1getRequestURI().contains("/Images") 遇到的问题最好多人协作统一工作环境，我估计这能节省解决问题耗费的三分之一的时间。 数据库数据库问题比较常见，乱码问题就是报错给出乱码，可以给IDEA加上1useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false 连上数据库，也可以像我一样索性打开Mysql的界面进行操作，sql文件夹下的建表和插入语句可能会影响数据库。Junit测试出现数据库错误报错不明显，也要考虑数据库。 逻辑Date日期问题，我们没注意到为了防止Long越界，Copy过来的界面有除以1000的操作，结果导致提取出来的数据库判断时间出现了问题。进而影响了token过期的判断，解决方式是转换成正常日期打印观察。Date转换：https://lixh1986.iteye.com/blog/1757619 空指针问题，以为Dao层select语句可以如insert语句可以返回变更的行数，实际上返回的实体类，如果为空进而使用会出现空指针异常。 变量问题，代码逻辑最好不要使用变量值来操作，很容易出 bug 也很不清晰，如果单独的传至，可以使用静态常量。这次可能是设计的问题，我们逻辑判断很绕，索性就在User实体类中多设计了一个属性和Token实体相互照应，解决了首次登陆插入，再次登陆更新的逻辑问题。 注入失败非service层注入dao层总是导致注入失败，显示为空。工具类中还可以避免注入Dao层，我觉得这样代码也会更清晰，但是拦截器那里确实要使用TokenDao层的数据，因为header返回的token要和数据库中的token进行比较，所以寻找了Java调用Service层方法123456789@Autowired private TokenDao tokenDao; private static TokenDao tokenDao1; public @PostConstruct void init()&#123; tokenDao1 = tokenDao; &#125; IDEA的使用很多不确定的东西不用搜，注意idea提示的类型等语句就足以解决问题，比如Mysql对应的数据类型，要考虑好逻辑再动手敲。IDEA有很好的插件，对应更为省力的注解，比如Lombok插件，关键是要理解本来的东西是个什么原理。IDEA相关的快捷键也很大程度上能提升效率。 ctrl + alt + b跳到service实现类，快速创建某个接口的实现类等。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2019%2F07%2Fyuque%2Fxshnz9%2F</url>
    <content type="text"><![CDATA[第一句废话 引用自阮一峰 科技爱好者周刊：第 69 期（20190816）**一件事“做得好”比较好，还是“做得快”比较好？ 鱼和熊掌不能得兼，你怎么选择：做得好，付出的代价可能是耗时长、成本高；做得快，意味着完成度低、不是精品。 我很赞同一篇文章的结论：做得快更好。 做得快不仅可以让你在单位时间内完成更多的工作，而且 因为你工作得很快，所以你会觉得成本低，从而倾向于做更多。 写一篇博客，你可能需要两天。这是很高的时间成本，你觉得太贵了，于是你很少写。但是，做好一件事的唯一方法，就是多做这件事。 做得越快，这件事的时间成本就越低，你会愿意做得更多。 人们总是倾向于，多消费时间成本低的东西。网站很快，就会多访问；搜索很快，就会多搜索；文章很容易读懂，就会多读几篇。做得快的核心，就是要让时间成本降下来，从而多做。 基本语法 居中 1code是黄&amp;紫 是深蓝&amp;浅蓝 普通链接是蓝色 可以 尝试 实验 这个可以吗 我也不清楚 试试吧 可以 不怎样啊 这个 呢 好像 有点神奇 删除线~~下划线 行内代码试一下 不记得某个快捷方式，可以打开语雀的快捷键很容易查看，各个之间最好换行。 插入固定大小图片 插入B站视频 网易云音乐]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[篮球赛后]]></title>
    <url>%2F2019%2F05%2Fyuque%2Flundx2%2F</url>
    <content type="text"><![CDATA[概述准备了一年的篮球赛落下帷幕，今年和去年一样开了个好头，去年上场两分钟，今年 5 场比赛 2 替补 3 首发，得了 4 分。 场下篮球，一直都是激烈而残酷的，这一很大程度靠天赋决定实力的竞技体育，让我一度想回到伪球迷的闲适时光。虽然我们一直嘴里嚷着欢乐篮球，但是谁不想赢得比赛，谁又不想出线，走向下一轮呢？去年的比赛仅仅赢了一场，今年的锦鲤签打到现在也只是赢了一场，并且出线已然无望。相较于去年，走了一届，来了一届，但新一届学生的确没有什么技术，很不成熟，根本无法上场。所以我们知道我们需要更加努力，好在我们这群家伙里面有一个想打 CUBA 的，进入了校队，不然我们这一届会崩的很难看。想到之前的早训、晚训还有随意出去约的投篮、斗牛。备赛期间，觉是不可能睡好的，你每天醒来，脑子里面都是篮球，那才是正确的。不过我知道，比我压力大，比我更忙的人不在少数。我前面的队长，为了留学，东奔西走，却也把托福和球赛一起抗在肩上，现在在写论文，还怪我约球没有叫他。每个人都很辛苦，但有些人终究是上不了场。我们院篮球人才稀缺，我想只要是想打球的，熬两年总是能体验一下正式比赛的快乐的，不想工学院这些底蕴深厚的院，球技很不错，却也上不了场。 场上第一场比赛和第二场比赛我记得比较清楚，和外院的比赛最终只有一分之差，在我上场的时间内，我只能说自己一直在坐晕车，也没有丝毫经验，被人造了三分犯规，他妈的还防守不积极。第二场园林分差较大，但是我学到的经验最多，他们的后卫和锋线都很快，我对位后卫的时候让我明白，什么是用身体和脑子来防守。内线要贴紧，对于我们这种比赛，外线换防和单防都要留一定的空间，防突而放投。至于进攻，我的突破今年完全就是零，只靠快攻得了仅有的 4 分，而投篮只能有抛投和跳投，跳投是不敢投的，抛投又太短，5 场比赛的三分球又全部未中，只能说自己的提升空间太大了（滑稽），当然防守用的是经验和体力，进攻就要靠基本功和脑子了，至于视野，先多看比赛培养，然后再实战结合吧，视野这种东西我觉得自己还是有机会练出来的，毕竟以前冲动是能进球，而现在强度变大，我不再是予取予求的球员，自然会多考虑给别人做球。 定位和总结明年估计我还是和现在一样 1、2 号位傻傻分不清楚，所以定位就是要有视野、有基本功、有脑子、有经验。其实我觉得 CS 和打球如果能兼顾得好，会是一个有益身心的明智选择（逃），奈何自己太菜，感觉这两方面要做的都很多，当然 CS 做的要更多，毕竟篮球对于我只是爱好， CS 才是职业，以后能工作之余，打一下养身篮球，想必是极好的。 明年，我希望全员健康，不辜负自己的希冀，给其他院队一些惊喜（也是给自己一个交代），加油！]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周会分享]]></title>
    <url>%2F2019%2F03%2Fyuque%2Frcibso%2F</url>
    <content type="text"><![CDATA[脚本使用 概述脚本最重要的体验就是方便。如果能有一些基础，高度定制自己的工作环境，是一种很不错的体验。如果自己总是会出问题，那么做好备份就很重要。一般来说，我们很少要编写脚本文件，除非自己的系统崩了，或者有一些小的繁琐的事情需要不断重复。我们可以直接对别人的脚本进行修改，然后就可以达到一键执行的效果。 学习资料W3Cschool：https://www.w3cschool.cn/linux/linux-shell-variable.html语雀链接：https://www.yuque.com/allenlei/ia7uhw/edyrfz b站链接：https://www.bilibili.com/video/av17384556实验楼链接：https://www.shiyanlou.com/courses/944 读一下 Linux 命令行与shell脚本编程大全和 Linux shell 脚本攻略Linux命令行与shell脚本编程大全.pdf 实例用处 dos 清除图标缓存12345678910111213141516171819202122232425262728293031@ECHO OFF&amp;PUSHD %~DP0 &amp;TITLE 清理系统图标缓存mode con cols=46 lines=26color 2F&gt;NUL 2&gt;&amp;1 REG.exe query "HKU\S-1-5-19" || ( ECHO SET UAC = CreateObject^("Shell.Application"^) &gt; "%TEMP%\Getadmin.vbs" ECHO UAC.ShellExecute "%~f0", "%1", "", "runas", 1 &gt;&gt; "%TEMP%\Getadmin.vbs" "%TEMP%\Getadmin.vbs" DEL /f /q "%TEMP%\Getadmin.vbs" 2&gt;NUL Exit /b)echo 按任意键开始，或者关闭本窗口 &amp; pause&gt;nulrem 结束Windows资源管理器explorertaskkill /f /im explorer.exerem 清理系统图标缓存数据库attrib -h -s -r "%userprofile%\AppData\Local\IconCache.db"del /f "%userprofile%\AppData\Local\IconCache.db"attrib /s /d -h -s -r "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\*"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_32.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_96.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_102.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_256.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_1024.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_idx.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_sr.db"rem 清理系统托盘记忆的图标echo y|reg delete "HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify" /v IconStreamsecho y|reg delete "HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify" /v PastIconsStreamrem 重启Windows资源管理器explorerstart explorerecho 执行完成！按任意键退出 &amp; pause&gt;nulexit 删除指定盘符下的空文件夹1234567891011121314151617181920ECHO OFF&amp;PUSHD %~DP0 &amp;TITLE 删除空文件夹mode con cols=46 lines=26color 2F&gt;NUL 2&gt;&amp;1 REG.exe query "HKU\S-1-5-19" || ( ECHO SET UAC = CreateObject^("Shell.Application"^) &gt; "%TEMP%\Getadmin.vbs" ECHO UAC.ShellExecute "%~f0", "%1", "", "runas", 1 &gt;&gt; "%TEMP%\Getadmin.vbs" "%TEMP%\Getadmin.vbs" DEL /f /q "%TEMP%\Getadmin.vbs" 2&gt;NUL Exit /b)set /p var=请输入要清除的盘符（C盘需谨慎，多盘使用空格分开）：for %%i in (%var%) do (if exist %%i:\ (for /f "delims=" %%a in ('dir /ad /b /s "%%i:\"^|sort /r') do (rd "%%a")))echo 执行完成！按任意键退出 &amp; pause&gt;nulexit Shell alias永久生效：https://blog.51cto.com/feihan21/12129541234567891011121314151617alias sudo='sudo 'alias ll='ls -alF'alias la='ls -A'alias l='ls -CF'alias l.='ls -d .* --color=auto'alias nis="npm install --save "alias svim='sudo nvim'alias mkcd='foo()&#123; mkdir -p "$1"; cd "$1" &#125;; foo 'alias install='sudo apt get install'alias update='sudo apt-get update; sudo apt-get upgrade'alias ..="cd .."alias ...="cd ..; cd .."alias h='history'alias ports='netstat -tulanp'alias rm='rm -I --preserve-root'alias grep="grep --color"alias grepp="grep -P --color" alias 即可显示设置的命令，和git一个道理vim ~/.bash_aliases 加入适合的alias命令$ source .bashrc #让我们的环境生效 引导https://coolshell.cn/articles/19219.html建议先使用 tldr 命令，然后也可以在 github 上找有趣的 shell 工具。检查脚本：https://www.shellcheck.net/ fish 和 zshhttp://www.ruanyifeng.com/blog/2017/05/fish_shell.htmlhttps://www.jianshu.com/p/bf03bce60987fish:12helpfish_config oh-my-fish 和 oh-my-zsh我给的是 oh-my-fishhttps://github.com/oh-my-fish/oh-my-fish/blob/master/docs/zh-CN/README.mdhttps://linux.cn/article-9515-1.htmlhttps://wiki.archlinux.org/index.php/Fish_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)) 推荐脚本最好使用开源的脚本，不要使用私人的脚本。简单的一键安装脚本：https://gitee.com/chang_501/ubuntu_system_installationUbuntu 一键安装的脚本：https://github.com/SickoOrange/UbuntuAutoScript一键安装deepin-wine脚本,可用于安装TIM,QQ,迅雷等软件：https://github.com/innoob/deepin-wine-installer一些 Ubuntu 上可能有用的软件: https://github.com/the0demiurge/CharlesScripts进阶的一些 Java 和shell 的脚本：https://github.com/oldratlee/useful-scripts]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vim的资源与使用]]></title>
    <url>%2F2019%2F03%2Fyuque%2Fpq6p97%2F</url>
    <content type="text"><![CDATA[概述毫无疑问，Vim对新手很不友好。但是友好的编辑器通常跟不上程序员进步的速度，谁又不想一劳永逸，一直使用同一种编辑器呢？这显然是一种辩证选择。而选择 Vim 绝对是一个明智的长期投资。Vim 又被称为神的编辑器，前身 vi 是由 BIll Joy 于 1976 年开发，其改进版 Vim 最早于 1991 年由 Bram Moolenaar 开发。关于 Vim 的其他故事，可以参考编辑器之神 &amp; 神的编辑器。 Vim 学习资源网上有很多乱七八糟的资源，但我感觉写得都不尽如人意。主要还是靠自己去搜索资源，找到最适合自己的学习方式，显然现在我还只是入门，仍旧处于不断学习的状态中。我的学习过程大致如下: vimtutor Vim 实用技巧 笨方法学 Vimscript 关于 Vim 实用技巧，推荐自己看一遍，里面针对问题来提出 Vim 的解决方案，是一个很好的参考资料，可以参考我的写得一篇 Vim 实用技巧，至于笨方法学Vimscript，目前还没有深入下去，仍旧在学习当中。 Vim 应用场景Vim 作为神的编辑器，自然少不了应用的地方。据我目前认知，大部分需要编辑器的地方，都能发现 Vim的身影，各种主流的 IDE 中 Vim 插件已经有大牛帮你写好了，只需要搜索进行下载就行了，我目前在这几个场景中应用 Vim： SpaceVim —-模块化的 Vim IDE Vimium —-Chrome浏览器的扩展程序 IdeaVim —-Idea中内置的插件 SpaceVim 三大主流平台都支持，是我自己轻量级写作和文件管理的工具，一开始用的不舒服，现在也还是不断学习的阶段。Vimium 是程序员的福利，Chrome 和Firefox 浏览器均有其插件，开箱即食。虽然有些按键设计不合理，但总的来说还是有所联系，毕竟这是社区推动、集思广益的。IdeaVim 则需要在 IDEA 中进行下载。我的初步使用，感觉还是有些不够灵活，其中还有一个扩展的 Vim 插件，有机会会去试试。 Vim 熟练使用熟练使用 Vim ，首先要学会盲打，SpeedCoder 是个不错的练习网站，学习了部分的 Vim 的知识，就可以通过做大量的练习来锻炼自己了，这显然是个煎熬过程，鉴于自己的学习也比价缓慢，就不过多分析。但是我还是喜欢在日常中去练习使用，而不是根据文档去刻意练习，找到自己需要编辑的地方，一律用 Vim 来编辑。比如写博客，敲代码，做记录等等。虽然我现在还是很水，但是也初步感受到了 Vim 的好处，刚开始的时候时间学习成本非常高，但回报也是巨大的。不知道是真正的效率，还是克服困难、努力得到肯定，使人感到无比强大和酣畅淋漓，反正正如大牛所说，它们会带给你渐渐强烈的快感，但你也向它们献出了自己的灵魂。这时，你只能称它们为神器。 注意以上内容，都是我个人的观点，欢迎访客提出自己的建议。另外自己显然有很多东西不懂，欢迎大佬给我些指导意见。这篇博客对于初学者来说，内容可能有些繁多，最好每个方向都入门，然后慢慢进步吧(我是如此，所以如是建议)，在学习过程中可能还要记一些与 Vim 无关的快捷键，比如在浏览器和 IDEA 中， 但我觉得这是早晚要适应的，克服一下，最终会感谢自己的选择。 引用1.http://os.51cto.com/art/201101/242518.htm2.https://www.yuque.com/tfrain/boke/vim_skill3.http://learnvimscriptthehardway.onefloweroneworld.com/4.https://spacevim.org/cn/5.https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb6.www.speedcoder.net]]></content>
      <categories>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法相关知识简介]]></title>
    <url>%2F2019%2F02%2Fyuque%2Fwikipedia_algorithm%2F</url>
    <content type="text"><![CDATA[维基的知识总结很优秀，具体的刷题记录全面转移到我的Gitbook 前言若hexo有小bug或不舒服之处，请移步到语雀浏览，我的刷题记录在Gitbook因为自己的算法基础非常薄弱，希望通过兔派刷题的方式，怀着幸存者的意识，能够迎头赶上。 数组(Array)在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。最简单的数据结构类型是一维数组。例如，索引为0到9的32位整数数组，可作为在存储器地址2000，2004，2008，…2036中，存储10个变量，因此索引为i的元素即在存储器中的2000+4×i地址。数组第一个元素的存储器地址称为第一地址或基础地址。二维数组，对应于数学上的矩阵概念，可表示为二维矩形格。例如：在C语言中表示为int a[3][3] = {{3, 6, 2}, {0, 1, -4}, {2, -1, 0}};。在某些情况下，“向量”一词也可能代表二维数组，虽然在数学意义上更确切地称呼为元组（tuple），而不是向量。但需要注意的是：计算机科学的某些领域，如Matlab，元组是指类似C语言struct类型，具有固定的往往是不同类型的数据成员的数据结构。数组通常用于实现数据库的表格，特别是查询表；表格有时也被当作是数组的同义词。数组是最早期和最重要的数据结构之一，很多程序都会用到数组。它们也用于实现许多其他数据结构，譬如列表（list）和字符串（string）。它们有成效地开展了计算机的定址逻辑。在大多数现代计算机和许多外部存储设备中，存储器如同一维数组，索引就是其地址。编译器、处理单元（特别是向量处理器），经常会针对数组操作进行优化。因为在程序运行时可以计算元素的索引，数组是很有用的。此外，也能以单一迭代语句就处理数组的许多元素。为此，数组数据结构的元素必须具有相同的大小，而且应该使用相同的数据类型表示。数组一词通常用于表示数组数据类型，一种大多数高端编程语言都会内置的数据类型。数组类型通常由数组结构来实现；然而在某些语言中，它们可以由散列表、链表、搜索树或其它数据结构来实现。在算法的描述中，数组一词特别着重意义为关系数组或“抽象的数组”，一种理论上的计算机科学模型（抽象数据类型或 ADT），专注于数组的基本性质上。 哈希表(Hash Table)散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名x到首字母F(x)的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则F()，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。 链表(Linked List)链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针)(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（”links”）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。 数学(Math) 双指针(Two Pointers) 串(String)字符串（String），是由零个或多个字符组成的有限序列。一般记为。它是编程语言中表示文本的数据类型。通常以串的整体作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。两个字符串相等的充要条件是：长度相等，并且各个对应位置上的字符都相等。设p、q是两个串，求q在p中首次出现的位置的运算叫做模式匹配。串的两种最基本的存储方式是顺序存储方式和链接存储方式。 二分查找(Binary Search)在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。二分搜索在情况下的复杂度是对数时间，进行次比较操作在此处是数组的元素数量，是大O记号，是对数）。二分搜索使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分搜索比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），二分搜索应用面更广。二分搜索有许多中变种。比如分散层叠可以提升在多个数组中对同一个数值的搜索。分散层叠有效的解决了计算几何学和其他领域的许多搜索问题。指数搜索将二分搜索拓宽到无边界的列表。二分搜索树和B树数据结构就是基于二分搜索的。 分治算法(Divide and Conquer)在计算机科学中，分治法是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法（快速排序、归并排序）、傅立叶变换（快速傅立叶变换）。另一方面，理解及设计分治法算法的能力需要一定时间去掌握。正如以归纳法去证明一个理论，为了使递归能够推行，很多时候需要用一个较为概括或复杂的问题去取代原有问题。而且并没有一个系统性的方法去适当地概括问题。分治法这个名称有时亦会用于将问题简化为只有一个细问题的算法，例如用于在已排序的列中查找其中一项的折半搜索算法（或是在数值分析中类似的勘根算法）。这些算法比一般的分治算法更能有效地运行。其中，假如算法使用尾部递归的话，便能转换成简单的循环。但在这广义之下，所有使用递归或循环的算法均被视作“分治算法”。因此，有些作者考虑“分治法”这个名称应只用于每个有最少两个子问题的算法。而只有一个子问题的曾被建议使用减治法这个名称。分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。 动态规划(Dynamic Programming)动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 回溯算法(Backtracking)回溯法（英语：backtracking）是暴力搜索法中的一种。对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。在经典的教科书中，八皇后问题展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况： 找到一个可能存在的正确的答案 在尝试了所有可能的分步方法后宣告该问题没有答案 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。 栈(Stack)堆栈（英语：stack）又称为栈或堆叠，是计算机科学中一种特殊的串列形式的抽象数据类型，其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外堆栈也可以用一维数组或链表的形式来完成。堆栈的另外一个相对的操作方式称为队列。由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。 堆(Heap)堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。在堆中最顶端的那一个节点，称作根节点（root node），根节点本身没有母节点（parent node）。堆始于 J._W._J._Williams 在 1964 年发表的堆排序（heap sort），当时他提出了二叉堆树作为此算法的数据结构。堆在戴克斯特拉算法（英语：Dijkstra’s algorithm）中亦为重要的关键。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。 贪心算法(Greedy)贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。 排序(Sort)在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则： 输出结果为递增序列（递增是针对所需的排序顺序而言） 输出结果是原输入的一种排列、或是重组 虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：图书馆排序在2004年被发表） 位运算(Bit Manipulation)位操作是算法操作比字&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhjWJGcdyh6D0YqybOhRRrQm_q3weA)短的位或其他数据&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhimJkNnf1ms2G_qzxH5ThHaFXOF3w)的行为。 需要位操作的计算机编程任务包括低级设备控制， 错误检测和纠正算法， 数据压缩 ， 加密算法和优化&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhh_t9EuZt8FPWcE83nzA7-3KzopLw) 。 对于大多数其他任务，现代编程语言允许程序员直接使用抽象&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhgsc5qtrh0_vT7zGYTWMCKDHxCcOA)而不是代表那些抽象的位。 执行位操作的源代码使用按位运算 ：AND，OR，XOR，NOT和位移 。在某些情况下，位操作可以消除或减少循环数据结构的需要，并且可以提供多倍的加速，因为并行处理位操作，但代码可能变得更难以编写和维护。 树(Tree)在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树里面没有环路(cycle) 深度优先搜索(Depth-first Search)深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树)或图)的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。因发明“深度优先搜索算法”，约翰·霍普克洛夫特与罗伯特·塔扬在1986年共同获得计算机领域的最高奖：图灵奖。 广度优先搜索(Breadth-first Search)广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。 并查集(Union Find)在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于创建单元素集合。有了这些方法，许多经典的划分问题可以被解决。为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。 图(Graph) 设计(Design) 拓扑排序(Topological Sort)在计算机科学领域，有向图的拓扑排序是其顶点的线性排序，使得对于从顶点到顶点的每个有向边，在排序中都在之前。 例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束; 在这个应用中，拓扑排序只是一个有效的任务顺序。 如果且仅当图形没有定向循环，即如果它是有向无环图（DAG），则拓扑排序是可能的。 任何 DAG 具有至少一个拓扑排序，并且已知这些算法用于在线性时间内构建任何 DAG 的拓扑排序。在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）。 每个顶点出现且只出现一次； 若A在序列中排在B的前面，则在图中不存在从B到A的路径)。 字典树(Trie)在计算机科学中，trie，又称前缀树或字典树，是一种有序树)，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。Trie这个术语来自于retrieval。根据词源学，trie的发明者Edward Fredkin把它读作/ˈtriː/ “tree”。但是，其他作者把它读作/ˈtraɪ/ “try”。在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。trie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise trie中的键是一串比特，可以用于表示整数或者内存地址。 树状数组(Binary Indexed Tree)树状数组或二叉索引树（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以的时间得到任意前缀和，并同时支持在时间内支持动态单点值的修改。空间复杂度。 线段树(Segment Tree)线段树（英语：Segment tree）是一种二叉树形数据结构，1977年由Jon Louis Bentley发明，用以存储区间或线段，并且允许快速查询结构内包含某一点的所有区间。一个包含个区间的线段树，空间复杂度为，查询的时间复杂度则为，其中 是匹配条件的区间数量。此数据结构亦可推广到高维度。 二叉搜索树(Binary Search Tree)二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合)、多重集、关联数组等。二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望，最坏（数列有序，树退化成线性表）。虽然二叉查找树的最坏效率是,但它支持动态查询，且有很多改进版的二叉查找树可以使树高为,如SBT,AVL树，红黑树等。故不失为一种好的动态查找方法。 递归(Recursion)递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。 脑筋急转弯(Brainteaser) 记忆化(Memoization)在计算机科学中，记忆化（英语：memoization而非memorization）是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 记忆化是一种典型的时间存储平衡方案。 队列(Queue)队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。 极小化极大(Minimax)Minimax算法（亦称 MinMax or MM）又名极小化极大算法，是一种找出失败的最大可能性中的最小值的算法。 蓄水池抽样(Reservoir Sampinh) Map 几何(Geometry) Rendom Rejection Samping 参考以上内容均来自wikipedia]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LInux学习5]]></title>
    <url>%2F2019%2F01%2Fyuque%2Flinux_learning5%2F</url>
    <content type="text"><![CDATA[网络命令 编译：peida 链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html ifconfig命令 概述许多Windows非常熟悉ipconfig命令工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有类似的工具，也就是ifconfig（interfaces config）。通常需要以root身份登录或者使用sudo以便在LInux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息等，还可以修改这些配置 命令格式ifconfig[网络设备][参数] 命令参数12345678910111213141516171819up 启动指定网络设备/网卡。down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。arp 设置指定网卡是否支持ARP协议。-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包-a 显示全部接口信息-s 显示摘要信息（类似于 netstat -i）add 给指定网卡配置IPv6地址del 删除指定网卡的IPv6地址&lt;硬件地址&gt; 配置网卡最大的传输单元mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。tunel 建立隧道dstaddr 设定一个远端地址，建立点对点通信-broadcast&lt;地址&gt; 为指定网卡设置广播协议-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议multicast 为网卡设置组播标志address 为网卡设置IPv4地址txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度 常用命令实例：显示网络设备信息（激活状态的）命令：ifconfig[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:20 inet addr:192.168.120.204 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0 TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:596390239 (568.7 MiB) TX bytes:2886956 (2.7 MiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:68 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2856 (2.7 KiB) TX bytes:2856 (2.7 KiB)说明：eth0表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址（MAC地址）是 00:50:56:BF:26:20inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.168.120.204，广播地址， Bcast:192.168.120.255，掩码地址Mask:255.255.255.0 lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）第二行：网卡的IP地址、子网、掩码第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节第四、五行：接收、发送数据包情况统计第七行：接收、发送数据字节数统计信息。 实例：启动关闭指定网卡命令：ifconfig eth0 upifconfig eth0 down说明：ifconfig eth0 up 为启动网卡eth0 ；ifconfig eth0 down 为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 实例：为网卡配置和删除IPv6地址命令：ifconfig eth0 add 33ffe:3240:800:1005::2/64ifconfig eth0 del 33ffe:3240:800:1005::2/64说明：ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0配置IPv6地址；ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0删除IPv6地址；练习的时候，ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 实例：用ifconfig修改MAC地址命令：ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE[root@localhost ~]# ifconfig eth0 down //关闭网卡[root@localhost ~]# ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE //修改MAC地址[root@localhost ~]# ifconfig eth0 up //启动网卡[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:AA:BB:CC:DD:EE inet addr:192.168.120.204 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0 TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:596390239 (568.7 MiB) TX bytes:2886956 (2.7 MiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:68 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2856 (2.7 KiB) TX bytes:2856 (2.7 KiB)[root@localhost ~]# ifconfig eth0 hw ether 00:50:56:BF:26:20 //关闭网卡并修改MAC地址 [root@localhost ~]# ifconfig eth0 up //启动网卡[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:20 inet addr:192.168.120.204 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0 TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:596390239 (568.7 MiB) TX bytes:2886956 (2.7 MiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:68 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:2856 (2.7 KiB) TX bytes:2856 (2.7 KiB) 实例：配置IP地址命令：[root@localhost ~]# ifconfig eth0 192.168.120.56 [root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 [root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255说明：ifconfig eth0 192.168.120.56 给eth0网卡配置IP地：192.168.120.56 ifconfig eth0 192.168.120.56 netmask 255.255.255.0 给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255/给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255 实例：启动和关闭ARP协议命令：[root@localhost ~]# ifconfig eth0 arp [root@localhost ~]# ifconfig eth0 -arp说明：ifconfig eth0 arp 开启网卡eth0 的arp协议；ifconfig eth0 -arp 关闭网卡eth0 的arp协议； 实例：设置最大传输单元命令：ifconfig eth0 mtu 1500[root@localhost ~]# ifconfig eth0 mtu 1480[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:1F inet addr:192.168.120.203 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1480 Metric:1 RX packets:8712395 errors:0 dropped:0 overruns:0 frame:0 TX packets:36631 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:597062089 (569.4 MiB) TX bytes:2643973 (2.5 MiB) [root@localhost ~]# ifconfig eth0 mtu 1500[root@localhost ~]# ifconfigeth0 Link encap:Ethernet HWaddr 00:50:56:BF:26:1F inet addr:192.168.120.203 Bcast:192.168.120.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:8712548 errors:0 dropped:0 overruns:0 frame:0 TX packets:36685 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:597072333 (569.4 MiB) TX bytes:2650581 (2.5 MiB)说明：设置能通过的最大数据包大小为1500bytes备注：用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在，要想将上述的配置信息永远的存在电脑里，那就要修改网卡的配置文件了。 route命令 概述Linux系统的toute命令用于显示和操作IP路由表（show / manipulate the IP routing table）。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在 Linux 系统中，设置路由通常是为了解决以下问题：该 Linux 系统在一个局域网中，局域网中有一个网关，能够让机器访问 Internet，那么就需要将这台机器的 IP 地址设置为 Linux 机器的默认路由。要注意的是，直接在命令行下执行 route 命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在 / etc/rc.local 中添加 route 命令来保证该路由设置永久有效。 命令格式route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 命令功能Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络连接口，如eth0。当使用参数时，路由表被修改，如果没有参数，则显示路由表当前内容 命令参数1234567891011121314151617181920-c 显示更多信息-n 不解析名字-v 显示详细的处理信息-F 显示发送信息-C 显示路由缓存-f 清除所有网关入口的路由表。 -p 与 add 命令一起使用时使路由具有永久性。add: 添加一条新路由。del: 删除一条路由。-net: 目标地址是一个网络。-host: 目标地址是一个主机。netmask: 当添加一个网络路由时，需要使用网络掩码。gw: 路由数据包通过网关。注意，你指定的网关必须能够达到。metric：设置路由跳数。Command 指定您想运行的命令 (Add/Change/Delete/Print)。 Destination 指定该路由的网络目标。 mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。 Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。 metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表 (与转发的数据包目标地址最匹配) 的多个路由中进行选择时可以使用。 if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。 常用命令实例：显示当前路由命令：routeroute -n[root@localhost ~]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.120.0 * 255.255.255.0 U 0 0 0 eth0e192.168.0.0 192.168.120.1 255.255.0.0 UG 0 0 0 eth010.0.0.0 192.168.120.1 255.0.0.0 UG 0 0 0 eth0default 192.168.120.240 0.0.0.0 UG 0 0 0 eth0[root@localhost ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.120.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0192.168.0.0 192.168.120.1 255.255.0.0 UG 0 0 0 eth010.0.0.0 192.168.120.1 255.0.0.0 UG 0 0 0 eth00.0.0.0 192.168.120.240 0.0.0.0 UG 0 0 0 eth0说明：第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240其中Flags为路由标志，标记当前网络节点的状态。Flags标志说明： 1234567U Up表示此路由当前为启动状态H Host，表示此网关为一主机G Gateway，表示此网关为一路由器aR Reinstate Route，使用动态路由重新初始化的路由D Dynamically,此路由是动态性地写入aM Modified，此路由是由路由守护程序或导向器动态修改! 表示此路由当前为关闭状态 备注：route -n (-n 表示不解析名字,列出速度会比route 快) 实例：添加网关/设置网管命令：route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0说明：增加一条 到达 244.0.0.0 的路由 实例：删除路由记录命令：route del -net 224.0.0.0 netmask 240.0.0.0route del -net 224.0.0.0 netmask 240.0.0.0 reject说明：删除224.0.0.0的路由记录 实例 ：删除和添加设置默认网关命令：route del default gw 192.168.120.240route add default gw 192.168.120.240 ping命令 概述Linux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性，我们经常会说”ping一下某机器，看是不是开着“、不能打开网页时会说””你先ping网关地址192.168.1.1试试“。它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样而我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。 命令格式ping [参数] [主机名或IP地址] 命令功能ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。 命令参数1234567891011121314-d 使用Socket的SO_DEBUG功能。-f 极限检测。大量且快速地送网络封包给一台机器，看它的回应。-n 只输出数值。-q 不显示任何传送封包的信息，只显示最后的结果。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。-R 记录路由过程。-v 详细显示指令的执行过程。&lt;p&gt;-c 数目：在发送指定数目的包后停止。-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。-I 网络界面：使用指定的网络界面送出数据包。-l 前置载入：设置在送出要求信息之前，先行发出的数据包。-p 范本样式：设置填满数据包的范本样式。-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。-t 存活数值：设置存活数值TTL的大小。 常用命令实例：ping的通的情况命令：ping 192.168.120.205输出：[root@localhost ~]# ping 192.168.120.205PING 192.168.120.205 (192.168.120.205) 56(84) bytes of data.64 bytes from 192.168.120.205: icmp_seq=1 ttl=64 time=0.720 ms64 bytes from 192.168.120.205: icmp_seq=2 ttl=64 time=0.181 ms64 bytes from 192.168.120.205: icmp_seq=3 ttl=64 time=0.191 ms64 bytes from 192.168.120.205: icmp_seq=4 ttl=64 time=0.188 ms64 bytes from 192.168.120.205: icmp_seq=5 ttl=64 time=0.189 ms — 192.168.120.205 ping statistics —5 packets transmitted, 5 received, 0% packet loss, time 4000msrtt min/avg/max/mdev = 0.181/0.293/0.720/0.214 ms[root@localhost ~]# 实例：ping不通的情况命令：ping 192.168.120.202输出：[root@localhost ~]# ping 192.168.120.202PING 192.168.120.202 (192.168.120.202) 56(84) bytes of data.From 192.168.120.204 icmp_seq=1 Destination Host UnreachableFrom 192.168.120.204 icmp_seq=2 Destination Host Unreachable 实例：ping指定次数命令：ping -c 10 192.168.120.206 实例：时间间隔和次数限制的ping命令：ping -c 10 -i 0.5 192.168.120.206 实例：多参数使用命令：ping -i 3 -s 1024 -t 255 192.168.120.206说明：-i 3 发送周期为 3秒 -s 设置发送包的大小为1024 -t 设置TTL值为 255 traceroute命令 概述通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。在大多数情况下，我们会在linux主机系统下，直接执行命令行：traceroute hostname而在Windows系统下是执行tracert的命令：tracert hostname 命令格式traceroute[参数][主机] 命令功能traceroute命令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小] 命令参数123456789101112131415-d 使用Socket层级的排错功能。-f 设置第一个检测数据包的存活数值TTL的大小。-F 设置勿离断位。-g 设置来源路由网关，最多可设置8个。-i 使用指定的网络界面送出数据包。-I 使用ICMP回应取代UDP资料信息。-m 设置检测数据包的最大存活数值TTL的大小。-n 直接使用IP地址而非主机名称。-p 设置UDP传输协议的通信端口。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-s 设置本地主机送出数据包的IP地址。-t 设置检测数据包的TOS数值。-v 详细显示指令的执行过程。-w 设置等待远端主机回报的时间。-x 开启或关闭数据包的正确性检验。 常用命令实例1：traceroute 用法简单、最常用的用法命令：traceroute www.baidu.com输出：[root@localhost ~]# traceroute www.baidu.comtraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets 1 192.168.74.2 (192.168.74.2) 2.606 ms 2.771 ms 2.950 ms 2 211.151.56.57 (211.151.56.57) 0.596 ms 0.598 ms 0.591 ms 3 211.151.227.206 (211.151.227.206) 0.546 ms 0.544 ms 0.538 ms 4 210.77.139.145 (210.77.139.145) 0.710 ms 0.748 ms 0.801 ms 5 202.106.42.101 (202.106.42.101) 6.759 ms 6.945 ms 7.107 ms 6 61.148.154.97 (61.148.154.97) 718.908 ms bt-228-025.bta.net.cn (202.106.228.25) 5.177 ms 7 124.65.58.213 (124.65.58.213) 4.343 ms 4.336 ms 4.367 ms 8 202.106.35.190 (202.106.35.190) 1.795 ms 61.148.156.138 (61.148.156.138) 1.899 ms 1.951 ms 9 30 *[root@localhost ~]# 说明：记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。 Traceroute的工作原理Traceroute最简单的基本用法是：traceroute hostnameTraceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器…… traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。 scp命令 概述scp命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp知识在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读read only system时，用scp可以帮你把文件移出来。另外scp还非常不占资源，不会提高多少系统负荷，在这一点上rsync就远远不及它了。虽然rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 命令格式scp [参数] [原路径] [目标路径] 命令功能scp是secure copy的缩写，scp是Linux系统基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在Linux服务器之间复制文件和目录。 命令参数1234567891011121314151617-1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 常用命令实例：从远处复制到本地/从本地复制到远处命令：scp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/scp -r /opt/soft/mongodb root@192.168.120.204:/opt/soft/scptest说明：从192.168.120.204机器上的/opt/soft/中下载mongodb 目录到本地的/opt/soft/目录来。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vim 实用技巧]]></title>
    <url>%2F2019%2F01%2Fyuque%2Fvim_skill%2F</url>
    <content type="text"><![CDATA[希望由厚至薄 概述 学习Vim，最难受的就是它对新手出名的不友好，网上一大堆乱七八糟的东西，还是自己进行学习对自己的帮助最大。建议首先学习 :vimtutor 入门vim学习。最好会盲打，自己看了这本 vim 实用技巧。 第 1 章 Vim解决问题的方式{char} 是指任意字符 指cw会删除光标位置到当前词位置结尾处的文本，并进入插入模式&gt;G是首行缩进C=c$ 删除到行尾再插入o=A下一行插入s删除光标处再插入@：重复命令行命令&amp;重复替换命令f{char} 搜索，; 下一个字符，, 上一个字符* 可以查看当前光标下的单词理想模式：用一个键移动，另一键执行。又称为 “.范式”。 第一部分 模式Vim 提供一个区分模式的用户界面，就是说在 Vim 中按键盘上的任意键所产生的结果可能会不一样，而这取决于当前正处于哪种模式，以及如何在各模式间切换，是极其重要的。在本书的这一部分，我们将学习每种模式的工作方式及其用途。 第 2 章 普通模式b 把光标移动到单词开头daw 在单词末尾也能删除 在数字上执行加一，不在数字上，在当前行正向查找一个数字，10 在数字上执行减一最好不要用数字 d2w 这样，因为 . 能很好代替，但是 c3w 有用，行中间来快速进行修改g~ 反转大小写，gu 转成小写，gU转成大写。gUap 将一段转换为大写，g 当成操作符前缀gc{motion} 切换为注释状态，gcap 切换当前段落的注释状态。gcG 当前行到文件结尾间的所有内容注释掉，gcc 注释当前行，gg=G 自动缩进整个文件。 第 3 章 插入模式在输入错误时，专业打字员会建议先删除整个单词，然后再重新输入一遍。 删除前一个字符（同退格键） 删除前一个单词 删至行首。&lt;c-[&gt;切换到普通模式， 切换到插入-普通模式。在此模式中，可以执行一个普通模式命令，执行完后，马上又返回到插入模式 按键操作 缓冲区内容 yt, Practical Vim, by Drew NeilRead Drew Neil’s jA␣ Practical Vim, by Drew NeilRead Drew Neil’s 0 Practical Vim, by Drew NeilRead Drew Neil’s Practical Vim . Practical Vim, by Drew NeilRead Drew Neil’s Practical Vim. yt, 命令把“Practical Vim”复制到复制专用寄存器中,0 把刚才复制的文本粘贴到光标所在位置= 符号指明使用表达式寄存器,=6*35，将执行结果插入到文档的当前位置{code}根据字符编码插入字符，{code} 是要插入字符的编码，065插入Au{1234} 以十六进制字符编码插入字符ga 分别以十进制和十六进制的形式显示出其字符编码{char1}{char2} 插入以二合字母{char1}{char2}表示的字符，?I 表示的“¿”字符，二合字母 12 指1⁄2R 命令可以由普通模式进入替换模式，“,␣b” 替换原有的“. ␣ B”字符gR 进入虚拟替换模式(Virtual Replace mode)，把制表符当成一组空格进行处理，输入制表符占据的最后一个字符，该字符会替换制表符。 第 4 章 可视模式viw 来高亮选择这个词,用 c 命令进行修改V 激活面向行的可视模式 激活面向列块的可视模式gv 重选上次的高亮选区o 切换高亮选区的活动端，vbb ，o ，e重复执行面向行的可视命令，Vj ，&gt;.vit 可被解读为高亮选中标签内部的内容(visually select inside the tag),it 命令是一种被称为文本对象(text object)gUit 要优于 vitU 命令，首选操作符命令，再者是可是模式命令，可视模式擅长一次性处理和动作命令难以构建的文本范围技巧24 面向列块的可是模式编辑表格数据，在一行下生成分割线 yyp，Vr-列块可视模式,插入操作只影响顶行，但实际影响所有，插入模式时间很短暂I 命令把光标置于当前行的开头 第 5 章 命令行模式有些命令在插入模式和命令行模式中可以通用。例如,可以用 和 分别删除至上个单词的开头及行首,也可以用 或 来插入键盘上找不到的字符,还可以用 {register} 命令把任意寄存器的内容插入到命令行。Ex 命令可以在任意位置执行 :3d 等于 3G dd 一定程度上要比普通模式命令要快. 代表当前行的地址，:.,$d 这样的命令可能很实用% 代表当前文件中的所有行，:%s/Practical/Pragmatic/可视模式加命令行模式，VG，输入 ：命令行上就会预先填充一个范围 :’&lt;,’&gt; 。代表高亮选区的范围:6copy. 命令解读为“为第 6 行创建一份副本,并放到当前行下方”，:copy 简写:co 或是 :t:t6 把当前行复制到第 6 行下方，:t$ 把当前行复制到文本结尾快速跳回原先的位置( )，在复制距离较远的行时, :t 命令通常更加高效。: yyp 会使用寄存器，不想覆盖默认寄存器中的当前内容时，可以考虑使用 :t. 来复制行:’&lt;,’&gt;m$ 等于 :’&lt;,’&gt;m$，重复上次的 Ex 命令 @:‘&lt;,’&gt;normal . 命令可以解读为“对高亮选区中的每一行,对其执行普通模式下的 . 命令”。:%normal i// 把整个 JavaScript 文件注释掉:normal 命令则让我们可以把具有强大表现力的 Vim 普通模式命令与具有大范围影响力的 Ex 命令结合在一起遍历缓冲区列表的条目，:bn[ext] 可以在列表中逐项正向移动,而 :bp[revious] 命令则进行反向移动 逐个查看每个缓冲区 :bnext，@: 命令和:bprevious 命令可能会出现反向遍历缓冲区列表，将人搞糊涂，更好用 命令，该命令会回到跳转列表的上条记录。想往回跳,就用 命令。 命令会让 Vim 显示可用的补全列表，按 键依次显示 用于插入光标下的单词，插入光标下的字串，一般和 * 、:%s 一起使用，:%s///g命令行窗口就像是一个常规的 Vim 缓冲区,只不过它的每行内容都对应着命令历史中的一个条目。我们可以用 k 及 j 键在历史中向前或向后移动,也可以用 Vim 的查找功能查找某一行。在按下 键时,将会把当前行的内容当成 Ex 命令加以执行。好处是强大的vim编辑能力可以派上用场。q: 调出命令行窗口，J 命令合并下一行，命令行窗口处于打开状态时,它会始终拥有焦点。 从命令行模式切换到命令行窗口，已经输入到命令行上的内容仍然会得以保留:!ls 执行 Shell 中的程序，在 Vim 的命令行中,符号 % 代表当前文件名(指调用了shell程序时)执行几条命令:shell 命令来启动一个交互的 shell 会话,用 exit 命令可以退出此 shell 并返回 Vim把 Vim 置于后台，看书 p 94 命令会产生大量输出，用:read !{cmd} 命令，它让我们把命令的标准输出重定向到缓冲区。:write !{cmd} 做相反的事。它把缓冲区内容作为指定 {cmd} 的标准输入:write! sh 把缓冲区内容写到一个名为 sh 的文件，叹号放得位置不同,命令的作用]也大相径庭。:write !sh 命 令 的 作 用 是 在 shell 中 执 行 当 前 缓 冲 区 中 的 每 行 内 容Vim 把过滤器定义为“一个由标准输入读取文本,并对其进行某种形式的修改后输出到标准输出的程序”:2,$!sort -t’,’ -k2，命令行结合 shell 来对文本进行处理。Vim 提供了一种方便的快捷方式来设置 :[range]!{filter} 命令中的范围。我们可以用 !{motion} 操作符切换到命令行模式,并把指定 {motion} 所涵盖的范围预置在命令行上，如果我们把光标移到第 2 行,然后执行 !G ,Vim 就会打开命令行并把范围 :.,$! 预置在命令行上。虽然此后我们仍需输入剩下的 {filter} 命令,但这毕竟节省了部分工作。:read !{cmd} 在 shell 中执行 {cmd} ,并把其标准输出插入到光标下方:[range]write !{cmd} 在 shell 中执行 {cmd} ,以 [range] 作为其标准输入:[range]!{filter} 使用外部程序 {filter} 过滤指定的 [range] 第二部分 文件在本书的这一部分，我们将学习如何使用文件及缓冲区。Vim 允许在一个编辑会话中编辑多个文件，我们既可以每次显示一个文件，也可以把工作区分成若干个分割窗口或标签页，每个窗口或标签页包含一个独立的缓冲区。另外，我们还会看到在 Vim 中打开文件的机种不同方式，并掌握一些方法来解决无法把缓冲区保存到文件的问题。 第 6 章 管理多个文件我们编辑的只是内存中的映像，也就是 Vim 术语中的“缓冲区”。 :ls 命令会列出所有被载入到内存中的缓冲区的列表， :bnext 命令可以切换到列表中的下一个缓冲区，% 符号指明哪个缓冲区在当前窗口中可见，而 # 符号则代表轮换文件。按 &lt;C-^&gt; 可以在当前文件和轮换文件间快速切换。 :bprev (bp) 和 :bnext (bn)在列表中反向或正向移动；而 :bfirst 和 :blast 则分别跳到列表的开头和结尾 12《 1 # "a.txt" line 1 2 %a "b.txt" line 1 :buffer N 命令直接凭编号跳转到一个缓冲区，:buffer {bufname} 格式实现同样的功能。{bufname} 只需包含文件路径中 足以唯一标识此缓冲区的字符即可 删除缓冲区，可以用 :bdelete 命令, :5,10bd ,删除编号 5～10（包含 5 和 10）的缓冲区 用 :argdo 命令可以在参数列表中的每个文件上执行一条 Ex 命令。 当不带参数运行 :args 命令时，它会打印当前参数列表的内容。 :args {arglist} {arglist} 可以包括文件名、通配符，甚至是一条 shell 命令的输出结果 填充参数列表最简单的方式是逐一指定文件的名字：➾ :args index.html app.js 通配符也匹配 0 个或多个字符，但它可以递归进入指定目录的子目录 :args /.js , :args **/.js */.css :args cat .chapters 按 Go 在缓冲区的结尾增加一个空行,缓冲区 a.txt 前有一个 + 号，表示这个缓冲区被修改过了,被标记为 h，表示它是一个隐藏缓冲区（hidden） :w[rite] 把缓冲区内容写入磁盘 :e[dit]! 把磁盘文件内容读入缓冲区（即回滚所做修改） :qa[ll]! 关闭所有窗口，摒弃修改而无需警告 :wa[ll]! 把所有改变的缓冲区写入磁盘 启用‘hidden’选项,运行完 :argdo {cmd} 后,一切正常，可以运行 :argdo write （或 :wall）来保存所有的缓冲区。 用 s 命令可以水平切分此窗口，使之成 为两个高度相同的窗口；或者可以用 v 命令对其进行垂直切分，这样会产生两 个宽度相同的窗口 编辑长文件时,可以滚动其中一个窗口，使之显示缓冲区的一部分，这样，在修改第二 个窗口中缓冲区的另外一部分时，就可以参考第一个窗口中的内容。 :sp[lit] {file} 水平切分当前窗口，并在新窗口中载入{file} :vsp[lit] {file} 垂直切分当前窗口，并在新窗口中载入{file}w 在窗口间循环切换 h 切换到左边的窗口 j 切换到下边的窗口 k 切换到上边的窗口 l 切换到右边的窗口,按住 键，然后再输入 ww （或 wj ，或上表中的其他命令）来切换活动窗口。 = 使所有窗口等宽、等高 _ 最大化活动窗口的高度 | 最大化活动窗口的宽度 [N]_ 把活动窗口的高度设为[N]行 [N]| 把活动窗口的宽度设为[N]列,用鼠标做最好 用 :edit 命令打开一个文件时，Vim 却不会自动创建一 个新标签页，而是会创建一个新缓冲区，并把该缓冲区显示到当前窗口。应该把标签页想成容纳一系 列窗口的容器 :lcd {path} 命令让我们可以设置当前窗口的本地工作目录。如果我们创建了一 个新标签页，并用 :lcd 命令切换到另一个目录，那么就可以把每个标签页限制在不 同的工程范围内。用 :tabedit {filename} 命令可以打开一个新的标签页，如果省略了 {filename} 参数的话，那么 Vim 会创建一个新标签页，里面包含一个空缓冲区 T 命 令把当前窗口移到一个新标签页中 :tabc[lose] 关闭当前标签页及其中的所有窗口 :tabo[nly] 只保留活动标签页，关闭所有其他标签页 :tabmove [N] 命令可以重新排列标签页。省略了 [N]，当前标签页会被移到结尾，如果支持鼠标，则用鼠标拖拽 第 7 章 打开及保存文件:edit {file} 命令可以接受相对于工作目录的文件路径 % 符号代表活动缓冲区的完整文件路径，:h 修饰符会去除文件名，但保留路径中的其他部分 :edit %:hM $ vim . 在按 键时，Vim 会打开光标下的条 目。如果光标位于目录上，那么此窗口的内容会更新为该目录的内容；如果光标位于文件上，那么该文件会被载入一个缓冲区里，并把它显示在当前窗口中。这将导致当 前窗口中的文件管理器被该缓冲区的内容所替代 :edit . :e. 打开文件管理器，并显示当前工作目录 :Explore :E 打开文件管理器，并显示活动缓冲区所在的目录 :E 及 :e. 命令表现得有些古怪，因为它们会用文件管理器替换掉当前窗口的内容，想象成一张纸牌，如果在调出文 件管理器后，又想切换回刚才正在编辑的那个文件，此时可以使用 &lt;C-^&gt; 命令。 杀手级功能，其名字正因为此功能而来，即 netrw 可 以通过网络读写文件。该插件可以利用多种协议读写网络文件，包括 scp、ftp、curl 及 wget，这取决于你的系统上可以用哪些协议。（手动流汗） 命令用于显示当前文件的文件名及状态，以超级用户执行，tee /etc/hosts &gt; /dev/null。这条命令会把缓冲区的内容当作标准输入，并用它来覆盖 /etc/hosts 文件的内容，下面文件与缓冲区的内容刚好是完全一致的。 第三部分 更快地移动及跳转动作命令是进行 Vim 操作的最重要的一些命令。我们不仅可以用它们四处移动光标，还能够用它们与操作符待决模式配合使用，指定一段文本范围并在其上进行操作。在本书的这一部分，我们将结识一些最为有用的动作命令，另外，我们还会学习 Vim 的跳转命令，这些命令让我们可以在文件间快速地跳转。 第 8 章 用动作命令在文档中移动我们不用把手从本位行上移开，就可以上下左右移动，操作符待决模式中最出彩的明星是文本对象如果你在一行中连续按了两次以上的 h 键，那就是在浪费时间（手动流汗）。 即 j、k、0和 $ 都用于操作实际行，而如果在这些 键前加上 g 前缀的话，就会让 Vim 对屏幕行进行操作 w 正向移动到下一单词的开头 (for-)wordb 反向移动到当前单词/上一单词的开头 back-worde 正向移动到当前单词/下一单词的结尾ge 反向移动到上一单词的结尾ea 命令连在一起可被解读为“在当前单词结尾后添加”gea 命令当成“在上一单词结尾后 添加”的命令 我们之前遇到过的每个面向单词的动作命令，都有一个面向字串的命令与其对 应，这当中包括 W、B、E和 gE一个单词由字母、数字、下划线，或其他非空白字符的序列组成，单词间以空白 字符分隔，字串的定义则更简单，它由非空白字符序列组成， 字串间以空白字符分隔 Vim 会记录 上次执行过的 f{char} 命令，随后用 ; 命令就可以重复该命令了，用 , 命令就可以再跳回来f{char} 正向移动到下一个 {char} 所在之处F{char} 反向移动到上一个 {char} 所在之处t{char} 正向移动到下一个 {char} 所在之处的前一个字符上T{char} 反向移动到上一个 {char} 所在之处的后一个字符上; 重复上次的字符查找命令, 反转方向查找上次的字符查找命令 f,dt.训练成手指的下意识动作（删除 , 和 . 之间的内容） 缺省的 键是 \ 查找命令不仅限于在普通模式下使用，我们也可以在可视模式及操作符待决模式 中使用它，用来完成实际的工作删除工作会更方便，先高亮然后通过命令行模式进行大范围选择。d/ge 用 /ge 查找动作告诉 d{motion} 命令删除什么。查找命令是 一个开动作，也就是说，虽然光标是在单词“gets”开头的“g”上的，但此字符却被 排除在删除操作之外，用 v 还需要 h 一下把 d{motion} 操作符与查找动作结 合在一起使用，这是个很大的进步，你可以好好在朋友和同事们面前炫耀一番了 可以把 i 想成“inside”，而把 a 想成 “around” 或“all”。 文本对象自身并不是动作命令，我们不能用它们在文档中移动。但是我们却可以 在可视模式及操作符待决模式中使用文本对象 ：每当在命令语法里看到 {motion} 时，你也可以在这个地方使用文本对象，常见的例子包括 d{motion}、 c{motion}和 y{motion} 把 ci” 命令解读为“修改双引号内部的内容”，把 cit 命令解读为“修 改标签内部的内容”。另外，我们也可以很容易地用 yit 命令拷贝标签内的文本，或 者是用 dit 删除这些文本。 如果说 f{char} 和 /pattern 命令如同单足飞踹， 那么文本对象则像是一次攻击两个目标的剪刀腿 iw 和 aw 之间的区别很微妙，为什么会需要这样两个文本对象呢？ciw 命令只删除该单词，而不删除其前后的空白字符，随后它会进入插入模式， 这刚好是我们想要的效果。如果用的是 caw 的话，那最后两个单词就会连在一起一般来说，d{motion} 命令和 aw、as 和 ap 配合起来使用比较好，而 c{motion} 命令和 iw 及类似的文本对象一起用效果会更好。 m{a-zA-Z} 命令会用选定的字母标记当前光标所在位置,mm 和 `m 命令是一对便于使用的命令，它们分别设置位置标记 m，以及跳转到 该标记% 命令允许我们在一组开、闭括号间跳转,在执行 % 命令时，Vim 会 自动为发生跳转的地方设置一个位置标记, % 命令只能用在配对的括号上,所以利用替换命令时最好利用位置标记，防止陷阱。 第 9 章 在文件间跳转:jumps 查看跳转列表的内容，如果我们运行 :edit 命令 打开了一个新文件，那么就可以用 和 命令在这个新文 件以及原本的文件之间来回跳转，会始终在 当前活动窗口的跳转列表范围内进行跳转， Vim 本来就把 和 当成同一个东西。映射需谨慎。 Vim 会在编辑会话期间维护一张表，里面记载我们对每个缓冲区所做的修改， 此表就是所谓的改变列表 :changes，用 g; 和 g, 命令反向或正向遍历改变列表。改变列表中则保存了多组位置。我们可以多次按 g; 命令，每次它都会把 我们带到改变列表中较早的一个位置，而 `. 则总是把我们带到改变列表的最后一项。 执行 gf 命令“go to file”加上 .rb 扩展名，用 ‘suffixesadd’ 选项做到这一点 :set suffixesadd+=.rb查看 ‘path’ 选项的值:set path?《 path=.,/usr/include,,&lt;C-]&gt; 命令的作用也类似。它也需要进行一些配置（在技巧 102 中讨论），然而 一旦正确配置好，它就允许我们从函数调用的地方直接跳到该函数定义的地方 用两次按键就可以打开你的 vimrc 文件，先打开你的 vimrc 文件，按 mV 设置一个全局标记（助记词 V 代 表 vimrc），然后切换到另一个文件中按 `V 缺省情况下，:vimgrep 会直接跳到它所找到的第一处匹配上，这或许会切换到 另外一个文件。一般来说，要养成在使用与 quickfix 列表有关的命令前，如:grep、:vimgrep 及:make，设置全局标记的习惯。另外，在执行与缓冲区列表或参数列表有关的命令前， 如:args {arglist}和:argdo（参见技巧 37），也要设置全局标记。 你总共可以设置 26 个全局位置标记，可以迅速跳回。 第四部分 寄存器Vim 的寄存器是一组用于保存文件的简单容器。它们既可像剪贴板那样，剪切、复制和粘贴文本；也可以记录一系列按键操作，把它们录制成宏。通过本书的这一部分，我们将掌握这一核心功能。 第 10 章 复制与粘贴xp，可被用于“调换光标之后的两个字符”ddp，可被用于“调换当前行和它的下一行” diw 命令不仅删除了单词，而且还将它拷贝到了无名寄存器，按 P时得到的是刚刚删除的单词，而不是之前复制的单词，给命令加 “{register} 前缀的方式指定要用的寄存器，Vim 将缺省使用无 名寄存器。”ayiw复制，用 “bdd删除，”ap粘贴，可以解决无名寄存器的问题，使用复制寄存器也可以解决，黑洞集训器从删除方面也可以解决 Vim 的 delete 命令也与标准剪切操作的作用一致。也就是说，该命令会先把 指定文本复制到寄存器后再从文档中删掉，引用黑洞寄存器，”_d{motion}会执行真正的删除操作。 无名寄存器（””）， “”p，它完全等同于 p命令，x 和 d{motion} 经常被当作“删除”命 令。这其实是用词不当，把它们理解为“剪切”命令会更合适 复制专用寄存器（”0）使用 y{motion} 命令时，要复制的文本不仅会被拷贝到无名寄存器中，而且也被拷贝到了复制专用寄存器中，因为专用，只有 y 能触发 检查无名寄存器和复制专用寄存器的内容，:reg “0 ，小问题用复制专用寄存器，如果碰到需要将一段或多段文本粘贴到多处的情况，有名寄存器就会大显神通。用小写字母引用有名寄存器，会覆盖该寄存器的原有内容，而换用大写字母的话，则会将新内容添加到该寄存器的原有内容之后 如果我们在外部程序中用剪切或复制命令获取了文本，就可以通过 “+p 命令（或 在插入模式下用 +）将其粘贴到 Vim 内部。相反地，如果在 Vim 的复制或删除 命令之前加入 “+ ，相应的文本将被捕获至系统剪贴板。“+ X11 剪贴板，用剪切、复制与粘贴命令操作 “ X11 主剪贴板，用鼠标中键操作把它们粘贴出来，Windows与Mac OS X操作系统并没有主剪贴板的概念，因此 “+ 寄存器与 “ 寄 存器可以混用，它们都代表系统剪贴板。 表达式寄存器（”=）当我们从表达式寄存器获取内容时，Vim 将跳到命 令行模式，并显示提示符“=”。这时，我们可以输入一段 Vim 脚本表达式并按 执行，如果返回的是字符串（或者可被强制转换成字符串的数据），Vim 将会使用它 只读寄存器 “% 当前文件名 “# 轮换文件名 “. 上次插入的文本 “: 上次执行的Ex命令 “/ 上次查找的模式 在可视模式下使用 p 命令时，Vim 将用我们指定的寄存器内容来替换高亮选区中的文本，可视再次解决了文本”丢失”现象，我们输入 u 撤销上次的修改。然后，按 gv重选上一次高亮选区的内容，再按一次 p键。发生了什么？显然什么也没发生，第一次使用 p时，之所以成功，是因为无名寄存器恰巧包含了我们想要的 文本。但在第二次使用 p时，无名寄存器包含的是被覆盖的内容，所以可是模式替换内容也会进入无名寄存器 在 Vim 的可视模式下使用 p命令时。首先，从无名寄存器里取出内容，然后，把高亮选区中的内容存入无名寄存器。（花里胡哨） c3w命令删除“chips and fish”并重新输入“fish and chips”， 应该会更快地完成任务。但是，以上方法可被用于交换更长的短语 p 命令旨在将寄存器中的文本粘贴到光标之后，P 命令用于将文本插入到光标之前，puP 和 Pup几乎成了下意识动作。当要粘贴的内容来自于面向行的寄存器时，p 和 P 命令会把它们粘贴至当前行的 上一行或下一行。这一点比面向字符的行为更直观 在插入模式下，我们可以通过输入 “ 来插入无名寄存器的内容，或者输入 0来插入复制专用寄存器的内容gp和 gP命令也值得关注，它们会把光标的位置移到被粘贴出来的文本结尾而不是开头。 当复制多行文本时，gP命令尤为管用，P 和 gP 命令区别 如果你运行的 Vim 是已集成系统剪贴板的版本，就可以完全避免与’paste’ 选项打交道了。普通模式下的 “+p 命令用来粘贴加号寄存器中的内容，即系统剪 贴板的镜像。 第 11章 宏]]></content>
      <categories>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[servlet学习ing]]></title>
    <url>%2F2018%2F11%2Fservlet%2F</url>
    <content type="text"><![CDATA[http协议：超文本传输协议概念和作用特点作用：规范浏览器（客户端）与服务器之间的数据交互 特点：简单、快捷、灵活、无连接（http1.1后支持可持续连接）、无状态（没有记忆，数据量大，新应答快速） 交互流程、请求格式、请求方式交互流程：客户端和服务器建立连接客户端法发送请求到服务器端服务器端接收到请求后进行处理，然后将处理结果相应客户端关闭客户端和服务器端的连接（HTTP1.1后不会立即关闭）请求格式：结构：请求头、请求行、空行、请求数据​​请求方式（结构大致一样，方式可能不同）：HTTP1.0：GET（？后有请求数据，不安全）、POST、HEAD方法HTTP1.1：OPTIONS、PUT、DELETE、TRACE、CONNECT方法​ 响应格式的结构和常见的状态码响应行（状态行）：HTTP版本、状态码、状态消息响应头：消息报头、客户端使用的附加信息空行：响应头和响应实体之间必须的响应实体：正文，服务器返回浏览器的信息​​常见的状态码（告诉浏览器）：​​ 服务器（主流是Tomcat）：本质：实际上就是java网络编程用代码编写的一个容器Tomcat目录结构：​​因为含有class文件，所以一定要依靠jdk，java虚拟环境 Servlet技术：概念和介绍 程序员在编写代码的时候如果能够按照服务器能够识别的规则进行编写，浏览器按照指定的规则进行发送请求（服务器识别就类似于JVM找main（）方法似的，有指定的规则），那么服务器就可以调用并执行响应的逻辑代码进行请求处理了。 ​​ 本质上就是服务器能够识别的接口规范1.创建普通的java类并继承HttpServlet方法2.覆写service方法3.在service方法中书写逻辑代码就行4.在webRoot下的WEB-INF文件夹下的web.xml文件中配置servlet（确保能找到）现在很多IDE环境不需要将class文件移交到相应的Tomcat下 运行（访问）流程：URL: http://localhost:8080/01.MyServlet/my2组成：服务器地址：端口号/服务器下webapps下的文件夹的名称（虚拟项目名）/（servlet的别名）要执行的servlet的url-pattern（因为防止包名类名被黑客利用，需有一定的隐藏，所以采用url-pattern的规则） URI：虚拟项目名/ servlet的别名123456789&lt;servlet&gt; &lt;servlet-name&gt;my2&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bjsxt.servlet.MyServlet2&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;my2&lt;/servlet-name&gt; &lt;url-pattern&gt;/my2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 相当于起一个别名，通过web.xml下找到my2，再找到包类名，找不到则404（my2相当于暗号）服务器会加载一下本地的文件，删除文件并关闭服务器再打开会提示报错信息 Servlet生命周期：1.第一次调用到服务器关闭2.如果servlet在web.xml中配置了load-on-startup之间的数字表示顺序，生命周期为从服务器启动到服务器关闭3.注意：Init方法是对servlet进行初始化的一个方法，会在servlet第一次加载进行存储时进行Destroy方法是在servlet销毁时执行 Jsp中的表单数据：​​ Service和doGet和doPost方法的区别： Service方法:可以处理get、post方式的请求，如果servlet中包含service方法，优先调用service方法对请求进行处理 doGet方法:处理get方式的请求 doPost方法:处理post方式的请求注意：如果在覆写的service方法中调用了父类的service方法（super.service（arg0,arg1））,则service方法处理后，会再次根据请求方式响应的doGet和doPost方法执行。一般情况下，不在service中调用父类的service方法，避免出现405错误 Servlet常见错误：404错误：资源未找到在请求地址中的servlet的别名书写错误虚拟项目名称拼写错误500错误：不可预估的错误在web.xml中校验servlet类的全限定路径是否拼写错误。service方法体的代码执行错误所致，根据错误提示对service方法体中的代码进行更改405错误：请求方式不支持请求方式和servlet中的方法不匹配所导致的，尽量使用service方法进行请求处理，并且不要在service方法中调用父类的service。 Request对象：介绍和获取请求头信息 服务器接收到浏览器的请求后，会创建一个request对象，对象中存储了此次请求相关的请求数据。服务器在调用servlet时会将创建好的request对象作为实参传递给servlet的方法，比如service方法。 使用：获取请求头数据、请求行数据、用户数据作用：request对象中封存了当前请求的多有请求信息注意：request对象由Tomcat服务器创建，并作为实参传递给处理请求的servlet的service方法 Service中的形参以req为例子 获取请求头数据：获取请求方式12String method = req.getMethod();Sout(method); 获取请求URL12StringBuffer url = req.getRequestURL()l;Sout(url); 获取URI12String uri = req.getRequestURI();Sout(uri); 获取协议12String h = req.getScheme();Sout(h); 获取请求行数据;获取指定的请求行信息1String value = req.getHeader(“User-Agent”);//根据F12浏览器端找到的键值，加入想要获取666但是你没有，那么你在控制台后收到null 获取所有的请求行的键的枚举12Enumeration e = req.getHeaderNames();while(e.hasMoreElements())&#123; 获取所有键值1sout(e.nextElement()); 获取所有信息123String name = (String)e. nextElement();String value2= req.getHeader(name);Sout(name+”:”+value2); 获取用户数据：req.getParameter(“键名”);(返回指定的用户数据，不能获得同键不同值的多项选择数据，会漏值)​​ 避免漏值​​12req.getParameterValue(“键名”);(返回同键不同值的请求数据（多选），返回数组)req.getParameterNames(“键名”);(返回所有请求数据的枚举集合) 注意：如过要获取的请求数据不存在，不会报错，返回null。 request对象学习问题：在使用request对象获取请求数据并进行处理后，处理的结果如何显示到浏览器中？总结：Service请求处理代码流程：设置响应编码格式、获取请求数据、处理请求数据、数据库操作（MVC思想）、响应处理结果响应实体里面可以设置具体的html代码（无JSP的麻烦之处）乱码问题：记得服务器到浏览器，浏览器到服务器两个半流程中的编码规范问题servlet流程总结： Request作用域问题：使用请求转发后，不同的servlet之间怎么进行数据共享呢？或者说数据怎么从一个servlet流转给另外一个servlet呢？解决：使用request对象的作用域 请求转发：问题：服务器在接收到浏览器的请求后，仅仅使用一个servlet进行请求处理，会造成不同的servlet逻辑代码冗余，servlet的职责不明确解决：使用请求转发特点：一次请求、地址栏信息不改变 重定向学习问题：如果当前的请求servlet无法处理怎么办？如果使用请求转发，造成表单数据重复提交怎么办？解决：使用重定向 Cookie学习Cookie介绍、使用、设置有效期、信息获取 Cookie三天免登录 session学习session介绍及原理问题：request对象解决了一次请求内的不同servlet的数据共享问题，那么一个用户的不同请求的处理需要使用相同的数据怎么办呢？解决：使用session技术原理：用户使用浏览器第一次向服务器发送请求，服务器在接收到请求后，调用响应的servlet进行处理。在处理过程中会给用户创建一个session对象，用来存储用户请求处理相关的公共数据，并将此session对象的JSESSIONID以cookie的形式存储在浏览器中（临时存储，浏览器关闭即失效）。用户在发起第二次请求及后续请求能够获取同一个session对象，也保证了不同请求能够获取到共享的数据。 session特点及使用特点：存储在服务器端、服务器进行创建、依赖cookie技术、一次会话作用：解决了一个用户不同请求的数据共享问题使用： 创建session对象/获取session对象 设置session存储时间（一般为30分钟） 设置session强制失效hs.invalidate(); 注意JSESSIONID以cookie的形式存储在浏览器中（临时存储，浏览器关闭即失效） session数据流转和总结存储和获取数据使用时机：一般用户在登录web项目时会将用户的个人信息存储到session中，供该用户的其他请求使用总结：session解决了有个用户的不同请求的数据共享问题，只要在JSESSIONID不失效和session对象不失效的情况下，用户的任意请求在处理时都能获取到同一个session对象。作用域：一次会话（在JSESSIONID不失效和session对象不失效的情况下为整个项目内）session失效处理：将用户请求中的JSESSIONID和后台获取到的session对象JSESSIONID进行对比，如果一致则session没有失效，否则证明session失效了。重定向到登录界面，让用户重新登录。 解决主页面用户名显示为null的问题原因：因为在用户登录成功后使用重定向显示主页面，两次请求，而用户的信息在第一次请求中，第二次请求中没有用户数据，所以显示为null解决：使用session ServletContext对象学习问题：request解决了一次请求内的数据共享问题，session解决了用户不同请求的数据共享问题，那么不同的用户的数据共享该怎么办呢？解决：使用ServletContext对象作用：解决了不同用户的数据共享问题原理：ServletContext对象由服务器进行创建，一个项目只有一个对象。不管在项目的任意位置进行获取得到的都是同一个对象，那么不同用户发起请求获取到的也就是同一个对象了，该对象由用户共同拥有特点：服务器创建、用户共享、一个项目只有一个生命周期：服务器启动到关闭作用域：项目内使用：获取ServletContext对象/使用ServletContext对象完成数据共享获取项目中web.xml文件中的全局配置数据获取项目webroot下的资源的绝对路径/流对象使用ServletContext对象完成网页计数器在用户登录校验中创建计数器并自增，然后存储到ServletContext对象中，在主页面中取出计数器数据并显示给用户即可 ServletConfig对象问题：使用ServletConfig对象可以获取web.xml中的全局配置文件，在web.xml中每个servlet也可以进行单独的配置，那么该怎么获取配置信息呢？解决：使用ServletConfig对象作用：ServletConfig对象是servlet的专属配置对象，每个servlet都单独拥有一个ServletConfig对象用来获取web.xml中的配置信息使用： web.xml文件作用：存储项目相关的配置信息，保护servlet。解耦一些数据对程序的依赖使用位置：每个web项目中、tomcat服务器中（在服务器目录conf目录中）区别：web项目下的web.xml文件为局部配置，针对本项目的位置tomcat下的web.xml文件为全局配置，配置公共信息内容（核心组件）：全局上下文配置（全局配置参数）、servlet配置、过滤器配置、监听器配置加载顺序：web容器会按照ServletContext-&gt;context-param-&gt;listener-&gt;filter-&gt;servlet这个顺序加载组件，这些元素可配置在web.xml中的任意位置加载时机：服务器启动时 server.xml文件问题：浏览器发起请求后服务器根据请求在webapps目录下调用对应的servlet进行请求处理。那么为什么是webapps目录而不是其他的目录呢？解决：了解server.xml文件的配置信息server.xml文件核心组件：热部署：1&lt;Context path=&quot;/Pet&quot; reloadable=&quot;false&quot; docBase=&quot;F:/PetWeb&quot; /&gt; 参考链接：B站菜鸟教程]]></content>
      <categories>
        <category>Java</category>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在前面]]></title>
    <url>%2F2018%2F08%2Ffirst_hexo%2F</url>
    <content type="text"><![CDATA[你不能一直做一些烂事，然后自己后悔，好像后悔有用一样，你需要变好 想法 2017给了我很多最最美好的经历，目前对我最重要的年份是这一年,希望能继往开来希望自己能多给自己一些惊喜，少管些闲事，累了就休息，再也不失眠希望自己能跟着大佬学点东西，不要别人一张嘴你就一头雾水、一脸尴尬多看点书，学点东西，然后写一些对自己有用的博文 你要是无聊，它可以让你学不动，给你省了时间和金钱 计算机相关技术资料整理 https://github.com/EZLippi/practical-programming-books 编程书籍的整理和收集 https://github.com/KeKe-Li/book java 的书多一些 https://github.com/huangbaoquan/books 现在没太多时间读书，但可以整理一下，大家有好的链接不妨推荐一下放在这个博客中，方便以后有时间阅读寄语（鸡汤）没有不可治愈的伤痛，没有不能结束的沉沦，所有失去的，都会以另一种方式归来人生亦如逆旅，一切美好与温暖沉默如影，静立你的身后，不会迎头遇见，只要你不断走向远方，它便一路相随]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+nexT中的其他内容]]></title>
    <url>%2F2018%2F08%2Fhexo%2BnexT%2Bsomething%2F</url>
    <content type="text"><![CDATA[建议直接看最根本的东西 限于本人英语水平有限，建议大家直接到github上阅读相应的仓库获取最新知识，这样能避免很多错误，也不会被网上很多已经过时的东西影响。本人的版本： Theme versionversion: 5.1.4 hexo 版本 东拼西凑的东西每次输入都需要重新输入github帐号和密码？参考设置 SSH 使用 hexo deploy 时免输用户名密码设置好的状态： 版权声明之前的版本声明我觉得有点丑，除了有最新更新时间没有别的好处，而且那些声明明显落后于现在版本更新的速度，建议使用新版本里面的简洁声明 打开主题配置文件找到post_copyright1234post_copyright: enable: true #将false改成true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 设置gitment评论系统尝试过valine评论，但是决定作为程序员还是使用gitment比较好 最新版里面不需要添加配置文件只需要有app即可操作如下： 注册OAuth Application点击https://github.com/settings/applications/new注册参数说明：1234Application name： #应用名称Homepage URL： #网站URLApplication description #描述Authorization callback URL：#网站URL 修改themes/next/_config.yml在其中添加：12345678910111213141516# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: 不添加则跟随默认语言# Force language, or auto switch by theme跟随默认语言 github_user: Github名 # MUST HAVE, Your Github ID github_repo: .github.io的仓库 # MUST HAVE, The repo you use to store Gitment comments client_id: App id # MUST HAVE, Github client id for the Gitment client_secret: App secret # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 链接消除汉语在文章量不是很大的情况下建议直接设置链接的英文名，网上有相关教程我采用了转换，但是出了些小bug，但还能应付的过来 关于用自己的页面做页面请参考jacklightChenHexo-用自己的页面做首页 主题内添加相册功能（可能会出现卡顿）请参考asdfv1929Hexo NexT主题内添加相册功能 添加网页标题崩溃欺骗搞怪特效请参考asdfv1929Hexo NexT主题中添加网页标题崩溃欺骗搞怪特效 添加加载效果打开主题配置文件搜索pace_theme看到下面这些效果，有很多种，挑选一个自己喜欢的就好了12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-loading-bar 最后 鉴于很多大佬都有相应的分享我就老老实实做一个搬运工，希望有更多人能有一个自己满意的博客网上有更多好的效果和实现方式欢迎与我交流 —-&gt;传送门]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github+ubuntu搭建个人博客]]></title>
    <url>%2F2018%2F08%2Fhexo%2Bhithub_pages%2BnexT%2F</url>
    <content type="text"><![CDATA[菜鸟初步搭建须知（是我没错，备忘）相应知识 会一些基本的Linux命令和vim的操作命令。可以在实验楼上入门学习 网上已经浏览了 官方文档 安装ubuntu和git（因为最近在学习用ubuntu，而且很多操作ubuntu上会更简单） 安装Node.js并拥有github账号 github上新建好一个专门的仓库，并最好熟悉github及其基本操作比如SSH密钥 以上知识网上有比较完善的信息，搜索关键字学习并进行必要的搭建前提已经完成下图： 建议大家选择不同的博客建站，可以参考有哪些好看的 Hexo 主题? 新手初步搭建可能有用搭建nexT主题可能有帮助的链接： https://www.cnblogs.com/fengxiongZz/p/7707219.html https://www.jianshu.com/p/a0a27d840992 https://www.jianshu.com/p/24cb74aeb0a3 http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 深入搭建，安装NexT主题Hexo 安装主题的方式非常简单，新建blog文档（命名随意）在其下打开终端操作即可，具体到 NexT 来说，安装步骤如下。 安装主题1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 具体还有以下步骤（自行网上搜索）： hexo init(第一次需要) hexo clean hexo g hexo s hexo d 启动主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件（官方文档中给出站点配置文件解释）， ctrl+f 搜索到 theme 字段，并将其值更改为 next，主题默认为landscape，建议选择Pisces或Gemini 1theme: next 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug，dubug会帮助你更好找到安装过程的错误），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： 1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 改动hexo 站点配置文件我们打开站点下的_config.yml文件 深入站点配置文件，事先变动RSS订阅 1.在hexo的根目录下执行命令： 1npm install hexo-generator-feed --save 2在根目录下的/theme/next/_config.yml文件中添加配置 123456feed: type: rss2 path: rss2.xml limit: 5 hub: content: 'true' 加入站点内容搜索功能 1.安装hexo-generator-searchdb 注意：安装时应在站点根目录下，即blog目录下 1$ npm install hexo-generator-searchdb --save 2.添加search字段，在站点blog/_config.yml中添加search字段，如下 12345search: path: search.xml field: post format: html limit: 10000 编辑远程部署 ，添加代码块 1234deploy: type: git repository: https://github.com/Thunderforrain/Thunderforrain.github.io.git branch: master 方便写博客，自动生成图片文档 1post_asset_folder: true 如果是flase 改成true 参考文章内添加图片 注意 : : 使用英文的，并且后面要有空格 执行完以上步骤，查找关键字来更改其他信息，最后结果大致如下(仅作最后的参考)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: Thunderforrain's Blog #网站标题subtitle: 实迷途其未远,觉今是而昨非 #网站副标题description: 菜鸟的 尝试，笨鸟的先飞 #网站描述keywords:author: Thunderforrain #博主的名字language: zh-Hans #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址 ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://thunderforrain.github.io/ ** #你网站的urlroot: /blog/ #子目录permalink: :year/:month/:day/:title/ #生成文件名字的格式permalink_defaults:# Directory 目录配置source_dir: source public_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章new_post_name: :title.md # File name of new posts （新建文章链接形式）default_layout: post # 默认布局（官方文档中给出其他布局）titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 render_drafts: false post_asset_folder: true #启动 Asset 文件夹,方便管理文章图片relative_link: false future: true highlight: #代码块设为true enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map: # Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页（非全屏不显示）## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page search: path: search.xml field: post format: html limit: 10000# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next## Rss订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有) hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:Tenke007/Tenke007.github.io.git branch: master 改动hexo 主题配置文件建议参考网址，网上有比较好的教程:Never_yu’s Blog主题配置参考知了笔记Elegant theme for Hexo建议看一下我下一篇博客我们打开主题下的_config.yml文件 深入主题配置文件，里面可以添加很多东西（参考上述网址）： 在右上角或者左上角实现fork me on github 背景配置 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改“代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加Gitment评论系统 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 自定义鼠标样式 hexo 添加百度站长推送 hexo NexT主题首页title链接的优化 Hexo NexT主题修改文章标题样式 hexo 添加百度站长推送 参考上文知了笔记的hexo框架基于next主题定制 下文可作为理解帮助（仅作为最后的参考）:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexofavicon: ##网站的头像 small: /images/avatar.jpg medium: /images/avatar.jpg apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)keywords: "记录耕耘"##网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml # 需要安装插件# Specify the date when the site was setupsince: 2015 网站时间，类似 2015-2016 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: #我的是自己设置可否评论，可以使用统一u形式，不同的评论方式不同 # ------------------------------------------------------------- # Hexo link (Powered by Hexo).#管理底部驱动信息，个人去了版本号 powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: false # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remeber set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / categories: /categories #分类 tags: /tags #标签 archives: /archives #归档 #about: /about # 关于我 #sitemap: /sitemap.xml #这个可以不用开启，给搜索引擎用的，需要安装插件 #commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #上面menu的iconmenu_icons: enable: true home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next主题的三个schemes(默认是Muse)#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini #个人比较喜欢Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.#social: #社交链接，可以放github,weibo,qq等 GitHub: https://github.com/Thunderforrain || github CSDN: https://blog.csdn.net/Thunderforrain #微博: #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype social_icons: #对应的社交icon enable: true # Icon Mappings. # KeyMapsToSocalItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter Weibo: weibo Wechat: wechat# Blog rolls #相关链接links_icon: linklinks_title: 友情链接links: git学习: http://github.phodal.com/ 馨客栈: http://www.mackxin.com/ CSL's Blog 的链接: http://cubercsl.cn/links/ jacklightChen's Blog: http://blog.lightina.cn/links_layout: block #Title: http://example.com/# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: /images/avatar.jpg #博主头像（可以放外链）# Table Of Contents in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: #侧边栏，只对Pisces、Gemini有效 # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggler. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).像素菜单条边栏偏移量 offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: false # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: #设置为true,首页文章会显示 阅读全文，建议使用 &lt;!-- more --&gt; enable: true length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Wechat Subscriber #文章内显示微信二维码wechat_subscriber: enabled: true qcode: /images/wechat.png #微信二维码图片路径 description: 随便说点 #微信二维码描述#Reward #打赏功能，图片相应目录有或者外链reward_comment: 捐助菜鸡，提携笨鸟wechatpay: /images/wechatpay.pngalipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png# Declare license on posts # 版权声明post_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Android Chrome header panel color ($black-deep).android_chrome_color: "#222"# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme 代码高丽风格，个人喜欢默认版本# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font: enable: false # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Lato size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: # ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML# Swiftype Search API Key #第三方搜索（根据喜好选择，不举例了）#swiftype_key:# Baidu Analytics ID #百度分析#baidu_analytics:# Duoshuo ShortName #多说评论，已成为过去，不可使用duoshuo_shortname: tenke# Disqus #来必力评论#disqus_shortname:# changyan #畅言评论changyan: enable: false appid: appkey: # Hypercomments#hypercomments_id:# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: #下面有东西，暂不举例，涉及隐私 # Gitment #需要github账号才能留言# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled:# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.#jiathis: ##uid: Get this uid from http://www.jiathis.com/#add_this_id:# Share #废弃duoshuo_share: true# NeedMoreShare2# This plugin is a pure javascript sharing lib which is useful in China.# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,# Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,# Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,# Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2: enable: false postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: #弃用 ua_enable: true admin_enable: true user_id: admin_nickname: # Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: #facebook相关 enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true # Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# --------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: #第三方用户访问插件，直接开启，根据喜好添加文字 # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp阅读数 page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"# Local search #自己添加# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url "title" %&#125;# Alias: &#123;% extlink text url "title" %&#125;exturl: false# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: false labels: true border_radius: 0 #! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancyboxfancybox: true# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-center-simple# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # needMoreShare2 # https://github.com/revir/need-more-share2 needMoreShare2:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.4# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 最后一些想法1.科学上网（你懂的） 2.逐步升级博客（一次性弄好不现实） 3.先理解站点和主题配置文件（有些东西随着版本的更新，没有必要进行很麻烦的操作） 4.还有一部分东西可以自己查,希望对大家有所帮助 欢迎互加友情链接 ，互相交流—–&gt;传送门 一些博客实例： IIssNan’s NotesKevin Pu’s Blog Showo^^e吴小龙同學]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
