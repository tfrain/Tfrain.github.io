---
title: 算法相关知识简介
date: '2019-02-04 21:25:54 +0800'
tags: []
categories: leetcode
abbrlink: 20635
---
<blockquote class="blockquote-center">**据说维基的知识总结很优秀**</blockquote><br /><!-- more -->

## 前言
若hexo有小bug或不舒服之处，请移步到[语雀](https://www.yuque.com/tfrain/boke/wikipedia_algorithm)浏览<br />因为自己的算法基础非常薄弱，希望通过兔派刷题的方式，怀着幸存者的意识，能够迎头赶上。
## 数组(Array)
在计算机科学中，**数组数据结构**（英语：array data structure），简称**数组**（英语：Array），是由相同类型的元素（element）的集合所组成的[数据结构](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。<br />最简单的数据结构类型是**一维数组**。例如，索引为0到9的32位整数数组，可作为在存储器地址2000，2004，2008，...2036中，存储10个变量，因此索引为i的元素即在存储器中的2000+4×i地址。数组第一个元素的存储器地址称为第一地址或基础地址。<br />**二维数组**，对应于数学上的[矩阵](https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%99%A3)概念，可表示为二维矩形格。例如：![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549288867661-a83c2c4e-808d-42eb-b39b-22e7de8e5ed5.svg)在[C语言](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80)中表示为{% raw %}int a[3][3] = {{3, 6, 2}, {0, 1, -4}, {2, -1, 0}};{% endraw %}。<br />在某些情况下，“[向量](https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F)”一词也可能代表二维数组，虽然在数学意义上更确切地称呼为[元组](https://zh.wikipedia.org/wiki/%E5%85%83%E7%BB%84)（tuple），而不是向量。但需要注意的是：计算机科学的某些领域，如Matlab，元组是指类似C语言struct类型，具有固定的往往是不同类型的数据成员的数据结构。<br />数组通常用于实现[数据库](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93)的表格，特别是查询表；表格有时也被当作是数组的同义词。<br />数组是最早期和最重要的数据结构之一，很多程序都会用到数组。它们也用于实现许多其他数据结构，譬如列表（list）和[字符串](https://zh.wikipedia.org/wiki/%E5%AD%97%E4%B8%B2)（string）。它们有成效地开展了计算机的定址逻辑。在大多数现代计算机和许多外部存储设备中，存储器如同一维数组，索引就是其地址。编译器、处理单元（特别是[向量处理器](https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8)），经常会针对数组操作进行优化。<br />因为在程序运行时可以计算元素的索引，数组是很有用的。此外，也能以单一迭代语句就处理数组的许多元素。为此，数组数据结构的元素必须具有相同的大小，而且应该使用相同的[数据类型](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)表示。<br />数组一词通常用于表示数组数据类型，一种大多数高端编程语言都会内置的[数据类型](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)。数组类型通常由数组结构来实现；然而在某些语言中，它们可以由[散列表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)、[链表](https://zh.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97)、[搜索树](https://zh.wikipedia.org/w/index.php?title=%E6%90%9C%E7%B4%A2%E6%A8%B9&action=edit&redlink=1)或其它[数据结构](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B)来实现。<br />在算法的描述中，数组一词特别着重意义为[关系数组](https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84)或“抽象的数组”，一种理论上的计算机科学模型（抽象数据类型或 ADT），专注于数组的基本性质上。
## 哈希表(Hash Table)
**散列表**（**Hash table**，也叫**哈希表**），是根据[键](https://zh.wikipedia.org/wiki/%E9%8D%B5)（Key）而直接访问在内存存储位置的[数据结构](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)。也就是说，它通过计算一个关于键值的函数，将所需查询的数据[映射](https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84)到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做[散列函数](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0)，存放记录的数组称做**散列表**。<br />一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名x到首字母F(x)的一个[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0)关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为[关键字](https://zh.wikipedia.org/wiki/%E9%97%9C%E9%8D%B5%E5%AD%97)，“取首字母”是这个例子中[散列函数](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0)的函数法则F()，存放首字母的表对应[散列表](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E8%A1%A8)。关键字和函数法则理论上可以任意确定。
## 链表(Linked List)
**链表**（Linked list）是一种常见的基础数据结构，是一种[线性表](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8)，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的[指针](https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8))(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的[复杂度](https://zh.wikipedia.org/wiki/%E8%A4%87%E9%9B%9C%E5%BA%A6)，比另一种线性表[顺序表](https://zh.wikipedia.org/wiki/%E9%A1%BA%E5%BA%8F%E8%A1%A8)快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。<br />使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。<br />在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。<br />链表可以在多种编程语言中实现。像[Lisp](https://zh.wikipedia.org/wiki/Lisp)和[Scheme](https://zh.wikipedia.org/wiki/Scheme)这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。
## 数学(Math)

## 双指针(Two Pointers)

## 串(String)
**字符串**（**String**），是由零个或多个[字符](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6)组成的有限序列。一般记为。它是[编程语言](https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80)中表示[文本](https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC)的[数据类型](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)。<br />通常以串的整体作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。两个字符串相等的充要条件是：长度相等，并且各个对应位置上的字符都相等。设p、q是两个串，求q在p中首次出现的位置的运算叫做模式匹配。串的两种最基本的存储方式是顺序存储方式和链接存储方式。
## 二分查找(Binary Search)
在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**二分搜索**（英语：binary search），也称**折半搜索**（英语：half-interval search）、**对数搜索**（英语：logarithmic search），是一种在[有序数组](https://zh.wikipedia.org/wiki/%E6%9C%89%E5%BA%8F%E6%95%B0%E5%AF%B9)中查找某一特定元素的搜索[算法](https://zh.wikipedia.org/wiki/%E6%BC%94%E7%AE%97%E6%B3%95)。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<br />二分搜索在情况下的复杂度是对数时间，进行![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291436329-6143cbca-53e0-4ec8-a4cb-a1540416cf2f.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=64)次比较操作![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291435712-b8b12d5e-9e71-4339-8a7b-243957d03d3c.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=15&originWidth=13&size=0&width=24)在此处是数组的元素数量，![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291435981-1075a6e4-8cca-4daf-a0ac-5066aa045df5.svg#align=left&display=inline&height=30&linkTarget=_blank&originHeight=20&originWidth=16&size=0&width=24)是[大O记号](https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7)，![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291435966-5e179d00-15dd-4d34-a342-c31b303e442f.svg#align=left&display=inline&height=20&linkTarget=_blank&originHeight=23&originWidth=27&size=0&width=24)是[对数](https://zh.wikipedia.org/wiki/%E5%AF%B9%E6%95%B0)）。二分搜索使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分搜索比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如[哈希表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)），二分搜索应用面更广。<br />二分搜索有许多中变种。比如[分散层叠](https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E6%95%A3%E5%B1%82%E5%8F%A0&action=edit&redlink=1)可以提升在多个数组中对同一个数值的搜索。分散层叠有效的解决了[计算几何学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6)和其他领域的许多搜索问题。[指数搜索](https://zh.wikipedia.org/w/index.php?title=Exponential_Search&action=edit&redlink=1)将二分搜索拓宽到无边界的列表。[二分搜索树](https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91&action=edit&redlink=1)和B树数据结构就是基于[二分搜索](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2)的。
## 分治算法(Divide and Conquer)
在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**分治法**是建基于多项分支[递归](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92)的一种很重要的算法[范式](https://zh.wikipedia.org/wiki/%E7%AF%84%E5%BC%8F)。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。<br />这个技巧是很多高效算法的基础，如[排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)（[快速排序](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)、[归并排序](https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)）、[傅立叶变换](https://zh.wikipedia.org/wiki/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2)（[快速傅立叶变换](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2)）。<br />另一方面，理解及设计分治法算法的能力需要一定时间去掌握。正如以归纳法去证明一个[理论](https://zh.wikipedia.org/wiki/%E7%90%86%E8%AB%96)，为了使递归能够推行，很多时候需要用一个较为概括或复杂的问题去取代原有问题。而且并没有一个系统性的方法去适当地概括问题。<br />**分治法**这个名称有时亦会用于将问题简化为只有一个细问题的算法，例如用于在已排序的列中查找其中一项的[折半搜索算法](https://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)（或是在[数值分析](https://zh.wikipedia.org/wiki/%E6%95%B8%E5%80%BC%E5%88%86%E6%9E%90)中类似的[勘根算法](https://zh.wikipedia.org/wiki/%E5%8B%98%E6%A0%B9%E5%AE%9A%E7%90%86)）。这些算法比一般的分治算法更能有效地运行。其中，假如算法使用[尾部递归](https://zh.wikipedia.org/wiki/%E5%B0%BE%E9%83%A8%E9%80%92%E5%BD%92)的话，便能转换成简单的[循环](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%BF%B4%E5%9C%88)。但在这广义之下，所有使用递归或循环的算法均被视作“分治算法”。因此，有些作者考虑“分治法”这个名称应只用于每个有最少两个子问题的算法。而只有一个子问题的曾被建议使用**减治法**这个名称。<br />分治算法通常以[数学归纳法](https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8%E6%AD%B8%E7%B4%8D%E6%B3%95)来验证。而它的计算成本则多数以解[递归关系式](https://zh.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E9%97%9C%E4%BF%82%E5%BC%8F)来判定。    
## 动态规划(Dynamic Programming)
**动态规划**（英语：Dynamic programming，简称DP）是一种在[数学](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6)、[管理科学](https://zh.wikipedia.org/wiki/%E7%AE%A1%E7%90%86%E7%A7%91%E5%AD%A6)、[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)、[经济学](https://zh.wikipedia.org/wiki/%E7%BB%8F%E6%B5%8E%E5%AD%A6)和[生物信息学](https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6)中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br />动态规划常常适用于有重叠子问题和[最优子结构](https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84&action=edit&redlink=1)性质的问题，动态规划方法所耗时间往往远少于朴素解法。<br />动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。<br />通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其[记忆化](https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96)存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈[指数增长](https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B8%E5%A2%9E%E9%95%B7)时特别有用。
## 回溯算法(Backtracking)
**回溯法**（英语：backtracking）是[暴力搜索法](https://zh.wikipedia.org/wiki/%E6%9A%B4%E5%8A%9B%E6%90%9C%E5%B0%8B%E6%B3%95)中的一种。<br />对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。<br />在经典的教科书中，**[八皇后问题](https://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98)**展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）<br />回溯法采用[试错](https://zh.wikipedia.org/wiki/%E8%AF%95%E9%94%99)的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的[递归](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92)方法来实现，在反复重复上述的步骤后可能出现两种情况：
* 找到一个可能存在的正确的答案
* 在尝试了所有可能的分步方法后宣告该问题没有答案

在最坏的情况下，回溯法会导致一次[复杂度](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA)为[指数时间](https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B8%E6%99%82%E9%96%93)的计算。
## 栈(Stack)
**堆栈**（英语：stack）又称为**栈**或**堆叠**，是[计算机科学](https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)中一种特殊的串列形式的[抽象数据类型](https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)，其特殊之处在于只能允许在[链表](https://zh.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97)或[数组](https://zh.wikipedia.org/wiki/%E9%99%A3%E5%88%97)的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外堆栈也可以用一维[数组](https://zh.wikipedia.org/wiki/%E9%99%A3%E5%88%97)或[链表](https://zh.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97)的形式来完成。堆栈的另外一个相对的操作方式称为[队列](https://zh.wikipedia.org/wiki/%E4%BD%87%E5%88%97)。<br />由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。
## 堆(Heap)
**堆**（英语：Heap）是[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中的一种特别的树状[数据结构](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒**小于等于**子节点的值，此堆称为**最小堆**（min heap）；反之，若母节点的值恒**大于等于**子节点的值，此堆称为**最大堆**（max heap）。在堆中最顶端的那一个节点，称作**根节点**（root node），根节点本身没有**母节点**（parent node）。<br />堆始于 [J._W._J._Williams](https://zh.wikipedia.org/w/index.php?title=J._W._J._Williams&action=edit&redlink=1) 在 1964 年发表的**堆排序**（heap sort），当时他提出了二叉堆树作为此算法的数据结构。堆在[戴克斯特拉算法](https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95)（英语：Dijkstra's algorithm）中亦为重要的关键。<br />在[队列](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97)中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。
## 贪心算法(Greedy)
**贪心算法**（英语：greedy algorithm），又称**贪婪算法**，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)。比如在[旅行推销员问题](https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98)中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。<br />贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。<br />贪心算法与[动态规划](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。<br />贪心法可以解决一些[最优化](https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BC%98%E5%8C%96)问题，如：求[图](https://zh.wikipedia.org/wiki/%E5%9B%BE)中的[最小生成树](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)、求[哈夫曼编码](https://zh.wikipedia.org/wiki/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81)……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。
## 排序(Sort)
在[计算机科学](https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)与[数学](https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8)中，一个**排序算法**（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)。最常用到的排序方式是数值顺序以及[字典顺序](https://zh.wikipedia.org/wiki/%E5%AD%97%E5%85%B8%E9%A0%86%E5%BA%8F)。有效的排序算法在一些算法（例如[搜索算法](https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E7%AE%97%E6%B3%95)与[合并算法](https://zh.wikipedia.org/w/index.php?title=%E5%90%88%E4%BD%B5%E7%AE%97%E6%B3%95&action=edit&redlink=1)）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：
  1. 输出结果为递增序列（递增是针对所需的排序顺序而言）
  1. 输出结果是原输入的一种[排列](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%88%97)、或是重组

虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，[冒泡排序](https://zh.wikipedia.org/wiki/%E6%B0%A3%E6%B3%A1%E6%8E%92%E5%BA%8F)在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：[图书馆排序](https://zh.wikipedia.org/wiki/%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%8E%92%E5%BA%8F)在2004年被发表）
## 位运算(Bit Manipulation)
**位操作**是[算法](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Algorithm&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhjMVi1RPGMBteOeVhr7rwyRqB0rpw)操作比[字](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Word_(data_type)&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhjWJGcdyh6D0YqybOhRRrQm_q3weA)短的[位](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Bit&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhjEeYjDXtSE4aLD8IBpxGHOw7i1cw)或其他[数据](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Data_(computing)&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhimJkNnf1ms2G_qzxH5ThHaFXOF3w)的行为。 需要位操作的[计算机编程](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Computer_programming&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhgBTJOhasH5dW1tnoxF67KIfvfLTg)任务包括低级设备控制， [错误检测](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Error_detection&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhgXOngDc_CmFhIvFAdYWlKuRmY5sA)和[纠正](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Error_correction&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhiSkVgbuw44Uuoqt32JwsNGOtuw_g)算法， [数据压缩](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Data_compression&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhgSFcXbh6AiHJgQKcqYVOpo_yxdxA) ， [加密](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Encryption&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhi9MtfS8E3BFR-z1u_riRNQ4gfERA)算法和[优化](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Optimization_(computer_science)&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhh_t9EuZt8FPWcE83nzA7-3KzopLw) 。 对于大多数其他任务，现代[编程语言](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Programming_language&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhj2io6d_vRyulRfmd5Yfg6y-t0jwA)允许[程序员](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Programmer&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhgf_SNoU3vDFByphd_Ho3Qo_cUX0w)直接使用[抽象](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Abstraction_(computer_science)&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhgsc5qtrh0_vT7zGYTWMCKDHxCcOA)而不是代表那些抽象的位。 执行位操作的[源代码](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Source_code&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhj24xoEiLJDqG9xWG1lAWhEg3m9kw)使用[按位运算](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Bitwise_operation&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhixv-Y0how8ovsYIKadV3hDvxPp_g) ：AND，OR，XOR，NOT和[位移](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Bitwise_operation&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhixv-Y0how8ovsYIKadV3hDvxPp_g#Bit_shifts) 。<br />在某些情况下，位操作可以消除或减少循环数据结构的需要，并且可以提供多倍的加速，因为并行处理位操作，但代码可能变得更难以编写和维护。
## 树(Tree)
在计算机科学中，**树**（英语：tree）是一种[抽象数据类型](https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)（ADT）或是实现这种抽象数据类型的[数据结构](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B)，用来模拟具[有树状结构](https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B)性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的[集合](https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88)。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：
* 每个节点有零个或多个子节点；
* 没有父节点的节点称为根节点；
* 每一个非根节点有且只有一个父节点；
* 除了根节点外，每个子节点可以分为多个不相交的子树；
* 树里面没有环路(cycle)
## 深度优先搜索(Depth-first Search)
**深度优先搜索算法**（英语：Depth-First-Search，DFS）是一种用于遍历或搜索[树](https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84))或[图](https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6))的[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。<br />深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应[拓扑](https://zh.wikipedia.org/wiki/%E6%8B%93%E6%89%91)排序表，利用拓扑排序表可以方便的解决很多相关的[图论](https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA)问题，如最大路径问题等等。<br />因发明“深度优先搜索算法”，[约翰·霍普克洛夫特](https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E9%9C%8D%E6%99%AE%E5%85%8B%E6%B4%9B%E5%A4%AB%E7%89%B9)与[罗伯特·塔扬](https://zh.wikipedia.org/wiki/%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7%E5%A1%94%E6%89%AC)在[1986年](https://zh.wikipedia.org/wiki/1986%E5%B9%B4)共同获得计算机领域的最高奖：[图灵奖](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96)。
## [广度优先搜索(Breadth-first Search)](https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)
**广度优先搜索算法**（英语：Breadth-First-Search，缩写为BFS），又译作**宽度优先搜索**，或**横向优先搜索**，是一种[图形搜索算法](https://zh.wikipedia.org/w/index.php?title=%E5%9C%96%E5%BD%A2%E6%90%9C%E7%B4%A2%E6%BC%94%E7%AE%97%E6%B3%95&action=edit&redlink=1)。简单的说，BFS是从[根节点](https://zh.wikipedia.org/w/index.php?title=%E6%A0%B9%E7%AF%80%E9%BB%9E&action=edit&redlink=1)开始，沿着树的宽度遍历树的[节点](https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9)。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。
## [并查集(Union Find)](https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86)
在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**并查集**是一种树型的[数据结构](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，用于处理一些[不交集](https://zh.wikipedia.org/wiki/%E4%B8%8D%E4%BA%A4%E9%9B%86)（Disjoint Sets）的合并及查询问题。有一个**联合-查找算法**（**union-find algorithm**）定义了两个用于此数据结构的操作：
* Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。
* Union：将两个子集合并成同一个集合。

由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于创建单元素集合。有了这些方法，许多经典的[划分问题](https://zh.wikipedia.org/w/index.php?title=%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98&action=edit&redlink=1)可以被解决。<br />为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。
## 图(Graph)

## 设计(Design)

## [拓扑排序(Topological Sort)](https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)
在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)领域，有向图的拓扑排序是其顶点的线性排序，使得对于从顶点![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354123-46ab159b-38a0-46e3-a690-34e6b7709fdf.svg#align=left&display=inline&height=30&linkTarget=_blank&originHeight=15&originWidth=12&size=0&width=24)到顶点![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354252-13693c10-18ce-497c-b9d7-779c170f2a8d.svg#align=left&display=inline&height=36&linkTarget=_blank&originHeight=15&originWidth=10&size=0&width=24)的每个有向边![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354371-3ec1d5f3-0550-4402-9b94-1b4b8f3f0600.svg#align=left&display=inline&height=33&linkTarget=_blank&originHeight=15&originWidth=22&size=0&width=48)，![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374355325-b27802fb-985e-4392-a5f1-8d6579ef3e54.svg#align=left&display=inline&height=30&linkTarget=_blank&originHeight=15&originWidth=12&size=0&width=24)在排序中都在![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354366-9481a9bd-90a4-404d-91c0-f7dade18d1bf.svg#align=left&display=inline&height=36&linkTarget=_blank&originHeight=15&originWidth=10&size=0&width=24)之前。 例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束; 在这个应用中，拓扑排序只是一个有效的任务顺序。 如果且仅当图形没有定向循环，即如果它是[有向无环图](https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE)（[DAG](https://zh.wikipedia.org/wiki/DAG)），则拓扑排序是可能的。 任何 DAG 具有至少一个拓扑排序，并且已知这些算法用于在线性时间内构建任何 DAG 的拓扑排序。<br />在[图论](https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA)中，由一个[有向无环图](https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE)的顶点组成的序列，当且仅当满足下列条件时，称为该[图](https://zh.wikipedia.org/wiki/%E5%9B%BE)的一个**拓扑排序**（英语：Topological sorting）。
1. 每个顶点出现且只出现一次；
1. 若A在序列中排在B的前面，则在图中不存在从B到A的[路径](https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%BE%84_(%E5%9B%BE%E8%AE%BA))。
## [字典树(Trie)](https://zh.wikipedia.org/wik\i/Trie)
在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**trie**，又称**前缀树**或**字典树**，是一种有序[树](https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84))，用于保存[关联数组](https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84)，其中的键通常是[字符串](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2)。与[二叉查找树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的[前缀](https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80)，也就是这个节点对应的字符串，而根节点对应[空字符串](https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2)。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。<br />Trie这个术语来自于re**trie**val。根据[词源学](https://zh.wikipedia.org/wiki/%E8%AF%8D%E6%BA%90%E5%AD%A6)，trie的发明者Edward Fredkin把它读作[/ˈtriː/](https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99) "tree"。但是，其他作者把它读作[/ˈtraɪ/](https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99) "try"。<br />在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie可以看作是一个[确定有限状态自动机](https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA)，尽管边上的符号一般是隐含在分支的顺序中的。<br />键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。<br />trie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，**bitwise trie**中的键是一串比特，可以用于表示整数或者内存地址。
## [树状数组(Binary Indexed Tree)](https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84)
**树状数组**或**二叉索引树**（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374511328-9fe02213-3e39-4b5b-acbe-fb59ee62ea6a.svg#align=left&display=inline&height=24&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=69)的时间得到任意前缀和![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374510664-f61df39c-15ae-4076-a405-b180719a51da.svg#align=left&display=inline&height=33&linkTarget=_blank&originHeight=66&originWidth=199&size=0&width=100)，并同时支持在![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374511010-ea3ea917-e9c1-48cf-ada2-4093faacfddd.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=64)时间内支持动态单点值的修改。空间复杂度![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374511028-2d7e11b6-48e0-4e85-89dd-de13cc5a6a65.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=26&originWidth=45&size=0&width=48)。
## [线段树(Segment Tree)](https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5%E6%A8%B9)
**线段树**（英语：Segment tree）是一种[二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9)形数据结构，1977年由Jon Louis Bentley发明，用以存储[区间](https://zh.wikipedia.org/wiki/%E5%8D%80%E9%96%93)或[线段](https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5)，并且允许快速查询结构内包含某一点的所有区间。<br />一个包含![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552076-e7d1c1d6-98c5-4322-a4f2-bb1bcc5a0d9f.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=15&originWidth=13&size=0&width=24)个区间的线段树，空间复杂度为![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552115-58a0f517-8c4f-42ae-9e70-96c81942fc07.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=26&originWidth=45&size=0&width=48)，查询的时间复杂度则为<br />![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552251-c509b348-c14d-4d64-9b3d-ead957b7bebf.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=111&size=0&width=96)，其中![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552879-3eb804e1-b119-4942-a704-e087c6dffe63.svg#align=left&display=inline&height=44&linkTarget=_blank&originHeight=20&originWidth=11&size=0&width=24) 是匹配条件的区间数量。<br />此数据结构亦可推广到高维度。
## [二叉搜索树(Binary Search Tree)](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9)
**二叉查找树**（英语：Binary Search Tree），也称为**二叉搜索树**、**有序二叉树**（ordered binary tree）或**排序二叉树**（sorted binary tree），是指一棵空树或者具有下列性质的[二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)：
1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
1. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
1. 任意节点的左、右子树也分别为二叉查找树；
1. 没有键值相等的节点。

二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374603713-e7614cde-5606-4f23-83b9-4ff54cf3550c.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=64)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如[集合](https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))、[多重集](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E9%9B%86)、[关联数组](https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84)等。<br />二叉查找树的查找过程和[次优二叉树](https://zh.wikipedia.org/w/index.php?title=%E6%AC%A1%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91&action=edit&redlink=1)类似，通常采取二叉[链表](https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8)作为二叉查找树的[存储结构](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374604022-7033cee1-3f01-406d-ba64-a70801094f38.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=64)，最坏![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374602579-6fa796ae-ae43-4472-9023-95d85568de76.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=26&originWidth=45&size=0&width=48)（数列有序，树退化成线性表）。<br />虽然二叉查找树的最坏效率是![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374602655-65e5154d-b982-4944-be46-c8d04d9e0f7f.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=26&originWidth=45&size=0&width=48),但它支持动态查询，且有很多改进版的二叉查找树可以使树高为![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374603172-e378edd1-985b-444d-8847-54100c89d8ee.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=64),如[SBT](https://zh.wikipedia.org/w/index.php?title=SBT&action=edit&redlink=1),[AVL树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)，[红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)等。故不失为一种好的动态查找方法。
## [递归(Recursion)](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92)
**递归**（英语：Recursion），又译为**递回**，在[数学](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6)与[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，是指在[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0)的定义中使用函数自身的方法。递归一词还较常用于描述以[自相似](https://zh.wikipedia.org/wiki/%E8%87%AA%E7%9B%B8%E4%BC%BC)方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。
## 脑筋急转弯(Brainteaser)

## 记忆化(Memoization)
在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**记忆化**（英语：memoization而非memorization）是一种提高程序运行速度的优化技术。通过储存大计算量[函数](https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F)的返回值，当这个结果再次被需要时将其从[缓存](https://zh.wikipedia.org/wiki/%E7%BC%93%E5%AD%98)提取，而不用再次计算来节省计算时间。 <br />记忆化是一种典型的时间存储平衡方案。
## [队列(Queue)](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97)
**队列**，又称为**伫列**（queue），是[先进先出](https://zh.wikipedia.org/wiki/%E5%85%88%E9%80%B2%E5%85%88%E5%87%BA)（FIFO, First-In-First-Out）的[线性表](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8)。在具体应用中通常用[链表](https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8)或者[数组](https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84)来实现。队列只允许在后端（称为_rear_）进行插入操作，在前端（称为_front_）进行删除操作。<br />队列的操作方式和[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)类似，唯一的区别在于队列只允许新数据在后端进行添加。
## [极小化极大(Minimax)](https://zh.wikipedia.org/wiki/%E6%9E%81%E5%B0%8F%E5%8C%96%E6%9E%81%E5%A4%A7%E7%AE%97%E6%B3%95)
**Minimax算法**（亦称 **MinMax** or **MM**）又名极小化极大算法，是一种找出失败的最大可能性中的最小值的算法。
## 蓄水池抽样(Reservoir Sampinh)

## Map

## 几何(Geometry)

## Rendom

## Rejection Samping

## 参考
以上内容均来自wikipedia

