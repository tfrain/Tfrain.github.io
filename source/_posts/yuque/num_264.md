---
title: 264. Ugly Number II
date: '2019-02-01 11:57:23 +0800'
tags: []
categories: leetcode
abbrlink: 42326
---
![carbon.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548993522023-e08a0595-f805-4d93-9b0f-e3a5a13fa985.png#align=left&display=inline&height=760&linkTarget=_blank&name=carbon.png&originHeight=1166&originWidth=1144&size=175876&width=746)

<!-- more -->
## 题目描述
Write a program to find the `n`-th ugly number.<br />Ugly numbers are** positive numbers** whose prime factors only include `2, 3, 5`. <br />**Example:**
**Input:** n = 10
**Output:** 12
**Explanation: **```
1, 2, 3, 4, 5, 6, 8, 9, 10, 12
```
 is the sequence of the first ```
10
```
 ugly numbers.**Note: ** 
1. `1` is typically treated as an ugly number.
1. `n` **does not exceed 1690**.
## 参考代码

```java
class Solution {
    public int nthUglyNumber(int n) {
        int factors[] = {2,3,5};
        //优先队列
        Queue<Long> queue = new PriorityQueue<>();
        queue.offer(1L);
        注意第1690个可能会超过int的范围
        while (true) {
            long min = queue.poll();//每次取最小值相乘，取得第n个数
            if (n == 1) {
                return (int)min;
            }
            for (int i = 0; i < 3; i++) {
                long ugly = factors[i] * min;
                if(!queue.contains(ugly)) {//去重
                    queue.offer(ugly);
                }
            }
            n--;
        }
    }
}
```

## 思路及总结
利用优先队列进行排序，然后将2、3、5中最小值作为下次相乘的因子，确保没有重复的数字，queue.poll()取得的是即是第 1\2\3\4\5。。。 个数,当n = 1 时，min即是第n个数.
## 参考
[https://chuansongme.com/n/1648591652025](https://chuansongme.com/n/1648591652025)

