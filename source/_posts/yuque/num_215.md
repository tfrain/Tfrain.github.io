---
title: 215. 数组中的第K个最大元素
date: '2019-01-26 20:27:39 +0800'
tags: []
categories: leetcode
abbrlink: 27418
---
![215.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548506060055-118e8488-7b24-4981-8a99-75880675fde5.png#align=left&display=inline&height=411&linkTarget=_blank&name=215.png&originHeight=806&originWidth=1464&size=153252&width=746)<br /><!-- more -->
## 题目描述
在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br />**示例 1:**
**输入:** ```
[3,2,1,5,6,4] 和
```
 k = 2
**输出:** 5**示例 2:**
**输入:** ```
[3,2,3,1,2,4,5,5,6] 和
```
 k = 4
**输出:** 4**说明:**<br />你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
## 参考代码

```java
class Solution {
   public static int findKthLargest(int[] nums, int k) {
		PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();
       for(int num :nums) {
           priorityQueue.add(num);
           if(priorityQueue.size() > k) {
               priorityQueue.poll();
           }
       }
       return priorityQueue.peek();
   }
}
```

## 思路及总结
主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。
## 参考
[https://www.kancloud.cn/maliming/leetcode/844880](https://www.kancloud.cn/maliming/leetcode/844880)

