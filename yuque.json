[
  {
    "id": 1231020,
    "slug": "num_4",
    "title": "4. Median of Two Sorted Arrays",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-15T15:29:26.933Z",
      "updated_at": "2019-02-15T15:29:26.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n![2..png](https://cdn.nlark.com/yuque/0/2019/png/203310/1549985856512-cc0b2a9d-65c8-4bcf-8e58-8056ef01fcb1.png#align=left&display=inline&height=835&linkTarget=_blank&name=2..png&originHeight=835&originWidth=724&size=131928&width=724)<br /><!-- more -->\n## 题目描述\nThere are two sorted arrays **nums1** and **nums2** of size m and n respectively.<br />Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).<br />You may assume **nums1** and **nums2** cannot be both empty.<br />**Example 1:**<br />nums1 = [1, 3]<br />nums2 = [2]\n\nThe median is 2.0<br />**Example 2:**<br />nums1 = [1, 2]<br />nums2 = [3, 4]\n\nThe median is (2 + 3)/2 = 2.5\n## 参考代码\n\n```java\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int m = nums1.length;\n        int n = nums2.length;\n        if (m > n) {\n            int[] tmp = nums1; nums1 = nums2; nums2 = tmp;\n            int temp = m; m = n; n = temp;\n        }\n        int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2;\n        while (iMin <= iMax) {\n            int i = (iMin + iMax) / 2;\n            int j = halfLen - i;\n            if (i < iMax && nums2[j-1] > nums1[i]) {\n                iMin = i + 1;\n            }\n            else if (i > iMin && nums1[i-1] > nums2[j]) {\n                iMax = i - 1;\n            }\n            else {\n                int maxLeft = 0;\n                if (i == 0) { maxLeft = nums2[j-1];}\n                else if (j == 0) {maxLeft = nums1[i-1];}\n                else { maxLeft = Math.max(nums1[i-1], nums2[j-1]); }\n                if ( (m + n) % 2 == 1) { return maxLeft; }\n                \n                int minRight = 0;\n                if (i == m) { minRight = nums2[j]; }\n                else if (j == n) {minRight = nums1[i]; }\n                else { minRight = Math.min(nums2[j], nums1[i]); }\n                \n                return (maxLeft + minRight) / 2.0;\n            }\n        }\n        return 0.0;\n    }\n}\n```\n\n## 思路及总结\n当找到目标对象 i_i_时，中位数为：<br />![](https://cdn.nlark.com/yuque/__latex/b50574d411c81d6628a7ea75b85359d0.svg#card=math&code=max%28A%5Bi%E2%88%921%5D%2CB%5Bj%E2%88%921%5D%29%2C%20%E5%BD%93%20m%2Bn%20%E4%B8%BA%E5%A5%87%E6%95%B0%E6%97%B6&height=27&width=332)<br />![](https://cdn.nlark.com/yuque/__latex/697e2a057e74f58fce21f9c72b44addf.svg#card=math&code=2%0Amax%28A%5Bi%E2%88%921%5D%2CB%5Bj%E2%88%921%5D%29%2Bmin%28A%5Bi%5D%2CB%5Bj%5D%29%0A%E2%80%8B%09%0A%20%2C%20%E5%BD%93%20m%2Bn%20%E4%B8%BA%E5%81%B6%E6%95%B0%E6%97%B6&height=27&width=486)<br />当为奇数时，left的数字较多，可以举例来理解一下<br />![](https://cdn.nlark.com/yuque/__latex/8aaac2d68b6fe1dc5f27b21886d5b59c.svg#card=math&code=i%20%3D%200%20%5Csim%20m%2C%20j%20%3D%20%5Cfrac%7Bm%20%2B%20n%20%2B%201%7D%7B2%7D%20-%20i&height=41&width=240) 保证奇偶都能满足<br />最后的那个数学证明是看到头都大了，大概是那个道理。还是官方解答，最为致命。时间复杂度为log(m+n),意思就是只能单层循环一次两个数组，有点利用二分法和分治的思想。\n## 参考\n[https://leetcode.com/problems/median-of-two-sorted-arrays/solution/](https://leetcode.com/problems/median-of-two-sorted-arrays/solution/)\n",
    "body_draft": "categories: leetcode\n\n---\n![215.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548506060055-118e8488-7b24-4981-8a99-75880675fde5.png#align=left&display=inline&height=411&linkTarget=_blank&name=215.png&originHeight=806&originWidth=1464&size=153252&width=746)<br /><!-- more -->\n## 题目描述\n在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br />**示例 1:**\n**输入:** ```\n[3,2,1,5,6,4] 和\n```\n k = 2\n**输出:** 5**示例 2:**\n**输入:** ```\n[3,2,3,1,2,4,5,5,6] 和\n```\n k = 4\n**输出:** 4**说明:**<br />你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n## 参考代码\n\n```java\nclass Solution {\n   public static int findKthLargest(int[] nums, int k) {\n\t\tPriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n       for(int num :nums) {\n           priorityQueue.add(num);\n           if(priorityQueue.size() > k) {\n               priorityQueue.poll();\n           }\n       }\n       return priorityQueue.peek();\n   }\n}\n```\n\n## 思路及总结\n主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。\n## 参考\n[https://www.kancloud.cn/maliming/leetcode/844880](https://www.kancloud.cn/maliming/leetcode/844880)\n",
    "body_html": "<p>categories: leetcode</p><p><br /></p><hr /><p><img alt=\"2..png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1549985856512-cc0b2a9d-65c8-4bcf-8e58-8056ef01fcb1.png#align=left&amp;display=inline&amp;height=835&amp;linkTarget=_blank&amp;name=2..png&amp;originHeight=835&amp;originWidth=724&amp;size=131928&amp;width=724\" style=\"max-width: 600px; width: 724px;\" /></p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p><p><strong>Example 1:</strong></p><p>nums1 = [1, 3]</p><p>nums2 = [2]</p><p><br /></p><p>The median is 2.0</p><p><strong>Example 2:</strong></p><p>nums1 = [1, 2]</p><p>nums2 = [3, 4]</p><p><br /></p><p>The median is (2 + 3)/2 = 2.5</p><h2 id=\"36967e2c\">参考代码</h2><p><br /></p><pre data-lang=\"java\"><code>class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int m = nums1.length;\n        int n = nums2.length;\n        if (m &gt; n) {\n            int[] tmp = nums1; nums1 = nums2; nums2 = tmp;\n            int temp = m; m = n; n = temp;\n        }\n        int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2;\n        while (iMin &lt;= iMax) {\n            int i = (iMin + iMax) / 2;\n            int j = halfLen - i;\n            if (i &lt; iMax &amp;&amp; nums2[j-1] &gt; nums1[i]) {\n                iMin = i + 1;\n            }\n            else if (i &gt; iMin &amp;&amp; nums1[i-1] &gt; nums2[j]) {\n                iMax = i - 1;\n            }\n            else {\n                int maxLeft = 0;\n                if (i == 0) { maxLeft = nums2[j-1];}\n                else if (j == 0) {maxLeft = nums1[i-1];}\n                else { maxLeft = Math.max(nums1[i-1], nums2[j-1]); }\n                if ( (m + n) % 2 == 1) { return maxLeft; }\n                \n                int minRight = 0;\n                if (i == m) { minRight = nums2[j]; }\n                else if (j == n) {minRight = nums1[i]; }\n                else { minRight = Math.min(nums2[j], nums1[i]); }\n                \n                return (maxLeft + minRight) / 2.0;\n            }\n        }\n        return 0.0;\n    }\n}</code></pre><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p>当找到目标对象 <span>i</span><em>i</em>时，中位数为：</p><p><img src=\"https://cdn.nlark.com/yuque/__latex/b50574d411c81d6628a7ea75b85359d0.svg#card=math&amp;code=max%28A%5Bi%E2%88%921%5D%2CB%5Bj%E2%88%921%5D%29%2C%20%E5%BD%93%20m%2Bn%20%E4%B8%BA%E5%A5%87%E6%95%B0%E6%97%B6&amp;height=27&amp;width=332\" style=\"max-width: 600px; width: 332px;\" /></p><p><img src=\"https://cdn.nlark.com/yuque/__latex/697e2a057e74f58fce21f9c72b44addf.svg#card=math&amp;code=2%0Amax%28A%5Bi%E2%88%921%5D%2CB%5Bj%E2%88%921%5D%29%2Bmin%28A%5Bi%5D%2CB%5Bj%5D%29%0A%E2%80%8B%09%0A%20%2C%20%E5%BD%93%20m%2Bn%20%E4%B8%BA%E5%81%B6%E6%95%B0%E6%97%B6&amp;height=27&amp;width=486\" style=\"max-width: 600px; width: 486px;\" /></p><p style=\"text-indent: 2em;\">当为奇数时，left的数字较多，可以举例来理解一下</p><p><img src=\"https://cdn.nlark.com/yuque/__latex/8aaac2d68b6fe1dc5f27b21886d5b59c.svg#card=math&amp;code=i%20%3D%200%20%5Csim%20m%2C%20j%20%3D%20%5Cfrac%7Bm%20%2B%20n%20%2B%201%7D%7B2%7D%20-%20i&amp;height=41&amp;width=240\" style=\"max-width: 600px; width: 240px;\" /><span> 保证奇偶都能满足</span></p><p>最后的那个数学证明是看到头都大了，大概是那个道理。还是官方解答，最为致命。时间复杂度为log(m+n),意思就是只能单层循环一次两个数组，有点利用二分法和分治的思想。</p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://leetcode.com/problems/median-of-two-sorted-arrays/solution/\" target=\"_blank\">https://leetcode.com/problems/median-of-two-sorted-arrays/solution/</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-13T13:54:52.000Z",
    "deleted_at": null,
    "created_at": "2019-02-10T10:09:45.000Z",
    "updated_at": "2019-02-13T13:54:52.000Z",
    "published_at": "2019-02-13T13:54:52.000Z",
    "first_published_at": "2019-02-10T10:10:14.000Z",
    "word_count": 410,
    "cover": null,
    "description": "categories: leetcode&lt;!-- more --&gt;题目描述There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sort...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1230171,
    "slug": "num_2",
    "title": "2. Add Two Numbers",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 22,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-03-13T15:18:22.536Z",
      "updated_at": "2019-03-13T15:18:22.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 4,
        "public_books_count": 1,
        "followers_count": 4,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-03-12T12:23:21.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 4,
      "public_books_count": 1,
      "followers_count": 4,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-03-12T12:23:21.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n![2.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1549785197064-d8534b88-345b-42a3-b91c-2e016c8e60a6.png#align=left&display=inline&height=1034&name=2.png&originHeight=1034&originWidth=665&size=108078&status=done&width=665)<br /><!-- more -->\n<a name=\"273a27cc\"></a>\n## 题目描述\nYou are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br />You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br />**Example:**\n**Input:** (2 -> 4 -> 3) + (5 -> 6 -> 4)\n**Output:** 7 -> 0 -> 8\n**Explanation:** 342 + 465 = 807.<a name=\"36967e2c\"></a>\n## 参考代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        if(l1 == null) {\n            l1 = new ListNode(0);\n        }\n        if(l2 == null) {\n            l2 = new ListNode(0);\n        }\n        \n        if(l1.next == null && l2.next == null) {//基准情况\n            int val = l1.val + l2.val;\n            if(val > 9) {\n                ListNode node = new ListNode(val%10);\n                node.next = new ListNode(1);//最大的数字也只能是19\n                return node;\n            }\n            else {\n                return new ListNode(val);\n            }\n        }\n        else {\n            int val = l1.val + l2.val;\n            if(val > 9) {\n                val -= 10;\n                if(l1.next != null) {//将进位赋值其一\n                    l1.next.val++;\n                }\n                else if(l2.next != null) {\n                    l2.next.val++;\n                }\n            }\n            ListNode node = new ListNode(val);\n            node.next = addTwoNumbers(l1.next,l2.next);\n            //最终返回的结果\n            return node;\n         }\n    }\n}\n```\n\n<a name=\"d7d37168\"></a>\n## 思路及总结\n涉及到链表和递归，感觉自己的基础实在是太差了，基础的算法思想都不会使用，还有就是自己的java基础也很薄弱，经常不知道如何来调用一些常用函数，结合自身情况，尽早提升吧。<br />本题主要要考虑到进位的安排，使用了递归，递归问题一般都能转换为循环问题，如[https://www.programcreek.com/2012/12/add-two-numbers/](https://www.programcreek.com/2012/12/add-two-numbers/)，复杂度为O(n)，进位只会进1。\n<a name=\"d17a0f0b\"></a>\n## 参考\n[https://blog.csdn.net/yanyumin52/article/details/79811375](https://blog.csdn.net/yanyumin52/article/details/79811375)<br />[https://blog.csdn.net/w496272885/article/details/80212426](https://blog.csdn.net/w496272885/article/details/80212426)\n",
    "body_draft": "categories: leetcode\n\n---\n![215.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548506060055-118e8488-7b24-4981-8a99-75880675fde5.png#align=left&display=inline&height=411&linkTarget=_blank&name=215.png&originHeight=806&originWidth=1464&size=153252&width=746)<br /><!-- more -->\n## 题目描述\n在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br />**示例 1:**\n**输入:** ```\n[3,2,1,5,6,4] 和\n```\n k = 2\n**输出:** 5**示例 2:**\n**输入:** ```\n[3,2,3,1,2,4,5,5,6] 和\n```\n k = 4\n**输出:** 4**说明:**<br />你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n## 参考代码\n\n```java\nclass Solution {\n   public static int findKthLargest(int[] nums, int k) {\n\t\tPriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n       for(int num :nums) {\n           priorityQueue.add(num);\n           if(priorityQueue.size() > k) {\n               priorityQueue.poll();\n           }\n       }\n       return priorityQueue.peek();\n   }\n}\n```\n\n## 思路及总结\n主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。\n## 参考\n[https://www.kancloud.cn/maliming/leetcode/844880](https://www.kancloud.cn/maliming/leetcode/844880)\n",
    "body_html": "<p>categories: leetcode</p><p><br /></p><hr /><p><img alt=\"2.png\" title=\"2.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1549785197064-d8534b88-345b-42a3-b91c-2e016c8e60a6.png#align=left&amp;display=inline&amp;height=1034&amp;name=2.png&amp;originHeight=1034&amp;originWidth=665&amp;size=108078&amp;status=done&amp;width=665\" style=\"max-width: 600px; width: 665px;\" /></p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><pre><strong>Input:</strong> (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n<strong>Output:</strong> 7 -&gt; 0 -&gt; 8\n<strong>Explanation:</strong> 342 + 465 = 807.</pre><h2 id=\"36967e2c\">参考代码</h2><pre data-lang=\"java\"><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        if(l1 == null) {\n            l1 = new ListNode(0);\n        }\n        if(l2 == null) {\n            l2 = new ListNode(0);\n        }\n        \n        if(l1.next == null &amp;&amp; l2.next == null) {//基准情况\n            int val = l1.val + l2.val;\n            if(val &gt; 9) {\n                ListNode node = new ListNode(val%10);\n                node.next = new ListNode(1);//最大的数字也只能是19\n                return node;\n            }\n            else {\n                return new ListNode(val);\n            }\n        }\n        else {\n            int val = l1.val + l2.val;\n            if(val &gt; 9) {\n                val -= 10;\n                if(l1.next != null) {//将进位赋值其一\n                    l1.next.val++;\n                }\n                else if(l2.next != null) {\n                    l2.next.val++;\n                }\n            }\n            ListNode node = new ListNode(val);\n            node.next = addTwoNumbers(l1.next,l2.next);\n            //最终返回的结果\n            return node;\n         }\n    }\n}</code></pre><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p style=\"text-indent: 2em;\">涉及到链表和递归，感觉自己的基础实在是太差了，基础的算法思想都不会使用，还有就是自己的java基础也很薄弱，经常不知道如何来调用一些常用函数，结合自身情况，尽早提升吧。</p><p style=\"text-indent: 2em;\">本题主要要考虑到进位的安排，使用了递归，递归问题一般都能转换为循环问题，如<a href=\"https://www.programcreek.com/2012/12/add-two-numbers/\" target=\"_blank\">https://www.programcreek.com/2012/12/add-two-numbers/</a>，复杂度为O(n)，进位只会进1。</p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://blog.csdn.net/yanyumin52/article/details/79811375\" target=\"_blank\">https://blog.csdn.net/yanyumin52/article/details/79811375</a></p><p><a href=\"https://blog.csdn.net/w496272885/article/details/80212426\" target=\"_blank\">https://blog.csdn.net/w496272885/article/details/80212426</a></p>",
    "body_lake": "<!doctype lake><p>categories: leetcode</p><p><br /></p><card type=\"block\" name=\"hr\"></card><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1549785197064-d8534b88-345b-42a3-b91c-2e016c8e60a6.png%22%2C%22originWidth%22%3A665%2C%22originHeight%22%3A1034%2C%22name%22%3A%222.png%22%2C%22size%22%3A108078%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A665%2C%22height%22%3A1034%7D\"></card></p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><pre><strong>Input:</strong> (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n<strong>Output:</strong> 7 -&gt; 0 -&gt; 8\n<strong>Explanation:</strong> 342 + 465 = 807.</pre><h2 id=\"36967e2c\">参考代码</h2><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22%2F**%5Cn%20*%20Definition%20for%20singly-linked%20list.%5Cn%20*%20public%20class%20ListNode%20%7B%5Cn%20*%20%20%20%20%20int%20val%3B%5Cn%20*%20%20%20%20%20ListNode%20next%3B%5Cn%20*%20%20%20%20%20ListNode(int%20x)%20%7B%20val%20%3D%20x%3B%20%7D%5Cn%20*%20%7D%5Cn%20*%2F%5Cnclass%20Solution%20%7B%5Cn%20%20%20%20public%20ListNode%20addTwoNumbers(ListNode%20l1%2C%20ListNode%20l2)%20%7B%5Cn%20%20%20%20%20%20%20%20if(l1%20%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20l1%20%3D%20new%20ListNode(0)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20if(l2%20%3D%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20l2%20%3D%20new%20ListNode(0)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20if(l1.next%20%3D%3D%20null%20%26%26%20l2.next%20%3D%3D%20null)%20%7B%2F%2F%E5%9F%BA%E5%87%86%E6%83%85%E5%86%B5%5Cn%20%20%20%20%20%20%20%20%20%20%20%20int%20val%20%3D%20l1.val%20%2B%20l2.val%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if(val%20%3E%209)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ListNode%20node%20%3D%20new%20ListNode(val%2510)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20node.next%20%3D%20new%20ListNode(1)%3B%2F%2F%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%9F%E5%8F%AA%E8%83%BD%E6%98%AF19%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20node%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20new%20ListNode(val)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20int%20val%20%3D%20l1.val%20%2B%20l2.val%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if(val%20%3E%209)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20val%20-%3D%2010%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if(l1.next%20!%3D%20null)%20%7B%2F%2F%E5%B0%86%E8%BF%9B%E4%BD%8D%E8%B5%8B%E5%80%BC%E5%85%B6%E4%B8%80%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20l1.next.val%2B%2B%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20else%20if(l2.next%20!%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20l2.next.val%2B%2B%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20ListNode%20node%20%3D%20new%20ListNode(val)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20node.next%20%3D%20addTwoNumbers(l1.next%2Cl2.next)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E6%9C%80%E7%BB%88%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20return%20node%3B%5Cn%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%7D%22%7D\"></card><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p style=\"text-indent: 2em;\">涉及到链表和递归，感觉自己的基础实在是太差了，基础的算法思想都不会使用，还有就是自己的java基础也很薄弱，经常不知道如何来调用一些常用函数，结合自身情况，尽早提升吧。</p><p style=\"text-indent: 2em;\">本题主要要考虑到进位的安排，使用了递归，递归问题一般都能转换为循环问题，如<a href=\"https://www.programcreek.com/2012/12/add-two-numbers/\" target=\"_blank\">https://www.programcreek.com/2012/12/add-two-numbers/</a>，复杂度为O(n)，进位只会进1。</p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://blog.csdn.net/yanyumin52/article/details/79811375\" target=\"_blank\">https://blog.csdn.net/yanyumin52/article/details/79811375<cursor /></a></p><p><a href=\"https://blog.csdn.net/w496272885/article/details/80212426\" target=\"_blank\">https://blog.csdn.net/w496272885/article/details/80212426</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-03-11T02:28:49.000Z",
    "deleted_at": null,
    "created_at": "2019-02-09T08:28:55.000Z",
    "updated_at": "2019-03-11T02:28:49.000Z",
    "published_at": "2019-03-11T02:28:49.000Z",
    "first_published_at": "2019-02-09T08:29:26.000Z",
    "word_count": 412,
    "cover": null,
    "description": "categories: leetcode&lt;!-- more --&gt;题目描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored i...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1229296,
    "slug": "shell_learning1",
    "title": "shell脚本学习",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 19,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-13T01:08:41.500Z",
      "updated_at": "2019-02-13T01:08:41.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Linux\n\n---\n\n<blockquote class=\"blockquote-center\">**shell脚本初步**</blockquote><br /><!-- more -->\n\n## 前言\n寒假在家不如学习一下shell的基本语法，也只能怪我看springboot的视频很容易睡觉，寒假准备为这个寒冬做准备学学springboot，结果老师的安排的东西我现在还没看，springboot也是看了个什么都不会的程度。<br />总而言之，就是在滚蛋的边缘疯狂的试探？shell脚本和Python脚本都有学习的必要，如果往后端方向发展，shell和Python都要涉猎，当然主语言还是Java，shell脚本对自动化部署有很大的帮助，有利于我学习一些Linux知识。\n\n## 语雀上有shell脚本的资料\n链接：[https://www.yuque.com/allenlei/ia7uhw/edyrfz](https://www.yuque.com/allenlei/ia7uhw/edyrfz)\n\n## bilibili视频学习\n链接：[https://www.bilibili.com/video/av17384556](https://www.bilibili.com/video/av17384556)\n\n## 实验楼实战操作\n链接：[https://www.shiyanlou.com/courses/944](https://www.shiyanlou.com/courses/944)<br />文档:  [https://www.shiyanlou.com/courses/944/labs/3558/document](https://www.shiyanlou.com/courses/944/labs/3558/document)\n## Linux温习\n实验楼上同样有相应的基础学习教程<br />[Linux命令实例练习 ](https://www.shiyanlou.com/courses/68)<br />[Linux 基础入门（新版）](https://www.shiyanlou.com/courses/1)\n\n",
    "body_draft": "categories: Linux\n\n---\n\n<blockquote class=\"blockquote-center\">**网络命令**</blockquote><br /><!-- more -->\n>       编译：peida     \n>       链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html\n\n# ifconfig命令\n## 概述\n许多Windows非常熟悉ipconfig命令工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有类似的工具，也就是ifconfig（interfaces config）。通常需要以root身份登录或者使用sudo以便在LInux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息等，还可以修改这些配置\n## 命令格式\nifconfig[网络设备][参数]\n## 命令参数\n\n```\nup 启动指定网络设备/网卡。\ndown 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。\narp 设置指定网卡是否支持ARP协议。\n-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包\n-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包\n-a 显示全部接口信息\n-s 显示摘要信息（类似于 netstat -i）\nadd 给指定网卡配置IPv6地址\ndel 删除指定网卡的IPv6地址\n<硬件地址> 配置网卡最大的传输单元\nmtu<字节数> 设置网卡的最大传输单元 (bytes)\nnetmask<子网掩码> 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。\ntunel 建立隧道\ndstaddr 设定一个远端地址，建立点对点通信\n-broadcast<地址> 为指定网卡设置广播协议\n-pointtopoint<地址> 为网卡设置点对点通讯协议\nmulticast 为网卡设置组播标志\naddress 为网卡设置IPv4地址\ntxqueuelen<长度> 为网卡设置传输列队的长度\n```\n## 常用命令\n实例：显示网络设备信息（激活状态的）<br />命令：ifconfig<br />[root@localhost ~]# ifconfig<br />eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:20  <br />          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0<br />          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br />          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:1000 <br />          RX bytes:596390239 (568.7 MiB)  TX bytes:2886956 (2.7 MiB)<br />lo        Link encap:Local Loopback  <br />          inet addr:127.0.0.1  Mask:255.0.0.0<br />          UP LOOPBACK RUNNING  MTU:16436  Metric:1<br />          RX packets:68 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:0 <br />          RX bytes:2856 (2.7 KiB)  TX bytes:2856 (2.7 KiB)<br />说明：eth0表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址（MAC地址）是 00:50:56:BF:26:20<br />inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.168.120.204，广播地址， Bcast:192.168.120.255，掩码地址Mask:255.255.255.0 <br />lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。<br />第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）<br />第二行：网卡的IP地址、子网、掩码<br />第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节<br />第四、五行：接收、发送数据包情况统计<br />第七行：接收、发送数据字节数统计信息。<br /><br /><br />实例：启动关闭指定网卡<br />命令：<br />ifconfig eth0 up<br />ifconfig eth0 down<br />说明：ifconfig eth0 up 为启动网卡eth0 ；ifconfig eth0 down 为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。\n\n实例：为网卡配置和删除IPv6地址<br />命令：<br />ifconfig eth0 add 33ffe:3240:800:1005::2/64<br />ifconfig eth0 del 33ffe:3240:800:1005::2/64<br />说明：<br />ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0配置IPv6地址；<br />ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0删除IPv6地址；<br />练习的时候，ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。\n\n实例：用ifconfig修改MAC地址<br />命令：ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE<br />[root@localhost ~]# ifconfig eth0 down //关闭网卡<br />[root@localhost ~]# ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE //修改MAC地址<br />[root@localhost ~]# ifconfig eth0 up //启动网卡<br />[root@localhost ~]# ifconfig<br />eth0      Link encap:Ethernet  HWaddr 00:AA:BB:CC:DD:EE  <br />          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0<br />          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br />          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:1000 <br />          RX bytes:596390239 (568.7 MiB)  TX bytes:2886956 (2.7 MiB)<br />lo        Link encap:Local Loopback  <br />          inet addr:127.0.0.1  Mask:255.0.0.0<br />          UP LOOPBACK RUNNING  MTU:16436  Metric:1<br />          RX packets:68 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:0 <br />          RX bytes:2856 (2.7 KiB)  TX bytes:2856 (2.7 KiB)<br />[root@localhost ~]# ifconfig eth0 hw ether 00:50:56:BF:26:20 //关闭网卡并修改MAC地址 <br />[root@localhost ~]# ifconfig eth0 up //启动网卡<br />[root@localhost ~]# ifconfig<br />eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:20  <br />          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0<br />          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br />          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:1000 <br />          RX bytes:596390239 (568.7 MiB)  TX bytes:2886956 (2.7 MiB)<br />lo        Link encap:Local Loopback  <br />          inet addr:127.0.0.1  Mask:255.0.0.0<br />          UP LOOPBACK RUNNING  MTU:16436  Metric:1<br />          RX packets:68 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:0 <br />          RX bytes:2856 (2.7 KiB)  TX bytes:2856 (2.7 KiB) \n\n实例：配置IP地址<br />命令：<br />[root@localhost ~]# ifconfig eth0 192.168.120.56 <br />[root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 <br />[root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255<br />说明：<br />ifconfig eth0 192.168.120.56 <br />给eth0网卡配置IP地：192.168.120.56<br /> ifconfig eth0 192.168.120.56 netmask 255.255.255.0 <br />给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0<br />ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255<br />/给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255<br /><br /><br />实例：启动和关闭ARP协议<br />命令：<br />[root@localhost ~]# ifconfig eth0 arp <br />[root@localhost ~]# ifconfig eth0 -arp<br />说明：<br />ifconfig eth0 arp 开启网卡eth0 的arp协议；<br />ifconfig eth0 -arp 关闭网卡eth0 的arp协议；\n\n实例：设置最大传输单元<br />命令：ifconfig eth0 mtu 1500<br />[root@localhost ~]# ifconfig eth0 mtu 1480<br />[root@localhost ~]# ifconfig<br />eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:1F  <br />          inet addr:192.168.120.203  Bcast:192.168.120.255  Mask:255.255.255.0<br />          UP BROADCAST RUNNING MULTICAST  MTU:1480  Metric:1<br />          RX packets:8712395 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:36631 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:1000 <br />          RX bytes:597062089 (569.4 MiB)  TX bytes:2643973 (2.5 MiB)<br /><br />[root@localhost ~]# ifconfig eth0 mtu 1500[root@localhost ~]# ifconfigeth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:1F  <br />          inet addr:192.168.120.203  Bcast:192.168.120.255  Mask:255.255.255.0<br />          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br />          RX packets:8712548 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:36685 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:1000 <br />          RX bytes:597072333 (569.4 MiB)  TX bytes:2650581 (2.5 MiB)<br />说明：设置能通过的最大数据包大小为1500bytes<br />备注：用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在，要想将上述的配置信息永远的存在电脑里，那就要修改网卡的配置文件了。\n\n---\n\n# route命令\n## 概述\nLinux系统的toute命令用于显示和操作IP路由表（show / manipulate the IP routing table）。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在 Linux 系统中，设置路由通常是为了解决以下问题：该 Linux 系统在一个局域网中，局域网中有一个网关，能够让机器访问 Internet，那么就需要将这台机器的 IP 地址设置为 Linux 机器的默认路由。要注意的是，直接在命令行下执行 route 命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在 / etc/rc.local 中添加 route 命令来保证该路由设置永久有效。\n## 命令格式\nroute [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] \n## 命令功能\nRoute命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络连接口，如eth0。当使用参数时，路由表被修改，如果没有参数，则显示路由表当前内容\n## 命令参数\n\n```\n-c 显示更多信息\n-n 不解析名字\n-v 显示详细的处理信息\n-F 显示发送信息\n-C 显示路由缓存\n-f 清除所有网关入口的路由表。 \n-p 与 add 命令一起使用时使路由具有永久性。\nadd: 添加一条新路由。\ndel: 删除一条路由。\n-net: 目标地址是一个网络。\n-host: 目标地址是一个主机。\nnetmask: 当添加一个网络路由时，需要使用网络掩码。\ngw: 路由数据包通过网关。注意，你指定的网关必须能够达到。\nmetric：设置路由跳数。\nCommand 指定您想运行的命令 (Add/Change/Delete/Print)。 \nDestination 指定该路由的网络目标。 \nmask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。 \nGateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。 \nmetric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表 (与转发的数据包目标地址最匹配) 的多个路由中进行选择时可以使用。 \nif Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。\n```\n## 常用命令\n实例：显示当前路由<br />命令：<br />route<br />route -n<br />[root@localhost ~]# route<br />Kernel IP routing table<br />Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br />192.168.120.0   *               255.255.255.0   U     0      0        0 eth0<br />e192.168.0.0     192.168.120.1   255.255.0.0     UG    0      0        0 eth0<br />10.0.0.0        192.168.120.1   255.0.0.0       UG    0      0        0 eth0<br />default         192.168.120.240 0.0.0.0         UG    0      0        0 eth0<br />[root@localhost ~]# route -n<br />Kernel IP routing table<br />Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br />192.168.120.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0<br />192.168.0.0     192.168.120.1   255.255.0.0     UG    0      0        0 eth0<br />10.0.0.0        192.168.120.1   255.0.0.0       UG    0      0        0 eth0<br />0.0.0.0         192.168.120.240 0.0.0.0         UG    0      0        0 eth0<br />说明：<br />第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;<br />第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240<br />其中Flags为路由标志，标记当前网络节点的状态。<br />Flags标志说明：\n\n```\nU Up表示此路由当前为启动状态\nH Host，表示此网关为一主机\nG Gateway，表示此网关为一路由器a\nR Reinstate Route，使用动态路由重新初始化的路由\nD Dynamically,此路由是动态性地写入a\nM Modified，此路由是由路由守护程序或导向器动态修改\n! 表示此路由当前为关闭状态\n```\n\n备注：route -n (-n 表示不解析名字,列出速度会比route 快)\n\n实例：添加网关/设置网管<br />命令：route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0<br />说明：增加一条 到达 244.0.0.0 的路由\n\n实例：删除路由记录<br />命令：<br />route del -net 224.0.0.0 netmask 240.0.0.0<br />route del -net 224.0.0.0 netmask 240.0.0.0 reject<br />说明：删除224.0.0.0的路由记录\n\n实例 ：删除和添加设置默认网关<br />命令：<br />route del default gw 192.168.120.240<br />route add default gw 192.168.120.240\n# ping命令\n## 概述\nLinux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性，我们经常会说\"ping一下某机器，看是不是开着“、不能打开网页时会说\"”你先ping网关地址192.168.1.1试试“。<br />它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样而我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。<br />linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。\n## 命令格式\nping [参数] [主机名或IP地址]\n## 命令功能\nping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。<br />ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在**程序超时或当接收到 SIGINT 信号时结束**。Host 参数或者是一个有效的主机名或者是因特网地址。\n## 命令参数\n\n```\n-d 使用Socket的SO_DEBUG功能。\n-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。\n-n 只输出数值。\n-q 不显示任何传送封包的信息，只显示最后的结果。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。\n-R 记录路由过程。\n-v 详细显示指令的执行过程。\n<p>-c 数目：在发送指定数目的包后停止。\n-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。\n-I 网络界面：使用指定的网络界面送出数据包。\n-l 前置载入：设置在送出要求信息之前，先行发出的数据包。\n-p 范本样式：设置填满数据包的范本样式。\n-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。\n-t 存活数值：设置存活数值TTL的大小。\n```\n## 常用命令\n实例：ping的通的情况<br />命令：ping 192.168.120.205<br />输出：<br />[root@localhost ~]# ping 192.168.120.205<br />PING 192.168.120.205 (192.168.120.205) 56(84) bytes of data.<br />64 bytes from 192.168.120.205: icmp_seq=1 ttl=64 time=0.720 ms<br />64 bytes from 192.168.120.205: icmp_seq=2 ttl=64 time=0.181 ms<br />64 bytes from 192.168.120.205: icmp_seq=3 ttl=64 time=0.191 ms<br />64 bytes from 192.168.120.205: icmp_seq=4 ttl=64 time=0.188 ms<br />64 bytes from 192.168.120.205: icmp_seq=5 ttl=64 time=0.189 ms<br /><br />--- 192.168.120.205 ping statistics ---<br />5 packets transmitted, 5 received, 0% packet loss, time 4000ms<br />rtt min/avg/max/mdev = 0.181/0.293/0.720/0.214 ms<br />[root@localhost ~]# <br /><br /><br />实例：ping不通的情况<br />命令：ping 192.168.120.202<br />输出：<br />[root@localhost ~]# ping 192.168.120.202<br />PING 192.168.120.202 (192.168.120.202) 56(84) bytes of data.<br />From 192.168.120.204 icmp_seq=1 Destination Host Unreachable<br />From 192.168.120.204 icmp_seq=2 Destination Host Unreachable<br /><br /><br />实例：ping指定次数<br />命令：ping -c 10 192.168.120.206\n\n实例：时间间隔和次数限制的ping<br />命令：ping -c 10 -i 0.5 192.168.120.206\n\n实例：多参数使用<br />命令：ping -i 3 -s 1024 -t 255 192.168.120.206<br />说明：-i 3 发送周期为 3秒 -s 设置发送包的大小为1024 -t 设置TTL值为 255\n# traceroute命令\n## 概述\n通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。<br />在大多数情况下，我们会在linux主机系统下，直接执行命令行：<br />traceroute hostname<br />而在Windows系统下是执行tracert的命令：<br />tracert hostname\n## 命令格式\ntraceroute[参数][主机]\n## 命令功能\ntraceroute命令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。具体参数格式：traceroute [-dFlnrvx][-f<存活数值>][-g<网关>...][-i<网络界面>][-m<存活数值>][-p<通信端口>][-s<来源地址>][-t<服务类型>][-w<超时秒数>][主机名称或IP地址][数据包大小]\n## 命令参数\n\n```\n-d 使用Socket层级的排错功能。\n-f 设置第一个检测数据包的存活数值TTL的大小。\n-F 设置勿离断位。\n-g 设置来源路由网关，最多可设置8个。\n-i 使用指定的网络界面送出数据包。\n-I 使用ICMP回应取代UDP资料信息。\n-m 设置检测数据包的最大存活数值TTL的大小。\n-n 直接使用IP地址而非主机名称。\n-p 设置UDP传输协议的通信端口。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n-s 设置本地主机送出数据包的IP地址。\n-t 设置检测数据包的TOS数值。\n-v 详细显示指令的执行过程。\n-w 设置等待远端主机回报的时间。\n-x 开启或关闭数据包的正确性检验。\n```\n## 常用命令\n实例1：traceroute 用法简单、最常用的用法<br />命令：<br />traceroute www.baidu.com<br />输出：<br />[root@localhost ~]# traceroute www.baidu.com<br />traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br /> 1  192.168.74.2 (192.168.74.2)  2.606 ms  2.771 ms  2.950 ms<br /> 2  211.151.56.57 (211.151.56.57)  0.596 ms  0.598 ms  0.591 ms<br /> 3  211.151.227.206 (211.151.227.206)  0.546 ms  0.544 ms  0.538 ms<br /> 4  210.77.139.145 (210.77.139.145)  0.710 ms  0.748 ms  0.801 ms<br /> 5  202.106.42.101 (202.106.42.101)  6.759 ms  6.945 ms  7.107 ms<br /> 6  61.148.154.97 (61.148.154.97)  718.908 ms * bt-228-025.bta.net.cn (202.106.228.25)  5.177 ms<br /> 7  124.65.58.213 (124.65.58.213)  4.343 ms  4.336 ms  4.367 ms<br /> 8  202.106.35.190 (202.106.35.190)  1.795 ms 61.148.156.138 (61.148.156.138)  1.899 ms  1.951 ms<br /> 9  * * *<br />30  * * *<br />[root@localhost ~]# <br />说明：<br />记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。<br />有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。<br />有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。<br />如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。\n## Traceroute的工作原理\nTraceroute最简单的基本用法是：traceroute hostname<br />Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器...... traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？<br />Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。<br />Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。\n# scp命令\n## 概述\nscp命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp知识在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读read only system时，用scp可以帮你把文件移出来。另外scp还非常不占资源，不会提高多少系统负荷，在这一点上rsync就远远不及它了。虽然rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。\n## 命令格式\nscp [参数] [原路径] [目标路径]\n## 命令功能\nscp是secure copy的缩写，scp是Linux系统基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在Linux服务器之间复制文件和目录。\n## 命令参数\n\n```\n-1  强制scp命令使用协议ssh1  \n-2  强制scp命令使用协议ssh2  \n-4  强制scp命令只使用IPv4寻址  \n-6  强制scp命令只使用IPv6寻址  \n-B  使用批处理模式（传输过程中不询问传输口令或短语）  \n-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  \n-p 保留原文件的修改时间，访问时间和访问权限。  \n-q  不显示传输进度条。  \n-r  递归复制整个目录。  \n-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。   \n-c cipher  以cipher将数据传输进行加密，这个选项将直接传递给ssh。   \n-F ssh_config  指定一个替代的ssh配置文件，此参数直接传递给ssh。  \n-i identity_file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。    \n-l limit  限定用户所能使用的带宽，以Kbit/s为单位。     \n-o ssh_option  如果习惯于使用ssh_config(5)中的参数传递方式，   \n-P port  注意是大写的P, port是指定数据传输用到的端口号   \n-S program  指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n```\n\n## 常用命令\n实例：从远处复制到本地/从本地复制到远处<br />命令：<br />scp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/<br />scp -r /opt/soft/mongodb root@192.168.120.204:/opt/soft/scptest<br />说明：从192.168.120.204机器上的/opt/soft/中下载mongodb 目录到本地的/opt/soft/目录来。\n",
    "body_html": "<p>categories: Linux</p><p><br /></p><hr /><p><br /></p><p>&lt;blockquote class=&quot;blockquote-center&quot;&gt;**shell脚本初步**&lt;/blockquote&gt;</p><p>&lt;!-- more --&gt;</p><p><br /></p><h2 id=\"df368884\">前言</h2><p style=\"text-indent: 2em;\"><span>寒假在家不如学习一下shell的基本语法，也只能怪我看springboot的视频很容易睡觉，寒假准备为这个寒冬做准备学学springboot，结果老师的安排的东西我现在还没看，springboot也是看了个什么都不会的程度。</span></p><p style=\"text-indent: 2em;\"><span>总而言之，就是在滚蛋的边缘疯狂的试探？shell脚本和Python脚本都有学习的必要，如果往后端方向发展，shell和Python都要涉猎，当然主语言还是Java，shell脚本对自动化部署有很大的帮助，有利于我学习一些Linux知识。</span></p><p><span><br /></span></p><h2 id=\"5c41b3a6\">语雀上有shell脚本的资料</h2><p>链接：<a href=\"https://www.yuque.com/allenlei/ia7uhw/edyrfz\" target=\"_blank\">https://www.yuque.com/allenlei/ia7uhw/edyrfz</a></p><p><br /></p><h2 id=\"2fa853c1\">bilibili视频学习</h2><p>链接：<a href=\"https://www.bilibili.com/video/av17384556\" target=\"_blank\">https://www.bilibili.com/video/av17384556</a></p><p><br /></p><h2 id=\"e82e03b8\">实验楼实战操作</h2><p>链接：<a href=\"https://www.shiyanlou.com/courses/944\" target=\"_blank\">https://www.shiyanlou.com/courses/944</a></p><p>文档:  <a href=\"https://www.shiyanlou.com/courses/944/labs/3558/document\" target=\"_blank\">https://www.shiyanlou.com/courses/944/labs/3558/document</a></p><h2 id=\"395a6420\">Linux温习</h2><p>实验楼上同样有相应的基础学习教程</p><p><a href=\"https://www.shiyanlou.com/courses/68\" target=\"_blank\">Linux命令实例练习 </a></p><p><a href=\"https://www.shiyanlou.com/courses/1\" target=\"_blank\">Linux 基础入门（新版）</a></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-12T14:16:54.000Z",
    "deleted_at": null,
    "created_at": "2019-02-07T15:21:13.000Z",
    "updated_at": "2019-02-12T14:16:54.000Z",
    "published_at": "2019-02-12T14:16:54.000Z",
    "first_published_at": "2019-02-07T15:50:49.000Z",
    "word_count": 271,
    "cover": null,
    "description": "categories: Linux&lt;blockquote class=&quot;blockquote-center&quot;&gt;**shell脚本初步**&lt;/blockquote&gt;&lt;!-- more --&gt;前言寒假在家不如学习一下shell的基本语法，也只...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1227713,
    "slug": "wikipedia_algorithm",
    "title": "算法相关知识简介",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 19,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-13T01:08:41.500Z",
      "updated_at": "2019-02-13T01:08:41.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n<blockquote class=\"blockquote-center\">**据说维基的知识总结很优秀**</blockquote><br /><!-- more -->\n\n## 前言\n若hexo有小bug或不舒服之处，请移步到[语雀](https://www.yuque.com/tfrain/boke/wikipedia_algorithm)浏览<br />因为自己的算法基础非常薄弱，希望通过兔派刷题的方式，怀着幸存者的意识，能够迎头赶上。\n## 数组(Array)\n在计算机科学中，**数组数据结构**（英语：array data structure），简称**数组**（英语：Array），是由相同类型的元素（element）的集合所组成的[数据结构](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。<br />最简单的数据结构类型是**一维数组**。例如，索引为0到9的32位整数数组，可作为在存储器地址2000，2004，2008，...2036中，存储10个变量，因此索引为i的元素即在存储器中的2000+4×i地址。数组第一个元素的存储器地址称为第一地址或基础地址。<br />**二维数组**，对应于数学上的[矩阵](https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%99%A3)概念，可表示为二维矩形格。例如：![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549288867661-a83c2c4e-808d-42eb-b39b-22e7de8e5ed5.svg)在[C语言](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80)中表示为{% raw %}int a[3][3] = {{3, 6, 2}, {0, 1, -4}, {2, -1, 0}};{% endraw %}。<br />在某些情况下，“[向量](https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F)”一词也可能代表二维数组，虽然在数学意义上更确切地称呼为[元组](https://zh.wikipedia.org/wiki/%E5%85%83%E7%BB%84)（tuple），而不是向量。但需要注意的是：计算机科学的某些领域，如Matlab，元组是指类似C语言struct类型，具有固定的往往是不同类型的数据成员的数据结构。<br />数组通常用于实现[数据库](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93)的表格，特别是查询表；表格有时也被当作是数组的同义词。<br />数组是最早期和最重要的数据结构之一，很多程序都会用到数组。它们也用于实现许多其他数据结构，譬如列表（list）和[字符串](https://zh.wikipedia.org/wiki/%E5%AD%97%E4%B8%B2)（string）。它们有成效地开展了计算机的定址逻辑。在大多数现代计算机和许多外部存储设备中，存储器如同一维数组，索引就是其地址。编译器、处理单元（特别是[向量处理器](https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8)），经常会针对数组操作进行优化。<br />因为在程序运行时可以计算元素的索引，数组是很有用的。此外，也能以单一迭代语句就处理数组的许多元素。为此，数组数据结构的元素必须具有相同的大小，而且应该使用相同的[数据类型](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)表示。<br />数组一词通常用于表示数组数据类型，一种大多数高端编程语言都会内置的[数据类型](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)。数组类型通常由数组结构来实现；然而在某些语言中，它们可以由[散列表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)、[链表](https://zh.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97)、[搜索树](https://zh.wikipedia.org/w/index.php?title=%E6%90%9C%E7%B4%A2%E6%A8%B9&action=edit&redlink=1)或其它[数据结构](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B)来实现。<br />在算法的描述中，数组一词特别着重意义为[关系数组](https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84)或“抽象的数组”，一种理论上的计算机科学模型（抽象数据类型或 ADT），专注于数组的基本性质上。\n## 哈希表(Hash Table)\n**散列表**（**Hash table**，也叫**哈希表**），是根据[键](https://zh.wikipedia.org/wiki/%E9%8D%B5)（Key）而直接访问在内存存储位置的[数据结构](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)。也就是说，它通过计算一个关于键值的函数，将所需查询的数据[映射](https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84)到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做[散列函数](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0)，存放记录的数组称做**散列表**。<br />一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名x到首字母F(x)的一个[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0)关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为[关键字](https://zh.wikipedia.org/wiki/%E9%97%9C%E9%8D%B5%E5%AD%97)，“取首字母”是这个例子中[散列函数](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0)的函数法则F()，存放首字母的表对应[散列表](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E8%A1%A8)。关键字和函数法则理论上可以任意确定。\n## 链表(Linked List)\n**链表**（Linked list）是一种常见的基础数据结构，是一种[线性表](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8)，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的[指针](https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8))(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的[复杂度](https://zh.wikipedia.org/wiki/%E8%A4%87%E9%9B%9C%E5%BA%A6)，比另一种线性表[顺序表](https://zh.wikipedia.org/wiki/%E9%A1%BA%E5%BA%8F%E8%A1%A8)快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。<br />使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。<br />在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（\"links\"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。<br />链表可以在多种编程语言中实现。像[Lisp](https://zh.wikipedia.org/wiki/Lisp)和[Scheme](https://zh.wikipedia.org/wiki/Scheme)这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。\n## 数学(Math)\n\n## 双指针(Two Pointers)\n\n## 串(String)\n**字符串**（**String**），是由零个或多个[字符](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6)组成的有限序列。一般记为。它是[编程语言](https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80)中表示[文本](https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC)的[数据类型](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)。<br />通常以串的整体作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。两个字符串相等的充要条件是：长度相等，并且各个对应位置上的字符都相等。设p、q是两个串，求q在p中首次出现的位置的运算叫做模式匹配。串的两种最基本的存储方式是顺序存储方式和链接存储方式。\n## 二分查找(Binary Search)\n在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**二分搜索**（英语：binary search），也称**折半搜索**（英语：half-interval search）、**对数搜索**（英语：logarithmic search），是一种在[有序数组](https://zh.wikipedia.org/wiki/%E6%9C%89%E5%BA%8F%E6%95%B0%E5%AF%B9)中查找某一特定元素的搜索[算法](https://zh.wikipedia.org/wiki/%E6%BC%94%E7%AE%97%E6%B3%95)。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<br />二分搜索在情况下的复杂度是对数时间，进行![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291436329-6143cbca-53e0-4ec8-a4cb-a1540416cf2f.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=64)次比较操作![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291435712-b8b12d5e-9e71-4339-8a7b-243957d03d3c.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=15&originWidth=13&size=0&width=24)在此处是数组的元素数量，![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291435981-1075a6e4-8cca-4daf-a0ac-5066aa045df5.svg#align=left&display=inline&height=30&linkTarget=_blank&originHeight=20&originWidth=16&size=0&width=24)是[大O记号](https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7)，![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291435966-5e179d00-15dd-4d34-a342-c31b303e442f.svg#align=left&display=inline&height=20&linkTarget=_blank&originHeight=23&originWidth=27&size=0&width=24)是[对数](https://zh.wikipedia.org/wiki/%E5%AF%B9%E6%95%B0)）。二分搜索使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分搜索比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如[哈希表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)），二分搜索应用面更广。<br />二分搜索有许多中变种。比如[分散层叠](https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E6%95%A3%E5%B1%82%E5%8F%A0&action=edit&redlink=1)可以提升在多个数组中对同一个数值的搜索。分散层叠有效的解决了[计算几何学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6)和其他领域的许多搜索问题。[指数搜索](https://zh.wikipedia.org/w/index.php?title=Exponential_Search&action=edit&redlink=1)将二分搜索拓宽到无边界的列表。[二分搜索树](https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91&action=edit&redlink=1)和B树数据结构就是基于[二分搜索](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2)的。\n## 分治算法(Divide and Conquer)\n在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**分治法**是建基于多项分支[递归](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92)的一种很重要的算法[范式](https://zh.wikipedia.org/wiki/%E7%AF%84%E5%BC%8F)。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。<br />这个技巧是很多高效算法的基础，如[排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)（[快速排序](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)、[归并排序](https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)）、[傅立叶变换](https://zh.wikipedia.org/wiki/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2)（[快速傅立叶变换](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2)）。<br />另一方面，理解及设计分治法算法的能力需要一定时间去掌握。正如以归纳法去证明一个[理论](https://zh.wikipedia.org/wiki/%E7%90%86%E8%AB%96)，为了使递归能够推行，很多时候需要用一个较为概括或复杂的问题去取代原有问题。而且并没有一个系统性的方法去适当地概括问题。<br />**分治法**这个名称有时亦会用于将问题简化为只有一个细问题的算法，例如用于在已排序的列中查找其中一项的[折半搜索算法](https://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)（或是在[数值分析](https://zh.wikipedia.org/wiki/%E6%95%B8%E5%80%BC%E5%88%86%E6%9E%90)中类似的[勘根算法](https://zh.wikipedia.org/wiki/%E5%8B%98%E6%A0%B9%E5%AE%9A%E7%90%86)）。这些算法比一般的分治算法更能有效地运行。其中，假如算法使用[尾部递归](https://zh.wikipedia.org/wiki/%E5%B0%BE%E9%83%A8%E9%80%92%E5%BD%92)的话，便能转换成简单的[循环](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%BF%B4%E5%9C%88)。但在这广义之下，所有使用递归或循环的算法均被视作“分治算法”。因此，有些作者考虑“分治法”这个名称应只用于每个有最少两个子问题的算法。而只有一个子问题的曾被建议使用**减治法**这个名称。<br />分治算法通常以[数学归纳法](https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8%E6%AD%B8%E7%B4%8D%E6%B3%95)来验证。而它的计算成本则多数以解[递归关系式](https://zh.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E9%97%9C%E4%BF%82%E5%BC%8F)来判定。    \n## 动态规划(Dynamic Programming)\n**动态规划**（英语：Dynamic programming，简称DP）是一种在[数学](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6)、[管理科学](https://zh.wikipedia.org/wiki/%E7%AE%A1%E7%90%86%E7%A7%91%E5%AD%A6)、[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)、[经济学](https://zh.wikipedia.org/wiki/%E7%BB%8F%E6%B5%8E%E5%AD%A6)和[生物信息学](https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6)中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<br />动态规划常常适用于有重叠子问题和[最优子结构](https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84&action=edit&redlink=1)性质的问题，动态规划方法所耗时间往往远少于朴素解法。<br />动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。<br />通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其[记忆化](https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96)存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈[指数增长](https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B8%E5%A2%9E%E9%95%B7)时特别有用。\n## 回溯算法(Backtracking)\n**回溯法**（英语：backtracking）是[暴力搜索法](https://zh.wikipedia.org/wiki/%E6%9A%B4%E5%8A%9B%E6%90%9C%E5%B0%8B%E6%B3%95)中的一种。<br />对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。<br />在经典的教科书中，**[八皇后问题](https://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98)**展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）<br />回溯法采用[试错](https://zh.wikipedia.org/wiki/%E8%AF%95%E9%94%99)的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的[递归](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92)方法来实现，在反复重复上述的步骤后可能出现两种情况：\n* 找到一个可能存在的正确的答案\n* 在尝试了所有可能的分步方法后宣告该问题没有答案\n\n在最坏的情况下，回溯法会导致一次[复杂度](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA)为[指数时间](https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B8%E6%99%82%E9%96%93)的计算。\n## 栈(Stack)\n**堆栈**（英语：stack）又称为**栈**或**堆叠**，是[计算机科学](https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)中一种特殊的串列形式的[抽象数据类型](https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)，其特殊之处在于只能允许在[链表](https://zh.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97)或[数组](https://zh.wikipedia.org/wiki/%E9%99%A3%E5%88%97)的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外堆栈也可以用一维[数组](https://zh.wikipedia.org/wiki/%E9%99%A3%E5%88%97)或[链表](https://zh.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97)的形式来完成。堆栈的另外一个相对的操作方式称为[队列](https://zh.wikipedia.org/wiki/%E4%BD%87%E5%88%97)。<br />由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。\n## 堆(Heap)\n**堆**（英语：Heap）是[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中的一种特别的树状[数据结构](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒**小于等于**子节点的值，此堆称为**最小堆**（min heap）；反之，若母节点的值恒**大于等于**子节点的值，此堆称为**最大堆**（max heap）。在堆中最顶端的那一个节点，称作**根节点**（root node），根节点本身没有**母节点**（parent node）。<br />堆始于 [J._W._J._Williams](https://zh.wikipedia.org/w/index.php?title=J._W._J._Williams&action=edit&redlink=1) 在 1964 年发表的**堆排序**（heap sort），当时他提出了二叉堆树作为此算法的数据结构。堆在[戴克斯特拉算法](https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95)（英语：Dijkstra's algorithm）中亦为重要的关键。<br />在[队列](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97)中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。\n## 贪心算法(Greedy)\n**贪心算法**（英语：greedy algorithm），又称**贪婪算法**，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)。比如在[旅行推销员问题](https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98)中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。<br />贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。<br />贪心算法与[动态规划](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。<br />贪心法可以解决一些[最优化](https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BC%98%E5%8C%96)问题，如：求[图](https://zh.wikipedia.org/wiki/%E5%9B%BE)中的[最小生成树](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91)、求[哈夫曼编码](https://zh.wikipedia.org/wiki/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81)……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。\n## 排序(Sort)\n在[计算机科学](https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)与[数学](https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8)中，一个**排序算法**（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)。最常用到的排序方式是数值顺序以及[字典顺序](https://zh.wikipedia.org/wiki/%E5%AD%97%E5%85%B8%E9%A0%86%E5%BA%8F)。有效的排序算法在一些算法（例如[搜索算法](https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E7%AE%97%E6%B3%95)与[合并算法](https://zh.wikipedia.org/w/index.php?title=%E5%90%88%E4%BD%B5%E7%AE%97%E6%B3%95&action=edit&redlink=1)）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：\n  1. 输出结果为递增序列（递增是针对所需的排序顺序而言）\n  1. 输出结果是原输入的一种[排列](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%88%97)、或是重组\n\n虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，[冒泡排序](https://zh.wikipedia.org/wiki/%E6%B0%A3%E6%B3%A1%E6%8E%92%E5%BA%8F)在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：[图书馆排序](https://zh.wikipedia.org/wiki/%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%8E%92%E5%BA%8F)在2004年被发表）\n## 位运算(Bit Manipulation)\n**位操作**是[算法](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Algorithm&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhjMVi1RPGMBteOeVhr7rwyRqB0rpw)操作比[字](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Word_(data_type)&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhjWJGcdyh6D0YqybOhRRrQm_q3weA)短的[位](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Bit&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhjEeYjDXtSE4aLD8IBpxGHOw7i1cw)或其他[数据](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Data_(computing)&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhimJkNnf1ms2G_qzxH5ThHaFXOF3w)的行为。 需要位操作的[计算机编程](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Computer_programming&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhgBTJOhasH5dW1tnoxF67KIfvfLTg)任务包括低级设备控制， [错误检测](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Error_detection&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhgXOngDc_CmFhIvFAdYWlKuRmY5sA)和[纠正](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Error_correction&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhiSkVgbuw44Uuoqt32JwsNGOtuw_g)算法， [数据压缩](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Data_compression&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhgSFcXbh6AiHJgQKcqYVOpo_yxdxA) ， [加密](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Encryption&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhi9MtfS8E3BFR-z1u_riRNQ4gfERA)算法和[优化](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Optimization_(computer_science)&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhh_t9EuZt8FPWcE83nzA7-3KzopLw) 。 对于大多数其他任务，现代[编程语言](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Programming_language&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhj2io6d_vRyulRfmd5Yfg6y-t0jwA)允许[程序员](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Programmer&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhgf_SNoU3vDFByphd_Ho3Qo_cUX0w)直接使用[抽象](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Abstraction_(computer_science)&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhgsc5qtrh0_vT7zGYTWMCKDHxCcOA)而不是代表那些抽象的位。 执行位操作的[源代码](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Source_code&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhj24xoEiLJDqG9xWG1lAWhEg3m9kw)使用[按位运算](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Bitwise_operation&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhixv-Y0how8ovsYIKadV3hDvxPp_g) ：AND，OR，XOR，NOT和[位移](https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&prev=search&rurl=translate.google.com&sl=en&sp=nmt4&u=https://en.wikipedia.org/wiki/Bitwise_operation&xid=25657,15700021,15700186,15700190,15700248&usg=ALkJrhixv-Y0how8ovsYIKadV3hDvxPp_g#Bit_shifts) 。<br />在某些情况下，位操作可以消除或减少循环数据结构的需要，并且可以提供多倍的加速，因为并行处理位操作，但代码可能变得更难以编写和维护。\n## 树(Tree)\n在计算机科学中，**树**（英语：tree）是一种[抽象数据类型](https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5)（ADT）或是实现这种抽象数据类型的[数据结构](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B)，用来模拟具[有树状结构](https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B)性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的[集合](https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88)。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n* 每个节点有零个或多个子节点；\n* 没有父节点的节点称为根节点；\n* 每一个非根节点有且只有一个父节点；\n* 除了根节点外，每个子节点可以分为多个不相交的子树；\n* 树里面没有环路(cycle)\n## 深度优先搜索(Depth-first Search)\n**深度优先搜索算法**（英语：Depth-First-Search，DFS）是一种用于遍历或搜索[树](https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84))或[图](https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6))的[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。<br />深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应[拓扑](https://zh.wikipedia.org/wiki/%E6%8B%93%E6%89%91)排序表，利用拓扑排序表可以方便的解决很多相关的[图论](https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA)问题，如最大路径问题等等。<br />因发明“深度优先搜索算法”，[约翰·霍普克洛夫特](https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E9%9C%8D%E6%99%AE%E5%85%8B%E6%B4%9B%E5%A4%AB%E7%89%B9)与[罗伯特·塔扬](https://zh.wikipedia.org/wiki/%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7%E5%A1%94%E6%89%AC)在[1986年](https://zh.wikipedia.org/wiki/1986%E5%B9%B4)共同获得计算机领域的最高奖：[图灵奖](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96)。\n## [广度优先搜索(Breadth-first Search)](https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)\n**广度优先搜索算法**（英语：Breadth-First-Search，缩写为BFS），又译作**宽度优先搜索**，或**横向优先搜索**，是一种[图形搜索算法](https://zh.wikipedia.org/w/index.php?title=%E5%9C%96%E5%BD%A2%E6%90%9C%E7%B4%A2%E6%BC%94%E7%AE%97%E6%B3%95&action=edit&redlink=1)。简单的说，BFS是从[根节点](https://zh.wikipedia.org/w/index.php?title=%E6%A0%B9%E7%AF%80%E9%BB%9E&action=edit&redlink=1)开始，沿着树的宽度遍历树的[节点](https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9)。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。\n## [并查集(Union Find)](https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86)\n在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**并查集**是一种树型的[数据结构](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，用于处理一些[不交集](https://zh.wikipedia.org/wiki/%E4%B8%8D%E4%BA%A4%E9%9B%86)（Disjoint Sets）的合并及查询问题。有一个**联合-查找算法**（**union-find algorithm**）定义了两个用于此数据结构的操作：\n* Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。\n* Union：将两个子集合并成同一个集合。\n\n由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于创建单元素集合。有了这些方法，许多经典的[划分问题](https://zh.wikipedia.org/w/index.php?title=%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98&action=edit&redlink=1)可以被解决。<br />为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。\n## 图(Graph)\n\n## 设计(Design)\n\n## [拓扑排序(Topological Sort)](https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F)\n在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)领域，有向图的拓扑排序是其顶点的线性排序，使得对于从顶点![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354123-46ab159b-38a0-46e3-a690-34e6b7709fdf.svg#align=left&display=inline&height=30&linkTarget=_blank&originHeight=15&originWidth=12&size=0&width=24)到顶点![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354252-13693c10-18ce-497c-b9d7-779c170f2a8d.svg#align=left&display=inline&height=36&linkTarget=_blank&originHeight=15&originWidth=10&size=0&width=24)的每个有向边![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354371-3ec1d5f3-0550-4402-9b94-1b4b8f3f0600.svg#align=left&display=inline&height=33&linkTarget=_blank&originHeight=15&originWidth=22&size=0&width=48)，![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374355325-b27802fb-985e-4392-a5f1-8d6579ef3e54.svg#align=left&display=inline&height=30&linkTarget=_blank&originHeight=15&originWidth=12&size=0&width=24)在排序中都在![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354366-9481a9bd-90a4-404d-91c0-f7dade18d1bf.svg#align=left&display=inline&height=36&linkTarget=_blank&originHeight=15&originWidth=10&size=0&width=24)之前。 例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束; 在这个应用中，拓扑排序只是一个有效的任务顺序。 如果且仅当图形没有定向循环，即如果它是[有向无环图](https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE)（[DAG](https://zh.wikipedia.org/wiki/DAG)），则拓扑排序是可能的。 任何 DAG 具有至少一个拓扑排序，并且已知这些算法用于在线性时间内构建任何 DAG 的拓扑排序。<br />在[图论](https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA)中，由一个[有向无环图](https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE)的顶点组成的序列，当且仅当满足下列条件时，称为该[图](https://zh.wikipedia.org/wiki/%E5%9B%BE)的一个**拓扑排序**（英语：Topological sorting）。\n1. 每个顶点出现且只出现一次；\n1. 若A在序列中排在B的前面，则在图中不存在从B到A的[路径](https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%BE%84_(%E5%9B%BE%E8%AE%BA))。\n## [字典树(Trie)](https://zh.wikipedia.org/wik\\i/Trie)\n在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**trie**，又称**前缀树**或**字典树**，是一种有序[树](https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84))，用于保存[关联数组](https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84)，其中的键通常是[字符串](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2)。与[二叉查找树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的[前缀](https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80)，也就是这个节点对应的字符串，而根节点对应[空字符串](https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2)。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。<br />Trie这个术语来自于re**trie**val。根据[词源学](https://zh.wikipedia.org/wiki/%E8%AF%8D%E6%BA%90%E5%AD%A6)，trie的发明者Edward Fredkin把它读作[/ˈtriː/](https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99) \"tree\"。但是，其他作者把它读作[/ˈtraɪ/](https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99) \"try\"。<br />在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie可以看作是一个[确定有限状态自动机](https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA)，尽管边上的符号一般是隐含在分支的顺序中的。<br />键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。<br />trie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，**bitwise trie**中的键是一串比特，可以用于表示整数或者内存地址。\n## [树状数组(Binary Indexed Tree)](https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84)\n**树状数组**或**二叉索引树**（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374511328-9fe02213-3e39-4b5b-acbe-fb59ee62ea6a.svg#align=left&display=inline&height=24&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=69)的时间得到任意前缀和![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374510664-f61df39c-15ae-4076-a405-b180719a51da.svg#align=left&display=inline&height=33&linkTarget=_blank&originHeight=66&originWidth=199&size=0&width=100)，并同时支持在![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374511010-ea3ea917-e9c1-48cf-ada2-4093faacfddd.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=64)时间内支持动态单点值的修改。空间复杂度![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374511028-2d7e11b6-48e0-4e85-89dd-de13cc5a6a65.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=26&originWidth=45&size=0&width=48)。\n## [线段树(Segment Tree)](https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5%E6%A8%B9)\n**线段树**（英语：Segment tree）是一种[二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9)形数据结构，1977年由Jon Louis Bentley发明，用以存储[区间](https://zh.wikipedia.org/wiki/%E5%8D%80%E9%96%93)或[线段](https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5)，并且允许快速查询结构内包含某一点的所有区间。<br />一个包含![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552076-e7d1c1d6-98c5-4322-a4f2-bb1bcc5a0d9f.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=15&originWidth=13&size=0&width=24)个区间的线段树，空间复杂度为![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552115-58a0f517-8c4f-42ae-9e70-96c81942fc07.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=26&originWidth=45&size=0&width=48)，查询的时间复杂度则为<br />![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552251-c509b348-c14d-4d64-9b3d-ead957b7bebf.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=111&size=0&width=96)，其中![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552879-3eb804e1-b119-4942-a704-e087c6dffe63.svg#align=left&display=inline&height=44&linkTarget=_blank&originHeight=20&originWidth=11&size=0&width=24) 是匹配条件的区间数量。<br />此数据结构亦可推广到高维度。\n## [二叉搜索树(Binary Search Tree)](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9)\n**二叉查找树**（英语：Binary Search Tree），也称为**二叉搜索树**、**有序二叉树**（ordered binary tree）或**排序二叉树**（sorted binary tree），是指一棵空树或者具有下列性质的[二叉树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)：\n1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n1. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n1. 任意节点的左、右子树也分别为二叉查找树；\n1. 没有键值相等的节点。\n\n二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374603713-e7614cde-5606-4f23-83b9-4ff54cf3550c.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=64)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如[集合](https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))、[多重集](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E9%9B%86)、[关联数组](https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84)等。<br />二叉查找树的查找过程和[次优二叉树](https://zh.wikipedia.org/w/index.php?title=%E6%AC%A1%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91&action=edit&redlink=1)类似，通常采取二叉[链表](https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8)作为二叉查找树的[存储结构](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374604022-7033cee1-3f01-406d-ba64-a70801094f38.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=64)，最坏![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374602579-6fa796ae-ae43-4472-9023-95d85568de76.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=26&originWidth=45&size=0&width=48)（数列有序，树退化成线性表）。<br />虽然二叉查找树的最坏效率是![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374602655-65e5154d-b982-4944-be46-c8d04d9e0f7f.svg#align=left&display=inline&height=28&linkTarget=_blank&originHeight=26&originWidth=45&size=0&width=48),但它支持动态查询，且有很多改进版的二叉查找树可以使树高为![](https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374603172-e378edd1-985b-444d-8847-54100c89d8ee.svg#align=left&display=inline&height=22&linkTarget=_blank&originHeight=26&originWidth=75&size=0&width=64),如[SBT](https://zh.wikipedia.org/w/index.php?title=SBT&action=edit&redlink=1),[AVL树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)，[红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)等。故不失为一种好的动态查找方法。\n## [递归(Recursion)](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92)\n**递归**（英语：Recursion），又译为**递回**，在[数学](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6)与[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，是指在[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0)的定义中使用函数自身的方法。递归一词还较常用于描述以[自相似](https://zh.wikipedia.org/wiki/%E8%87%AA%E7%9B%B8%E4%BC%BC)方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。\n## 脑筋急转弯(Brainteaser)\n\n## 记忆化(Memoization)\n在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)中，**记忆化**（英语：memoization而非memorization）是一种提高程序运行速度的优化技术。通过储存大计算量[函数](https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F)的返回值，当这个结果再次被需要时将其从[缓存](https://zh.wikipedia.org/wiki/%E7%BC%93%E5%AD%98)提取，而不用再次计算来节省计算时间。 <br />记忆化是一种典型的时间存储平衡方案。\n## [队列(Queue)](https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97)\n**队列**，又称为**伫列**（queue），是[先进先出](https://zh.wikipedia.org/wiki/%E5%85%88%E9%80%B2%E5%85%88%E5%87%BA)（FIFO, First-In-First-Out）的[线性表](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8)。在具体应用中通常用[链表](https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8)或者[数组](https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84)来实现。队列只允许在后端（称为_rear_）进行插入操作，在前端（称为_front_）进行删除操作。<br />队列的操作方式和[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)类似，唯一的区别在于队列只允许新数据在后端进行添加。\n## [极小化极大(Minimax)](https://zh.wikipedia.org/wiki/%E6%9E%81%E5%B0%8F%E5%8C%96%E6%9E%81%E5%A4%A7%E7%AE%97%E6%B3%95)\n**Minimax算法**（亦称 **MinMax** or **MM**）又名极小化极大算法，是一种找出失败的最大可能性中的最小值的算法。\n## 蓄水池抽样(Reservoir Sampinh)\n\n## Map\n\n## 几何(Geometry)\n\n## Rendom\n\n## Rejection Samping\n\n## 参考\n以上内容均来自wikipedia\n",
    "body_draft": "",
    "body_html": "<p><span>categories: leetcode</span></p><p><span><br /></span></p><hr /><p><span>&lt;blockquote class=&quot;blockquote-center&quot;&gt;**据说维基的知识总结很优秀**&lt;/blockquote&gt;</span></p><p><span>&lt;!-- more --&gt;</span></p><p><br /></p><h2 id=\"df368884\">前言</h2><p style=\"text-indent: 2em;\"><span>若hexo有小bug或不舒服之处，请移步到</span><a href=\"https://www.yuque.com/tfrain/boke/wikipedia_algorithm\" target=\"_blank\">语雀</a><span>浏览</span></p><p style=\"text-indent: 2em;\">因为自己的算法基础非常薄弱，希望通过兔派刷题的方式，怀着幸存者的意识，能够迎头赶上。</p><h2 id=\"7b540246\">数组(Array)</h2><p style=\"text-indent: 2em;\">在计算机科学中，<strong>数组数据结构</strong>（<span>英语：<span>array data structure</span></span>），简称<strong>数组</strong>（<span>英语：<span>Array</span></span>），是由相同类型的元素（element）的集合所组成的<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" target=\"_blank\">数据结构</a>，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。</p><p style=\"text-indent: 2em;\">最简单的数据结构类型是<strong>一维数组</strong>。例如，索引为0到9的32位整数数组，可作为在存储器地址2000，2004，2008，...2036中，存储10个变量，因此索引为i的元素即在存储器中的2000+4×i地址。数组第一个元素的存储器地址称为第一地址或基础地址。</p><p style=\"text-indent: 2em;\"><strong>二维数组</strong>，对应于数学上的<a href=\"https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%99%A3\" target=\"_blank\">矩阵</a>概念，可表示为二维矩形格。例如：<img src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549288867661-a83c2c4e-808d-42eb-b39b-22e7de8e5ed5.svg\" style=\"width: 51px; height: 24px;\" /><span>在</span><a href=\"https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80\" target=\"_blank\">C语言</a><span>中表示为<span>{% raw %}</span></span>int a[3][3] = {{3, 6, 2}, {0, 1, -4}, {2, -1, 0}};<span>{% endraw %}</span>。</p><p style=\"text-indent: 2em;\">在某些情况下，“<a href=\"https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F\" target=\"_blank\">向量</a>”一词也可能代表二维数组，虽然在数学意义上更确切地称呼为<a href=\"https://zh.wikipedia.org/wiki/%E5%85%83%E7%BB%84\" target=\"_blank\">元组</a>（tuple），而不是向量。但需要注意的是：计算机科学的某些领域，如Matlab，元组是指类似C语言struct类型，具有固定的往往是不同类型的数据成员的数据结构。</p><p style=\"text-indent: 2em;\">数组通常用于实现<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93\" target=\"_blank\">数据库</a>的表格，特别是查询表；表格有时也被当作是数组的同义词。</p><p style=\"text-indent: 2em;\">数组是最早期和最重要的数据结构之一，很多程序都会用到数组。它们也用于实现许多其他数据结构，譬如列表（list）和<a href=\"https://zh.wikipedia.org/wiki/%E5%AD%97%E4%B8%B2\" target=\"_blank\">字符串</a>（string）。它们有成效地开展了计算机的定址逻辑。在大多数现代计算机和许多外部存储设备中，存储器如同一维数组，索引就是其地址。编译器、处理单元（特别是<a href=\"https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8\" target=\"_blank\">向量处理器</a>），经常会针对数组操作进行优化。</p><p>因为在程序运行时可以计算元素的索引，数组是很有用的。此外，也能以单一迭代语句就处理数组的许多元素。为此，数组数据结构的元素必须具有相同的大小，而且应该使用相同的<a href=\"https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5\" target=\"_blank\">数据类型</a>表示。</p><p style=\"text-indent: 2em;\">数组一词通常用于表示数组数据类型，一种大多数高端编程语言都会内置的<a href=\"https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5\" target=\"_blank\">数据类型</a>。数组类型通常由数组结构来实现；然而在某些语言中，它们可以由<a href=\"https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8\" target=\"_blank\">散列表</a>、<a href=\"https://zh.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97\" target=\"_blank\">链表</a>、<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%90%9C%E7%B4%A2%E6%A8%B9&amp;action=edit&amp;redlink=1\" target=\"_blank\">搜索树</a>或其它<a href=\"https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B\" target=\"_blank\">数据结构</a>来实现。</p><p style=\"text-indent: 2em;\">在算法的描述中，数组一词特别着重意义为<a href=\"https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84\" target=\"_blank\">关系数组</a>或“抽象的数组”，一种理论上的计算机科学模型（抽象数据类型或 ADT），专注于数组的基本性质上。</p><h2 id=\"c16bbb87\">哈希表(Hash Table)</h2><p style=\"text-indent: 2em;\"><strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据<a href=\"https://zh.wikipedia.org/wiki/%E9%8D%B5\" target=\"_blank\">键</a>（Key）而直接访问在内存存储位置的<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" target=\"_blank\">数据结构</a>。也就是说，它通过计算一个关于键值的函数，将所需查询的数据<a href=\"https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84\" target=\"_blank\">映射</a>到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<a href=\"https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0\" target=\"_blank\">散列函数</a>，存放记录的数组称做<strong>散列表</strong>。</p><p style=\"text-indent: 2em;\">一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名<span>x</span>到首字母<span>F(x)</span>的一个<a href=\"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0\" target=\"_blank\">函数</a>关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为<a href=\"https://zh.wikipedia.org/wiki/%E9%97%9C%E9%8D%B5%E5%AD%97\" target=\"_blank\">关键字</a>，“取首字母”是这个例子中<a href=\"https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0\" target=\"_blank\">散列函数</a>的函数法则<span>F()</span>，存放首字母的表对应<a href=\"https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E8%A1%A8\" target=\"_blank\">散列表</a>。关键字和函数法则理论上可以任意确定。</p><h2 id=\"a4c8e9c4\">链表(Linked List)</h2><p style=\"text-indent: 2em;\"><strong>链表</strong>（<span>Linked list</span>）是一种常见的基础数据结构，是一种<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8\" target=\"_blank\">线性表</a>，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的<a href=\"https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)\" target=\"_blank\">指针</a>(<span>Pointer</span>)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的<a href=\"https://zh.wikipedia.org/wiki/%E8%A4%87%E9%9B%9C%E5%BA%A6\" target=\"_blank\">复杂度</a>，比另一种线性表<a href=\"https://zh.wikipedia.org/wiki/%E9%A1%BA%E5%BA%8F%E8%A1%A8\" target=\"_blank\">顺序表</a>快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p><p style=\"text-indent: 2em;\">使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p><p style=\"text-indent: 2em;\">在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（&quot;links&quot;）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。</p><p style=\"text-indent: 2em;\">链表可以在多种编程语言中实现。像<a href=\"https://zh.wikipedia.org/wiki/Lisp\" target=\"_blank\">Lisp</a>和<a href=\"https://zh.wikipedia.org/wiki/Scheme\" target=\"_blank\">Scheme</a>这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。</p><h2 id=\"4d402b45\">数学(Math)</h2><p><br /></p><h2 id=\"af7a46f0\">双指针(Two Pointers)</h2><p><br /></p><h2 id=\"e1eab6e5\">串(String)</h2><p style=\"text-indent: 2em;\"><strong>字符串</strong>（<strong>String</strong>），是由零个或多个<a href=\"https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6\" target=\"_blank\">字符</a>组成的有限序列。一般记为。它是<a href=\"https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80\" target=\"_blank\">编程语言</a>中表示<a href=\"https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC\" target=\"_blank\">文本</a>的<a href=\"https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5\" target=\"_blank\">数据类型</a>。</p><p style=\"text-indent: 2em;\">通常以串的整体作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。两个字符串相等的充要条件是：长度相等，并且各个对应位置上的字符都相等。设p、q是两个串，求q在p中首次出现的位置的运算叫做模式匹配。串的两种最基本的存储方式是顺序存储方式和链接存储方式。</p><h2 id=\"5690ef2c\">二分查找(Binary Search)</h2><p style=\"text-indent: 2em;\">在<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\">计算机科学</a>中，<strong>二分搜索</strong>（<span>英语：<span>binary search</span></span>），也称<strong>折半搜索</strong>（<span>英语：<span>half-interval search</span></span>）、<strong>对数搜索</strong>（<span>英语：<span>logarithmic search</span></span>），是一种在<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%89%E5%BA%8F%E6%95%B0%E5%AF%B9\" target=\"_blank\">有序数组</a>中查找某一特定元素的搜索<a href=\"https://zh.wikipedia.org/wiki/%E6%BC%94%E7%AE%97%E6%B3%95\" target=\"_blank\">算法</a>。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><p style=\"text-indent: 2em;\">二分搜索在情况下的复杂度是对数时间，进行<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291436329-6143cbca-53e0-4ec8-a4cb-a1540416cf2f.svg#align=left&amp;display=inline&amp;height=22&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=75&amp;size=0&amp;width=64\" style=\"max-width: 600px; width: 64px;\" />次比较操作<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291435712-b8b12d5e-9e71-4339-8a7b-243957d03d3c.svg#align=left&amp;display=inline&amp;height=28&amp;linkTarget=_blank&amp;originHeight=15&amp;originWidth=13&amp;size=0&amp;width=24\" style=\"max-width: 600px; width: 24px;\" />在此处是数组的元素数量，<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291435981-1075a6e4-8cca-4daf-a0ac-5066aa045df5.svg#align=left&amp;display=inline&amp;height=30&amp;linkTarget=_blank&amp;originHeight=20&amp;originWidth=16&amp;size=0&amp;width=24\" style=\"max-width: 600px; width: 24px;\" />是<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7\" target=\"_blank\">大O记号</a>，<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549291435966-5e179d00-15dd-4d34-a342-c31b303e442f.svg#align=left&amp;display=inline&amp;height=20&amp;linkTarget=_blank&amp;originHeight=23&amp;originWidth=27&amp;size=0&amp;width=24\" style=\"max-width: 600px; width: 24px;\" />是<a href=\"https://zh.wikipedia.org/wiki/%E5%AF%B9%E6%95%B0\" target=\"_blank\">对数</a>）。二分搜索使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分搜索比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如<a href=\"https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8\" target=\"_blank\">哈希表</a>），二分搜索应用面更广。</p><p>二分搜索有许多中变种。比如<span><a href=\"https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E6%95%A3%E5%B1%82%E5%8F%A0&amp;action=edit&amp;redlink=1\" target=\"_blank\">分散层叠</a></span>可以提升在多个数组中对同一个数值的搜索。分散层叠有效的解决了<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6\" target=\"_blank\">计算几何学</a>和其他领域的许多搜索问题。<span><a href=\"https://zh.wikipedia.org/w/index.php?title=Exponential_Search&amp;action=edit&amp;redlink=1\" target=\"_blank\">指数搜索</a></span>将二分搜索拓宽到无边界的列表。<a href=\"https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91&amp;action=edit&amp;redlink=1\" target=\"_blank\">二分搜索树</a>和B树数据结构就是基于<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2\" target=\"_blank\">二分搜索</a>的。</p><h2 id=\"d4fc9bef\">分治算法(Divide and Conquer)</h2><p style=\"text-indent: 2em;\">在<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\">计算机科学</a>中，<strong>分治法</strong>是建基于多项分支<a href=\"https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92\" target=\"_blank\">递归</a>的一种很重要的算法<a href=\"https://zh.wikipedia.org/wiki/%E7%AF%84%E5%BC%8F\" target=\"_blank\">范式</a>。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p style=\"text-indent: 2em;\">这个技巧是很多高效算法的基础，如<a href=\"https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\" target=\"_blank\">排序算法</a>（<a href=\"https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\" target=\"_blank\">快速排序</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\" target=\"_blank\">归并排序</a>）、<a href=\"https://zh.wikipedia.org/wiki/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2\" target=\"_blank\">傅立叶变换</a>（<a href=\"https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2\" target=\"_blank\">快速傅立叶变换</a>）。</p><p style=\"text-indent: 2em;\">另一方面，理解及设计分治法算法的能力需要一定时间去掌握。正如以归纳法去证明一个<a href=\"https://zh.wikipedia.org/wiki/%E7%90%86%E8%AB%96\" target=\"_blank\">理论</a>，为了使递归能够推行，很多时候需要用一个较为概括或复杂的问题去取代原有问题。而且并没有一个系统性的方法去适当地概括问题。</p><p style=\"text-indent: 2em;\"><strong>分治法</strong>这个名称有时亦会用于将问题简化为只有一个细问题的算法，例如用于在已排序的列中查找其中一项的<a href=\"https://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95\" target=\"_blank\">折半搜索算法</a>（或是在<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B8%E5%80%BC%E5%88%86%E6%9E%90\" target=\"_blank\">数值分析</a>中类似的<a href=\"https://zh.wikipedia.org/wiki/%E5%8B%98%E6%A0%B9%E5%AE%9A%E7%90%86\" target=\"_blank\">勘根算法</a>）。这些算法比一般的分治算法更能有效地运行。其中，假如算法使用<a href=\"https://zh.wikipedia.org/wiki/%E5%B0%BE%E9%83%A8%E9%80%92%E5%BD%92\" target=\"_blank\">尾部递归</a>的话，便能转换成简单的<a href=\"https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%BF%B4%E5%9C%88\" target=\"_blank\">循环</a>。但在这广义之下，所有使用递归或循环的算法均被视作“分治算法”。因此，有些作者考虑“分治法”这个名称应只用于每个有最少两个子问题的算法。而只有一个子问题的曾被建议使用<strong>减治法</strong>这个名称。</p><p style=\"text-indent: 2em;\">分治算法通常以<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8%E6%AD%B8%E7%B4%8D%E6%B3%95\" target=\"_blank\">数学归纳法</a>来验证。而它的计算成本则多数以解<a href=\"https://zh.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E9%97%9C%E4%BF%82%E5%BC%8F\" target=\"_blank\">递归关系式</a>来判定。    </p><h2 id=\"6d0a732d\">动态规划(Dynamic Programming)</h2><p style=\"text-indent: 2em;\"><strong>动态规划</strong>（<span>英语：<span>Dynamic programming</span></span>，简称<span>DP</span>）是一种在<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6\" target=\"_blank\">数学</a>、<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%A1%E7%90%86%E7%A7%91%E5%AD%A6\" target=\"_blank\">管理科学</a>、<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\">计算机科学</a>、<a href=\"https://zh.wikipedia.org/wiki/%E7%BB%8F%E6%B5%8E%E5%AD%A6\" target=\"_blank\">经济学</a>和<a href=\"https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6\" target=\"_blank\">生物信息学</a>中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p style=\"text-indent: 2em;\">动态规划常常适用于有重叠子问题和<span><a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84&amp;action=edit&amp;redlink=1\" target=\"_blank\">最优子结构</a></span>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p style=\"text-indent: 2em;\">动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p><p style=\"text-indent: 2em;\">通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96\" target=\"_blank\">记忆化</a>存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈<a href=\"https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B8%E5%A2%9E%E9%95%B7\" target=\"_blank\">指数增长</a>时特别有用。</p><h2 id=\"127cba8a\">回溯算法(Backtracking)</h2><p style=\"text-indent: 2em;\"><strong>回溯法</strong>（<span>英语：<span>backtracking</span></span>）是<a href=\"https://zh.wikipedia.org/wiki/%E6%9A%B4%E5%8A%9B%E6%90%9C%E5%B0%8B%E6%B3%95\" target=\"_blank\">暴力搜索法</a>中的一种。</p><p style=\"text-indent: 2em;\">对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解）。</p><p style=\"text-indent: 2em;\">在经典的教科书中，<strong><a href=\"https://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98\" target=\"_blank\">八皇后问题</a></strong>展示了回溯法的用例。（八皇后问题是在标准国际象棋棋盘中寻找八个皇后的所有分布，使得没有一个皇后能攻击到另外一个。）</p><p style=\"text-indent: 2em;\">回溯法采用<a href=\"https://zh.wikipedia.org/wiki/%E8%AF%95%E9%94%99\" target=\"_blank\">试错</a>的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的<a href=\"https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92\" target=\"_blank\">递归</a>方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><ul><li>找到一个可能存在的正确的答案</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案</li></ul><p style=\"text-indent: 2em;\">在最坏的情况下，回溯法会导致一次<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA\" target=\"_blank\">复杂度</a>为<a href=\"https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B8%E6%99%82%E9%96%93\" target=\"_blank\">指数时间</a>的计算。</p><h2 id=\"74d9851e\">栈(Stack)</h2><p style=\"text-indent: 2em;\"><strong>堆栈</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">（</span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">英语：<span>stack</span></span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">）又称为</span><strong>栈</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">或</span><strong>堆叠</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">，是</span><a href=\"https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8\" target=\"_blank\">计算机科学</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">中一种特<span class=\"lake-fontsize-11\" style=\"color: #222222;\">殊的串列形式的</span><a href=\"https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5\" target=\"_blank\">抽象数据类型</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">，其特殊之处在于只能允许在</span><a href=\"https://zh.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97\" target=\"_blank\">链表</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">或</span><a href=\"https://zh.wikipedia.org/wiki/%E9%99%A3%E5%88%97\" target=\"_blank\">数组</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">的一端</span>（称为堆栈顶端指针，<span>英语：<span>top</span></span>）进行加入数据（<span>英语：<span>push</span></span>）和输出数据（<span>英语：<span>pop</span></span>）的运算。另外堆栈也可以用一维<a href=\"https://zh.wikipedia.org/wiki/%E9%99%A3%E5%88%97\" target=\"_blank\">数组</a>或<a href=\"https://zh.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E4%B8%B2%E5%88%97\" target=\"_blank\">链表</a>的形式来完成。堆栈的另外一个相对的操作方式称为<a href=\"https://zh.wikipedia.org/wiki/%E4%BD%87%E5%88%97\" target=\"_blank\">队列</a>。</span></p><p>由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。</p><h2 id=\"8fb62e16\">堆(Heap)</h2><p style=\"text-indent: 2em;\"><strong>堆</strong>（<span>英语：<span>Heap</span></span>）是<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\">计算机科学</a>中的一种特别的树状<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" target=\"_blank\">数据结构</a>。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒<strong>小于等于</strong>子节点的值，此堆称为<strong>最小堆</strong>（<span>min heap</span>）；反之，若母节点的值恒<strong>大于等于</strong>子节点的值，此堆称为<strong>最大堆</strong>（<span>max heap</span>）。在堆中最顶端的那一个节点，称作<strong>根节点</strong>（<span>root node</span>），根节点本身没有<strong>母节点</strong>（<span>parent node</span>）。</p><p style=\"text-indent: 2em;\">堆始于 <span><a href=\"https://zh.wikipedia.org/w/index.php?title=J._W._J._Williams&amp;action=edit&amp;redlink=1\" target=\"_blank\">J._W._J._Williams</a></span> 在 1964 年发表的<strong>堆排序</strong>（<span>heap sort</span>），当时他提出了二叉堆树作为此算法的数据结构。堆在<a href=\"https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\" target=\"_blank\">戴克斯特拉算法</a>（<span>英语：<span>Dijkstra's algorithm</span></span>）中亦为重要的关键。</p><p style=\"text-indent: 2em;\">在<a href=\"https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97\" target=\"_blank\">队列</a>中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p><h2 id=\"47f950ef\">贪心算法(Greedy)</h2><p style=\"text-indent: 2em;\"><strong>贪心算法</strong>（<span>英语：<span>greedy algorithm</span></span>），又称<strong>贪婪算法</strong>，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95\" target=\"_blank\">算法</a>。比如在<a href=\"https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98\" target=\"_blank\">旅行推销员问题</a>中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。</p><p style=\"text-indent: 2em;\">贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #222222;\">贪心算法与</span><a href=\"https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\" target=\"_blank\">动态规划</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</span></p><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #222222;\">贪心法可以解决一些</span><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BC%98%E5%8C%96\" target=\"_blank\">最优化</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">问题，如：求</span><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE\" target=\"_blank\">图</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">中的</span><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91\" target=\"_blank\">最小生成树</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">、求</span><a href=\"https://zh.wikipedia.org/wiki/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81\" target=\"_blank\">哈夫曼编码</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。</span></p><h2 id=\"57049f2e\">排序(Sort)</h2><p style=\"text-indent: 2em;\">在<a href=\"https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8\" target=\"_blank\">计算机科学</a>与<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8\" target=\"_blank\">数学</a>中，一个<strong>排序算法</strong>（<span>英语：<span>Sorting algorithm</span></span>）是一种能将一串数据依照特定排序方式进行排列的一种<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95\" target=\"_blank\">算法</a>。最常用到的排序方式是数值顺序以及<a href=\"https://zh.wikipedia.org/wiki/%E5%AD%97%E5%85%B8%E9%A0%86%E5%BA%8F\" target=\"_blank\">字典顺序</a>。有效的排序算法在一些算法（例如<a href=\"https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E7%AE%97%E6%B3%95\" target=\"_blank\">搜索算法</a>与<span><a href=\"https://zh.wikipedia.org/w/index.php?title=%E5%90%88%E4%BD%B5%E7%AE%97%E6%B3%95&amp;action=edit&amp;redlink=1\" target=\"_blank\">合并算法</a></span>）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：</p><ol data-lake-indent=\"1\"><li>输出结果为递增序列（递增是针对所需的排序顺序而言）</li><li>输出结果是原输入的一种<a href=\"https://zh.wikipedia.org/wiki/%E6%8E%92%E5%88%97\" target=\"_blank\">排列</a>、或是重组</li></ol><p style=\"text-indent: 2em;\">虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，<a href=\"https://zh.wikipedia.org/wiki/%E6%B0%A3%E6%B3%A1%E6%8E%92%E5%BA%8F\" target=\"_blank\">冒泡排序</a>在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%8E%92%E5%BA%8F\" target=\"_blank\">图书馆排序</a>在2004年被发表）</p><h2 id=\"c4101bd6\">位运算(<span style=\"color: #333333; background-color: #F5F5F5;\">Bit Manipulation</span>)</h2><p style=\"text-indent: 2em;\"><strong>位操作</strong>是<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Algorithm&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhjMVi1RPGMBteOeVhr7rwyRqB0rpw\" target=\"_blank\">算法</a>操作比<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Word_(data_type)&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhjWJGcdyh6D0YqybOhRRrQm_q3weA\" target=\"_blank\">字</a>短的<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Bit&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhjEeYjDXtSE4aLD8IBpxGHOw7i1cw\" target=\"_blank\">位</a>或其他<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Data_(computing)&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhimJkNnf1ms2G_qzxH5ThHaFXOF3w\" target=\"_blank\">数据</a>的行为。 <span>需要位操作的<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Computer_programming&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhgBTJOhasH5dW1tnoxF67KIfvfLTg\" target=\"_blank\">计算机编程</a>任务包括低级设备控制， <a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Error_detection&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhgXOngDc_CmFhIvFAdYWlKuRmY5sA\" target=\"_blank\">错误检测</a>和<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Error_correction&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhiSkVgbuw44Uuoqt32JwsNGOtuw_g\" target=\"_blank\">纠正</a>算法， <a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Data_compression&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhgSFcXbh6AiHJgQKcqYVOpo_yxdxA\" target=\"_blank\">数据压缩</a> ， <a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Encryption&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhi9MtfS8E3BFR-z1u_riRNQ4gfERA\" target=\"_blank\">加密</a>算法和<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Optimization_(computer_science)&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhh_t9EuZt8FPWcE83nzA7-3KzopLw\" target=\"_blank\">优化</a> 。</span> <span>对于大多数其他任务，现代<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Programming_language&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhj2io6d_vRyulRfmd5Yfg6y-t0jwA\" target=\"_blank\">编程语言</a>允许<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Programmer&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhgf_SNoU3vDFByphd_Ho3Qo_cUX0w\" target=\"_blank\">程序员</a>直接使用<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Abstraction_(computer_science)&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhgsc5qtrh0_vT7zGYTWMCKDHxCcOA\" target=\"_blank\">抽象</a>而不是代表那些抽象的位。</span> <span>执行位操作的<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Source_code&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhj24xoEiLJDqG9xWG1lAWhEg3m9kw\" target=\"_blank\">源代码</a>使用<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Bitwise_operation&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhixv-Y0how8ovsYIKadV3hDvxPp_g\" target=\"_blank\">按位运算</a> ：AND，OR，XOR，NOT和<a href=\"https://translate.googleusercontent.com/translate_c?depth=1&amp;hl=zh-CN&amp;prev=search&amp;rurl=translate.google.com&amp;sl=en&amp;sp=nmt4&amp;u=https://en.wikipedia.org/wiki/Bitwise_operation&amp;xid=25657,15700021,15700186,15700190,15700248&amp;usg=ALkJrhixv-Y0how8ovsYIKadV3hDvxPp_g#Bit_shifts\" target=\"_blank\">位移</a> 。</span></p><p style=\"text-indent: 2em;\"><span>在某些情况下，位操作可以消除或减少循环数据结构的需要，并且可以提供多倍的加速，因为并行处理位操作，但代码可能变得更难以编写和维护。</span></p><h2 id=\"8fc5f20f\">树(Tree)</h2><p style=\"text-indent: 2em;\">在计算机科学中，<strong>树</strong>（<span>英语：<span>tree</span></span>）是一种<a href=\"https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5\" target=\"_blank\">抽象数据类型</a>（ADT）或是实现这种抽象数据类型的<a href=\"https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B\" target=\"_blank\">数据结构</a>，用来模拟具<a href=\"https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B\" target=\"_blank\">有树状结构</a>性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的<a href=\"https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88\" target=\"_blank\">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ul><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li><li>树里面没有环路(cycle)</li></ul><h2 id=\"a3eb0f11\">深度优先搜索(Depth-first Search)</h2><p style=\"text-indent: 2em;\"><strong>深度优先搜索算法</strong>（<span>英语：<span>Depth-First-Search</span></span>，<span>DFS</span>）是一种用于遍历或搜索<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\" target=\"_blank\">树</a>或<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)\" target=\"_blank\">图</a>的<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95\" target=\"_blank\">算法</a>。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p><p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应<a href=\"https://zh.wikipedia.org/wiki/%E6%8B%93%E6%89%91\" target=\"_blank\">拓扑</a>排序表，利用拓扑排序表可以方便的解决很多相关的<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA\" target=\"_blank\">图论</a>问题，如最大路径问题等等。</p><p style=\"text-indent: 2em;\">因发明“深度优先搜索算法”，<a href=\"https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E9%9C%8D%E6%99%AE%E5%85%8B%E6%B4%9B%E5%A4%AB%E7%89%B9\" target=\"_blank\">约翰·霍普克洛夫特</a>与<a href=\"https://zh.wikipedia.org/wiki/%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7%E5%A1%94%E6%89%AC\" target=\"_blank\">罗伯特·塔扬</a>在<a href=\"https://zh.wikipedia.org/wiki/1986%E5%B9%B4\" target=\"_blank\">1986年</a>共同获得计算机领域的最高奖：<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96\" target=\"_blank\">图灵奖</a>。</p><h2 id=\"fb878827\"><a href=\"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\" target=\"_blank\">广度优先搜索(Breadth-first Search)</a></h2><p style=\"text-indent: 2em;\"><strong>广度优先搜索算法</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">（</span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">英语：<span>Breadth-First-Search</span></span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">，缩写为BFS），又译作</span><strong>宽度优先搜索</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">，或</span><strong>横向优先搜索</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">，是一种</span><a href=\"https://zh.wikipedia.org/w/index.php?title=%E5%9C%96%E5%BD%A2%E6%90%9C%E7%B4%A2%E6%BC%94%E7%AE%97%E6%B3%95&amp;action=edit&amp;redlink=1\" target=\"_blank\">图形搜索算法</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">。简单的说，BFS是从</span><a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%A0%B9%E7%AF%80%E9%BB%9E&amp;action=edit&amp;redlink=1\" target=\"_blank\">根节点</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">开始，沿着树的宽度遍历树的</span><a href=\"https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9\" target=\"_blank\">节点</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。</span></p><h2 id=\"b5bb5ed5\"><a href=\"https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86\" target=\"_blank\">并查集(Union Find)</a></h2><p style=\"text-indent: 2em;\">在<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\">计算机科学</a>中，<strong>并查集</strong>是一种树型的<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" target=\"_blank\">数据结构</a>，用于处理一些<a href=\"https://zh.wikipedia.org/wiki/%E4%B8%8D%E4%BA%A4%E9%9B%86\" target=\"_blank\">不交集</a>（Disjoint Sets）的合并及查询问题。有一个<strong>联合-查找算法</strong>（<strong>union-find algorithm</strong>）定义了两个用于此数据结构的操作：</p><ul><li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li><li>Union：将两个子集合并成同一个集合。</li></ul><p style=\"text-indent: 2em;\">由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于创建单元素集合。有了这些方法，许多经典的<a href=\"https://zh.wikipedia.org/w/index.php?title=%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98&amp;action=edit&amp;redlink=1\" target=\"_blank\">划分问题</a>可以被解决。</p><p style=\"text-indent: 2em;\">为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，Find(x) 返回 x 所属集合的代表，而 Union 使用两个集合的代表作为参数。</p><h2 id=\"434123f3\">图(Graph)</h2><p><br /></p><h2 id=\"ddcbcb48\">设计(Design)</h2><p><br /></p><h2 id=\"e1863aeb\"><a href=\"https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F\" target=\"_blank\">拓扑排序(Topological Sort)</a></h2><p style=\"text-indent: 2em;\">在<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\">计算机科学</a>领域，有向图的拓扑排序是其顶点的线性排序，使得对于从顶点<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354123-46ab159b-38a0-46e3-a690-34e6b7709fdf.svg#align=left&amp;display=inline&amp;height=30&amp;linkTarget=_blank&amp;originHeight=15&amp;originWidth=12&amp;size=0&amp;width=24\" style=\"max-width: 600px; width: 24px;\" />到顶点<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354252-13693c10-18ce-497c-b9d7-779c170f2a8d.svg#align=left&amp;display=inline&amp;height=36&amp;linkTarget=_blank&amp;originHeight=15&amp;originWidth=10&amp;size=0&amp;width=24\" style=\"max-width: 600px; width: 24px;\" />的每个有向边<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354371-3ec1d5f3-0550-4402-9b94-1b4b8f3f0600.svg#align=left&amp;display=inline&amp;height=33&amp;linkTarget=_blank&amp;originHeight=15&amp;originWidth=22&amp;size=0&amp;width=48\" style=\"max-width: 600px; width: 48px;\" />，<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374355325-b27802fb-985e-4392-a5f1-8d6579ef3e54.svg#align=left&amp;display=inline&amp;height=30&amp;linkTarget=_blank&amp;originHeight=15&amp;originWidth=12&amp;size=0&amp;width=24\" style=\"max-width: 600px; width: 24px;\" />在排序中都在<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374354366-9481a9bd-90a4-404d-91c0-f7dade18d1bf.svg#align=left&amp;display=inline&amp;height=36&amp;linkTarget=_blank&amp;originHeight=15&amp;originWidth=10&amp;size=0&amp;width=24\" style=\"max-width: 600px; width: 24px;\" />之前。 例如，图形的顶点可以表示要执行的任务，并且边可以表示一个任务必须在另一个任务之前执行的约束; 在这个应用中，拓扑排序只是一个有效的任务顺序。 如果且仅当图形没有定向循环，即如果它是<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE\" target=\"_blank\">有向无环图</a>（<a href=\"https://zh.wikipedia.org/wiki/DAG\" target=\"_blank\">DAG</a>），则拓扑排序是可能的。 任何 DAG 具有至少一个拓扑排序，并且已知这些算法用于在线性时间内构建任何 DAG 的拓扑排序。</p><p>在<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA\" target=\"_blank\">图论</a>中，由一个<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE\" target=\"_blank\">有向无环图</a>的顶点组成的序列，当且仅当满足下列条件时，称为该<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE\" target=\"_blank\">图</a>的一个<strong>拓扑排序</strong>（<span>英语：<span>Topological sorting</span></span>）。</p><ol><li>每个顶点出现且只出现一次；</li><li>若A在序列中排在B的前面，则在图中不存在从B到A的<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%BE%84_(%E5%9B%BE%E8%AE%BA)\" target=\"_blank\">路径</a>。</li></ol><h2 id=\"a0134f8c\"><a href=\"https://zh.wikipedia.org/wik\\i/Trie\" target=\"_blank\">字典树(Trie)</a></h2><p style=\"text-indent: 2em;\">在<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\">计算机科学</a>中，<strong>trie</strong>，又称<strong>前缀树</strong>或<strong>字典树</strong>，是一种有序<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\" target=\"_blank\">树</a>，用于保存<a href=\"https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84\" target=\"_blank\">关联数组</a>，其中的键通常是<a href=\"https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2\" target=\"_blank\">字符串</a>。与<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91\" target=\"_blank\">二叉查找树</a>不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的<a href=\"https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80\" target=\"_blank\">前缀</a>，也就是这个节点对应的字符串，而根节点对应<a href=\"https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2\" target=\"_blank\">空字符串</a>。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><p style=\"text-indent: 2em;\">Trie这个术语来自于re<strong>trie</strong>val。根据<a href=\"https://zh.wikipedia.org/wiki/%E8%AF%8D%E6%BA%90%E5%AD%A6\" target=\"_blank\">词源学</a>，trie的发明者Edward Fredkin把它读作<span><a href=\"https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99\" target=\"_blank\">/<span>ˈ</span><span>t</span><span>r</span><span>iː</span>/</a></span> &quot;tree&quot;。但是，其他作者把它读作<span><a href=\"https://zh.wikipedia.org/wiki/Help:%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99\" target=\"_blank\">/<span>ˈ</span><span>t</span><span>r</span><span>aɪ</span>/</a></span> &quot;try&quot;。</p><p style=\"text-indent: 2em;\">在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie可以看作是一个<a href=\"https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA\" target=\"_blank\">确定有限状态自动机</a>，尽管边上的符号一般是隐含在分支的顺序中的。</p><p style=\"text-indent: 2em;\">键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示trie的原理。</p><p>trie中的键通常是字符串，但也可以是其它的结构。trie的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，<strong>bitwise trie</strong>中的键是一串比特，可以用于表示整数或者内存地址。</p><h2 id=\"af29efe9\"><a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84\" target=\"_blank\">树状数组(Binary Indexed Tree)</a></h2><p style=\"text-indent: 2em;\"><strong>树状数组</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">或</span><strong>二叉索引树</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">（</span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">英语：<span>Binary Indexed Tree</span></span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables</span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374511328-9fe02213-3e39-4b5b-acbe-fb59ee62ea6a.svg#align=left&amp;display=inline&amp;height=24&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=75&amp;size=0&amp;width=69\" style=\"max-width: 600px; width: 69px;\" />的时间得到任意前缀和<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374510664-f61df39c-15ae-4076-a405-b180719a51da.svg#align=left&amp;display=inline&amp;height=33&amp;linkTarget=_blank&amp;originHeight=66&amp;originWidth=199&amp;size=0&amp;width=100\" style=\"max-width: 600px; width: 100px;\" /></span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">，并同时支持在<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374511010-ea3ea917-e9c1-48cf-ada2-4093faacfddd.svg#align=left&amp;display=inline&amp;height=22&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=75&amp;size=0&amp;width=64\" style=\"max-width: 600px; width: 64px;\" /></span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">时间内支持动态单点值的修改。空间复杂度<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374511028-2d7e11b6-48e0-4e85-89dd-de13cc5a6a65.svg#align=left&amp;display=inline&amp;height=28&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=45&amp;size=0&amp;width=48\" style=\"max-width: 600px; width: 48px;\" /></span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">。</span></p><h2 id=\"d79af71c\"><a href=\"https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5%E6%A8%B9\" target=\"_blank\">线段树(Segment Tree)</a></h2><p style=\"text-indent: 2em;\"><strong>线段树</strong>（<span>英语：<span>Segment tree</span></span>）是一种<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9\" target=\"_blank\">二叉树</a>形数据结构，1977年由Jon Louis Bentley发明，用以存储<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%80%E9%96%93\" target=\"_blank\">区间</a>或<a href=\"https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5\" target=\"_blank\">线段</a>，并且允许快速查询结构内包含某一点的所有区间。</p><p style=\"text-indent: 2em;\">一个包含<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552076-e7d1c1d6-98c5-4322-a4f2-bb1bcc5a0d9f.svg#align=left&amp;display=inline&amp;height=28&amp;linkTarget=_blank&amp;originHeight=15&amp;originWidth=13&amp;size=0&amp;width=24\" style=\"max-width: 600px; width: 24px;\" />个区间的线段树，空间复杂度为<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552115-58a0f517-8c4f-42ae-9e70-96c81942fc07.svg#align=left&amp;display=inline&amp;height=28&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=45&amp;size=0&amp;width=48\" style=\"max-width: 600px; width: 48px;\" />，查询的时间复杂度则为</p><p style=\"text-indent: 2em;\"><img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552251-c509b348-c14d-4d64-9b3d-ead957b7bebf.svg#align=left&amp;display=inline&amp;height=22&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=111&amp;size=0&amp;width=96\" style=\"max-width: 600px; width: 96px;\" />，其中<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374552879-3eb804e1-b119-4942-a704-e087c6dffe63.svg#align=left&amp;display=inline&amp;height=44&amp;linkTarget=_blank&amp;originHeight=20&amp;originWidth=11&amp;size=0&amp;width=24\" style=\"max-width: 600px; width: 24px;\" /> 是匹配条件的区间数量。</p><p style=\"text-indent: 2em;\">此数据结构亦可推广到高维度。</p><h2 id=\"31ee0c82\"><a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9\" target=\"_blank\">二叉搜索树(Binary Search Tree)</a></h2><p style=\"text-indent: 2em;\"><strong>二叉查找树</strong>（<span>英语：<span>Binary Search Tree</span></span>），也称为<strong>二叉搜索树</strong>、<strong>有序二叉树</strong>（<span>ordered binary tree</span>）或<strong>排序二叉树</strong>（<span>sorted binary tree</span>），是指一棵空树或者具有下列性质的<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91\" target=\"_blank\">二叉树</a>：</p><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ol><p style=\"text-indent: 2em;\">二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374603713-e7614cde-5606-4f23-83b9-4ff54cf3550c.svg#align=left&amp;display=inline&amp;height=22&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=75&amp;size=0&amp;width=64\" style=\"max-width: 600px; width: 64px;\" />。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如<a href=\"https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)\" target=\"_blank\">集合</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E9%9B%86\" target=\"_blank\">多重集</a>、<a href=\"https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84\" target=\"_blank\">关联数组</a>等。</p><p style=\"text-indent: 2em;\">二叉查找树的查找过程和<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%AC%A1%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91&amp;action=edit&amp;redlink=1\" target=\"_blank\">次优二叉树</a>类似，通常采取二叉<a href=\"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8\" target=\"_blank\">链表</a>作为二叉查找树的<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" target=\"_blank\">存储结构</a>。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374604022-7033cee1-3f01-406d-ba64-a70801094f38.svg#align=left&amp;display=inline&amp;height=22&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=75&amp;size=0&amp;width=64\" style=\"max-width: 600px; width: 64px;\" />，最坏<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374602579-6fa796ae-ae43-4472-9023-95d85568de76.svg#align=left&amp;display=inline&amp;height=28&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=45&amp;size=0&amp;width=48\" style=\"max-width: 600px; width: 48px;\" />（数列有序，树退化成线性表）。</p><p style=\"text-indent: 2em;\">虽然二叉查找树的最坏效率是<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374602655-65e5154d-b982-4944-be46-c8d04d9e0f7f.svg#align=left&amp;display=inline&amp;height=28&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=45&amp;size=0&amp;width=48\" style=\"max-width: 600px; width: 48px;\" />,但它支持动态查询，且有很多改进版的二叉查找树可以使树高为<img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/svg/203310/1549374603172-e378edd1-985b-444d-8847-54100c89d8ee.svg#align=left&amp;display=inline&amp;height=22&amp;linkTarget=_blank&amp;originHeight=26&amp;originWidth=75&amp;size=0&amp;width=64\" style=\"max-width: 600px; width: 64px;\" />,如<a href=\"https://zh.wikipedia.org/w/index.php?title=SBT&amp;action=edit&amp;redlink=1\" target=\"_blank\">SBT</a>,<a href=\"https://zh.wikipedia.org/wiki/AVL%E6%A0%91\" target=\"_blank\">AVL树</a>，<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91\" target=\"_blank\">红黑树</a>等。故不失为一种好的动态查找方法。</p><h2 id=\"257a327a\"><a href=\"https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92\" target=\"_blank\">递归(Recursion)</a></h2><p style=\"text-indent: 2em;\"><strong>递归</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">（</span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">英语：<span>Recursion</span></span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">），又译为</span><strong>递回</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">，在</span><a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6\" target=\"_blank\">数学</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">与</span><a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\">计算机科学</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">中，是指在</span><a href=\"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0\" target=\"_blank\">函数</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">的定义中使用函数自身的方法。递归一词还较常用于描述以</span><a href=\"https://zh.wikipedia.org/wiki/%E8%87%AA%E7%9B%B8%E4%BC%BC\" target=\"_blank\">自相似</a><span class=\"lake-fontsize-11\" style=\"color: #222222;\">方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。</span></p><h2 id=\"5cd40043\">脑筋急转弯(Brainteaser)</h2><p><br /></p><h2 id=\"5e89c2be\">记忆化(Memoization)</h2><p style=\"text-indent: 2em;\">在<a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6\" target=\"_blank\">计算机科学</a>中，<strong>记忆化</strong>（英语：memoization而非memorization）是一种提高程序运行速度的优化技术。通过储存大计算量<a href=\"https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F\" target=\"_blank\">函数</a>的返回值，当这个结果再次被需要时将其从<a href=\"https://zh.wikipedia.org/wiki/%E7%BC%93%E5%AD%98\" target=\"_blank\">缓存</a>提取，而不用再次计算来节省计算时间。 </p><p>记忆化是一种典型的时间存储平衡方案。</p><h2 id=\"37a8d013\"><a href=\"https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97\" target=\"_blank\">队列(Queue)</a></h2><p style=\"text-indent: 2em;\"><strong>队列</strong>，又称为<strong>伫列</strong>（queue），是<a href=\"https://zh.wikipedia.org/wiki/%E5%85%88%E9%80%B2%E5%85%88%E5%87%BA\" target=\"_blank\">先进先出</a>（FIFO, First-In-First-Out）的<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8\" target=\"_blank\">线性表</a>。在具体应用中通常用<a href=\"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8\" target=\"_blank\">链表</a>或者<a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84\" target=\"_blank\">数组</a>来实现。队列只允许在后端（称为<em>rear</em>）进行插入操作，在前端（称为<em>front</em>）进行删除操作。</p><p style=\"text-indent: 2em;\">队列的操作方式和<a href=\"https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88\" target=\"_blank\">堆栈</a>类似，唯一的区别在于队列只允许新数据在后端进行添加。</p><h2 id=\"c4bbe1b2\"><a href=\"https://zh.wikipedia.org/wiki/%E6%9E%81%E5%B0%8F%E5%8C%96%E6%9E%81%E5%A4%A7%E7%AE%97%E6%B3%95\" target=\"_blank\">极小化极大(Minimax)</a></h2><p style=\"text-indent: 2em;\"><strong>Minimax算法</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">（亦称 </span><strong>MinMax</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\"> or </span><strong>MM</strong><span class=\"lake-fontsize-11\" style=\"color: #222222;\">）又名极小化极大算法，是一种找出失败的最大可能性中的最小值的算法。</span></p><h2 id=\"d24bd171\">蓄水池抽样(Reservoir Sampinh)</h2><p><br /></p><h2 id=\"Map\">Map</h2><p><br /></p><h2 id=\"38a66a69\">几何(Geometry)</h2><p><br /></p><h2 id=\"Rendom\">Rendom</h2><p><br /></p><h2 id=\"a19859a3\">Rejection Samping</h2><p><br /></p><h2 id=\"d17a0f0b\">参考</h2><p>以上内容均来自wikipedia</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-06T15:19:37.000Z",
    "deleted_at": null,
    "created_at": "2019-02-04T13:25:54.000Z",
    "updated_at": "2019-02-06T15:19:37.000Z",
    "published_at": "2019-02-06T15:19:37.000Z",
    "first_published_at": "2019-02-04T13:31:01.000Z",
    "word_count": 7438,
    "cover": null,
    "description": "categories: leetcode&lt;blockquote class=&quot;blockquote-center&quot;&gt;**据说维基的知识总结很优秀**&lt;/blockquote&gt;&lt;!-- more --&gt;前言若hexo有小bug或不舒服之处，...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1227105,
    "slug": "num_944",
    "title": "860. Lemonade Change",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 19,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-13T01:08:41.500Z",
      "updated_at": "2019-02-13T01:08:41.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n![860.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1549696398291-854a329e-11c0-4f90-9fa5-5c55e05dfaa1.png#align=left&display=inline&height=997&linkTarget=_blank&name=860.png&originHeight=997&originWidth=554&size=79027&width=554)<br /><!-- more -->\n## 题目描述\nAt a lemonade stand, each lemonade costs `$5`. <br />Customers are standing in a queue to buy from you, and order one at a time (in the order specified by `bills`).<br />Each customer will only buy one lemonade and pay with either a `$5`, `$10`, or `$20` bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.<br />Note that you don't have any change in hand at first.<br />Return `true` if and only if you can provide every customer with correct change.<br /> <br />**Example 1:**\n**Input: **[5,5,5,10,20]\n**Output: **true\n**Explanation: **\nFrom the first 3 customers, we collect three $5 bills in order.\nFrom the fourth customer, we collect a $10 bill and give back a $5.\nFrom the fifth customer, we give a $10 bill and a $5 bill.\nSince all customers got correct change, we output true.**Example 2:**\n**Input: **[5,5,10]\n**Output: **true**Example 3:**\n**Input: **[10,10]\n**Output: **false**Example 4:**\n**Input: **[5,5,10,10,20]\n**Output: **false\n**Explanation: **\nFrom the first two customers in order, we collect two $5 bills.\nFor the next two customers in order, we collect a $10 bill and give back a $5 bill.\nFor the last customer, we can't give change of $15 back because we only have two $10 bills.\nSince not every customer received correct change, the answer is false. <br />**Note:**\n* `0 <= bills.length <= 10000`\n* `bills[i]` will be either `5`, `10`, or `20`.\n## 参考代码\n\n```java\nclass Solution {\n    public boolean lemonadeChange(int[] bills) {\n        if (bills[0] != 5) {//若第一个不是5，则返回false\n            return false;\n        }\n        else {\n            int five = 1,ten = 0;\n            int length = bills.length;\n            for(int i = 1;i < length;i++) {//从第二个数据开始\n                if(bills[i] == 5) {\n                    five++;\n                }\n                else if(bills[i] == 10){\n                    if(five == 0) {\n                        return false;\n                    }\n                    else {//进行相应的加减\n                        five--;\n                        ten++;\n                    }\n                    \n                }\n                else {\n                    if(five == 0) {\n                        return false;\n                    }\n                    else if(ten != 0) {//10、5的情况\n                        five--;\n                        ten--;\n                    }\n                    else {\n                        if(five >= 3) {//5,5,5的情况\n                            five -= 3;\n                        }\n                        else {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n## 思路及总结\n感觉这个题目没有体现所谓贪心算法的思想，只是一些if else的语句，以及需要考虑一些边界问题。\n## 参考\n[https://www.smwenku.com/a/5bb2d3692b71770e645e1c2b/zh-cn/](https://www.smwenku.com/a/5bb2d3692b71770e645e1c2b/zh-cn/)\n",
    "body_draft": "categories: leetcode\n\n---\n![215.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548506060055-118e8488-7b24-4981-8a99-75880675fde5.png#align=left&display=inline&height=411&linkTarget=_blank&name=215.png&originHeight=806&originWidth=1464&size=153252&width=746)<br /><!-- more -->\n## 题目描述\n在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br />**示例 1:**\n**输入:** ```\n[3,2,1,5,6,4] 和\n```\n k = 2\n**输出:** 5**示例 2:**\n**输入:** ```\n[3,2,3,1,2,4,5,5,6] 和\n```\n k = 4\n**输出:** 4**说明:**<br />你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n## 参考代码\n\n```java\nclass Solution {\n   public static int findKthLargest(int[] nums, int k) {\n\t\tPriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n       for(int num :nums) {\n           priorityQueue.add(num);\n           if(priorityQueue.size() > k) {\n               priorityQueue.poll();\n           }\n       }\n       return priorityQueue.peek();\n   }\n}\n```\n\n## 思路及总结\n主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。\n## 参考\n[https://www.kancloud.cn/maliming/leetcode/844880](https://www.kancloud.cn/maliming/leetcode/844880)\n",
    "body_html": "<p>categories: leetcode</p><p><br /></p><hr /><p><img alt=\"860.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1549696398291-854a329e-11c0-4f90-9fa5-5c55e05dfaa1.png#align=left&amp;display=inline&amp;height=997&amp;linkTarget=_blank&amp;name=860.png&amp;originHeight=997&amp;originWidth=554&amp;size=79027&amp;width=554\" style=\"max-width: 600px; width: 554px;\" /></p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>At a lemonade stand, each lemonade costs <code>$5</code>. </p><p>Customers are standing in a queue to buy from you, and order one at a time (in the order specified by <code>bills</code>).</p><p>Each customer will only buy one lemonade and pay with either a <code>$5</code>, <code>$10</code>, or <code>$20</code> bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.</p><p>Note that you don't have any change in hand at first.</p><p>Return <code>true</code> if and only if you can provide every customer with correct change.</p><p> </p><p><strong>Example 1:</strong></p><pre><strong>Input: </strong><span>[5,5,5,10,20]</span>\n<strong>Output: </strong><span>true</span>\n<strong>Explanation: </strong>\nFrom the first 3 customers, we collect three $5 bills in order.\nFrom the fourth customer, we collect a $10 bill and give back a $5.\nFrom the fifth customer, we give a $10 bill and a $5 bill.\nSince all customers got correct change, we output true.</pre><p><strong>Example 2:</strong></p><pre><strong>Input: </strong><span>[5,5,10]</span>\n<strong>Output: </strong><span>true</span></pre><p><strong>Example 3:</strong></p><pre><strong>Input: </strong><span>[10,10]</span>\n<strong>Output: </strong><span>false</span></pre><p><strong>Example 4:</strong></p><pre><strong>Input: </strong><span>[5,5,10,10,20]</span>\n<strong>Output: </strong><span>false</span>\n<strong>Explanation: </strong>\nFrom the first two customers in order, we collect two $5 bills.\nFor the next two customers in order, we collect a $10 bill and give back a $5 bill.\nFor the last customer, we can't give change of $15 back because we only have two $10 bills.\nSince not every customer received correct change, the answer is false.</pre><p> </p><p><strong><span>Note:</span></strong></p><ul><li><code>0 &lt;= bills.length &lt;= 10000</code></li><li><code>bills[i]</code> will be either <code>5</code>, <code>10</code>, or <code>20</code>.</li></ul><h2 id=\"36967e2c\"><span>参考代码</span></h2><p><br /></p><pre data-lang=\"java\"><code>class Solution {\n    public boolean lemonadeChange(int[] bills) {\n        if (bills[0] != 5) {//若第一个不是5，则返回false\n            return false;\n        }\n        else {\n            int five = 1,ten = 0;\n            int length = bills.length;\n            for(int i = 1;i &lt; length;i++) {//从第二个数据开始\n                if(bills[i] == 5) {\n                    five++;\n                }\n                else if(bills[i] == 10){\n                    if(five == 0) {\n                        return false;\n                    }\n                    else {//进行相应的加减\n                        five--;\n                        ten++;\n                    }\n                    \n                }\n                else {\n                    if(five == 0) {\n                        return false;\n                    }\n                    else if(ten != 0) {//10、5的情况\n                        five--;\n                        ten--;\n                    }\n                    else {\n                        if(five &gt;= 3) {//5,5,5的情况\n                            five -= 3;\n                        }\n                        else {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}</code></pre><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p style=\"text-indent: 2em;\">感觉这个题目没有体现所谓贪心算法的思想，只是一些if else的语句，以及需要考虑一些边界问题。</p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://www.smwenku.com/a/5bb2d3692b71770e645e1c2b/zh-cn/\" target=\"_blank\">https://www.smwenku.com/a/5bb2d3692b71770e645e1c2b/zh-cn/</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-09T07:16:11.000Z",
    "deleted_at": null,
    "created_at": "2019-02-03T15:30:32.000Z",
    "updated_at": "2019-02-09T07:16:11.000Z",
    "published_at": "2019-02-09T07:16:11.000Z",
    "first_published_at": "2019-02-03T15:31:01.000Z",
    "word_count": 446,
    "cover": null,
    "description": "categories: leetcode&lt;!-- more --&gt;题目描述At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you, and orde...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1225638,
    "slug": "linux_learning6",
    "title": "Linux学习6",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 19,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-13T01:08:41.500Z",
      "updated_at": "2019-02-13T01:08:41.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Linux\n\n---\n\n<blockquote class=\"blockquote-center\">**文件和目录属性**</blockquote><br /><!-- more -->\n\n>       编译：peida     \n>       链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html\n\n# Linux目录结构\n## 概述\n对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学号Linux的至关重要的一步，深入了解Linux文件目录结构的标准和每个目录的详细功能，对于我们用好Linux系统至关重要，下面我们就开始了解Linux目录结构的相关知识。<br />当在使用Linux的时候，如果您通过ls -l/ 就会发现，在/下包含很多的目录，比如etc、usr、var、bin...等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就像树形结构，所以我们可以把文件新系统的结构形象称为树形结构。<br />文件系统是用力啊组织和排列文件存取的，所以他是可见的，在Linux中，我们可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/起始的树形结构。Linux文件系统的最顶端是/，我们称/为Linux的root，也就是Linux操作系统的文件系统。Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是上级的领导者。<br />由于Linux是开放源代码，各大公司和团体根据Linux的核心代码做各自的操作，编程。这样就造成在根下的目录的不同。这样就造成个人不能使用他人的linux系统的pc。因为你根本不知道一些基本的配置，文件在哪里。。这就造成了混乱。这就是FHS(Filesystem Hierarchy Standard )机构诞生对的原因。该机构是Linux爱好者自发组成的一个团体，主要是对Linux做一些基本的要求，不至于是操作者换一台主机就成了Linux的“文盲”。<br />根据FHS (http://www.pathname.com/fhs/) 的官方文件指出，他们的主要目的是希望让使用者可以了解发哦已安装软件通常放置于哪个目录下，所以他们希望独立的软件开发上、操作系统制作者、以及想要维护系统的用户，都能遵循FHS的标准。也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。这样做的好处非常多，因为Linux操作系统就能够与在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。<br />事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动，而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样：\n\n|  | **可分享的(shareable)** | **不可分享的(unshareable)** |\n| --- | --- | --- |\n| **不变的(static)** | /usr (软件放置处) | /etc (配置文件) |\n|  | /opt (第三方协力软件) | /boot (开机与核心档) |\n| **可变动的(variable)** | /var/mail (使用者邮件信箱) | /var/run (程序相关) |\n|  | /var/spool/news (新闻组) | /var/lock (程序相关) |\n\n 四种类型\n### 可分享的\n可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；\n### 不可分享的\n自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。\n### 不变的\n有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；\n### 可变动的\n经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。<br />事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：<br />/(root，根目录)：与开机系统有关<br />/usr (unix software resource)：与软件安装/执行有关；<br />/var (variable)：与系统运作过程有关。\n## 根目录(/)的意义与内容\n根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。<br />因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。**说白了，就是根目录和Windows的C盘一个样。**<br />根据以上原因，FHS认为根目录(/)下应该包含如下子目录：\n\n| **目录** | **应放置档案内容** |\n| --- | --- |\n| /bin | 系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,[chmod(修改权限)](http://hi.baidu.com/haifengjava/blog/item/e540a894c0f36a1bd21b70d1.html), chown, date, mv, mkdir, cp, bash等等常用的指令。 |\n| /boot | 主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 |\n| /dev | 在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等 |\n| /etc | 系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop<br />/etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。<br />/etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 |\n| /home | 这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： <br />~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 |\n| /lib | 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 |\n| /media | media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 |\n| /mnt | 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 |\n| /opt | 这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。 |\n| /root | 系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。 |\n| /sbin | Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 |\n| /srv | srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。 |\n| /tmp | 这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 |\n\n事实上FHS针对根目录所定义的标准就仅限与上表，不过仍旧有些目录也需要我们了解一下，具体如下：\n\n| **目录** | **应放置文件内容** |\n| --- | --- |\n| /lost+found | 这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found |\n| /proc | 这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ |\n| /sys | 这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 |\n\n除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录户被挂载，其他跟去则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录，就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些：<br />/etc：配置文件<br />/bin：重要执行档<br />/dev：所需要的装置文件<br />/lib：执行档所需的函式库与核心所需的模块<br />/sbin：重要的系统执行文件<br />这五个目录千万不可与根目录分开在不同的分区。请背下来啊。 \n## /usr的意义与内容\n依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)，如果你知道如何透过网络进行分区的挂载（例如在服务器篇会谈到的NFS服务器），那么/usr确实可以分享给局域网络内的其他主机来使用喔。<br />/usr不是user的缩写，其实usr是Unix Software Resource的缩写，也就是Unix操作系统软件资源放置的目录，而不是用户的数据啦。这点要注意。FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。<br />因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows系统的C:\\Windows\\ + C:\\Program files\\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，/usr的次目录建议有底下这些：\n\n| **目录** | **应放置文件内容** |\n| --- | --- |\n| /usr/X11R6/  | 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。  |\n| /usr/bin/  | 绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关)  |\n| /usr/include/  | c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。  |\n| /usr/lib/  | 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生  |\n| /usr/local/  | 统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib...的次目录  |\n| /usr/sbin/  | 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)  |\n| /usr/share/  | 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件<br />/usr/share/doc：软件杂项的文件说明<br />/usr/share/zoneinfo：与时区有关的时区文件 |\n| /usr/src/  | 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。  |\n\n## /var的意义与内容\n如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：\n\n| **目录** | **应放置文件内容** |\n| --- | --- |\n| /var/cache/ | 应用程序本身运作过程中会产生的一些暂存档 |\n| /var/lib/ | 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 |\n| /var/lock/ | 某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 |\n| /var/log/ | 非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 |\n| /var/mail/ | 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 |\n| /var/run/ | 某些程序或者是服务启动后，会将他们的PID放置在这个目录下 |\n| /var/spool/ | 这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用 |\n\n由于FHS仅是定义出最上层(/)及次层(/usr,/var)的目录内容应该要放置的文件或目录数据，因此，在其他次目录层级内，就可以随开发者自行来配置了。\n## 目录树**(directory tree)** **:**\n在Linux底下，所有文件与目录都是由根目录开始的。那是所有目录与文件的源头，然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directoty tree)，这个目录的主要特性有：<br />目录树的起始点为根目录(/，root)；<br />每一个目录不止能使用本地端的partition的文件系统，也可以使用网络上的filesystem。举例来说，可以利用Network File System(NFS)服务器挂载某特定目录等。<br />每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。<br />如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1549101208779-3e78a392-e781-434d-bb01-588504ab5836.png#align=left&display=inline&height=432&linkTarget=_blank&name=image.png&originHeight=432&originWidth=488&size=57239&width=488)\n## 绝对路径和相对路径\n除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名的写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。这两种文件名/路径的写法依据是这样的：<br />**绝对路径：**<br />由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；<br />**相对路径：**<br />相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 http://www.cnblogs.com/home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法<br />而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？<br />cd /var/log   (absolute)<br />cd ../var/log (relative)<br />因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：<br />.  ：代表当前的目录，也可以使用 ./ 来表示；<br />.. ：代表上一层目录，也可以 ../ 来代表。<br />这个.与..目录概念是很重要的，你常常会看到cd ..或./command 之类的指令下达方式，就是代表上一层与目前所在目录的工作状态。\n## 实例\n网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？<br />由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin,/usr/bin等为正规),此时要执行指令就要严格指定该执行档。./代表某目录的意思，所以./run.sh代表执行本目录下，名为run.sh的文件。\n\n# Linux文件类型与扩展名\n## 概述\nLinux文件类型和Linux文件的文件名所代表的意义是两个不同的概念。我们通过一般应用程序而创建的比如file.txt、file.tar.gz，这些文件虽然要用不同的程序来打开，但放在Linux文件类型中衡量的话，大多是常规文件（也被称为普通文件）。\n## 文件类型\nLinux文件类型常见的有：普通文件、目录文件、字符设备文件和块设备文件、符号链接文件等，现在我们进行一个简要的说明。\n### 普通文件\n我们用ls -lh来查看某个文件的属性，可以看到有类似-rwxrwxrwx，值得注意的是第一个符号是-，这样的文件在Linux中就是普通文件。这些文件一般使用一些相关的应用程序创建，比如图像工具、文档工具、归档工具...或cp工具等。这类文件的删除方式是用rm命令。另外，依照文件的内容，有大略可以分为：\n#### 纯文本档(ASCII):\n这是Linux系统中最多的一种文件类型，称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。<br />几乎只要我们可以用来做为设定的文件都属于这一种文件类型。举例来说，你可以用命令：cat ~/.bashrc看到该文件的内容。(cat是将一个文件内容读出来的指令)。\n#### 二进制文件(binary)：\nLinux系统其实仅认识切可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts,文字型批处理文件不算)就是这种格式的文件。刚刚使用的cat命令就是一个binary file。\n#### 数据格式文件(data)：\n有些程序在运作的过程中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件(data file)。举例来说，我们的Linux在使用者登录时，都会精登录的数据记录在/var/log/wtmp那个文件内，该文件是一个data file，他能够透过last这个指令读出来！但是使用cat时，会读出乱码~因为贪睡属于一种特殊格式的文件\n### 目录文件\n当我们在某个目录下执行，看到有类似drwxr-xr-x，这样的文件就是目录，目录在Linux是一个比较特殊的文件。注意它的第一个字符是d。创建目录的命令可以用mkdir命令，或cp命令，cp可以把一个目录复制为另一份目录。删除用rm或rmdir命令。\n### 字符设备或块设备文件\n如果你进入/dev目录，列一下文件，会看到类似如下的:<br />[root@localhost ~]# ls -al /dev/tty<br />crw-rw-rw- 1 root tty 5, 0 11-03 15:11 /dev/tty<br />[root@localhost ~]# ls -la /dev/sda1<br />brw-r----- 1 root disk 8, 1 11-03 07:11 /dev/sda1<br />我们看到/dev/tty的属性是crw-rw-rw-,注意前面第一个字符是c，这表示字符设备文件。比如猫等串口设备。我们看到/dev/sdal 的属性是brw-r----，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备。<br />这个种类的文件，使用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。<br />与系统周边及存储相关的一些文件，通常都集中在/dev这个目录之下通常又分成两种：\n#### 区块**(block)**设备档\n就是一些存储数据，以提供系统随机存取的接口设备，举例来说，硬盘与软盘等就是啦。你可以随机的在硬盘的不同区块读写，这种装置就是成组设备！你可以自行查一下/dev/sda看看，会发现第一个属性为 [b] ！\n#### 字符**(character)**设备文件\n亦即是一些串行端口的接口设备，例如键盘、鼠标等等！这些设备的特设就是一次性读取的，不能够结算输出。举例来说，你不可能让鼠标调到另一个画面，而是滑动到另一个地方！第一个属性为[c]。\n### 数据接口文件(sockets)：\n数据接口问文件(或者：套接口文件)，这种类型的文件通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求，而客户端就可以透过这个socket来进行数据的沟通了。第一个数次那个为[s]，最常在/var/run这个目录中看到这种文件类型了。<br />例如：当我们启动MySQL服务器时，会产生一个mysql.sock的文件。<br />[root@localhost ~]# ls -lh /var/lib/mysql/mysql.sock <br />srwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock<br />注意这个文件的属性的第一个字符是s。\n### 符号链接文件：\n当我们查看文件属性时，会看到有类似lrwxrwxrwx,注意第一个字符是l，这类文件是链接文件。是通过ln -s源文件名 新文件名。上面是一个例子，表示setup.log是instal.log的软链接文件。怎么理解呢？这和Windows操作系统中的快捷方式有点相似。<br />符号链接文件的创建方法举例：<br />[root@localhost test]# ls -lh log2012.log<br />-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log<br />[root@localhost test]# ln -s log2012.log  linklog.log<br />[root@localhost test]# ls -lh *.log<br />lrwxrwxrwx 1 root root   11 11-22 06:58 linklog.log -> log2012.log<br />-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log\n### 数据输送文件(FIFO，pipe):\nFIFO也是一种特殊的文件了类型，他主要的目的在解决多个程序同时存取一个问价所造成的错误问题。FIFO是first-in-first-out的缩写。第一个属性为[p]。\n## Linux文件扩展名\n### 扩展名类型\n基本上，Linux的文件是没有所谓的扩展名的，一个Linux文件能不能被执行，与他的第一栏的是个属性有关，与档名根本一点关系也没有。这个观念和Windows的情况不相同。在Windows底下，能被执行的文件扩展名通常是.com,.exe,.bat等等。而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ]即代表这个文件可以被执行。<br />不过，可以被执行根可以执行成功破那个是不一样的，举例来说，在root/home 目录下的install.log 是一个纯文本档，如果经由修改权限成为 -rwxrwxrwx 后，这个问价能够真的执行成功吗？当然就要看该文件的内容。<br />虽然如此，不过我们任然希望可以藉由扩展名来了解该文件是什么东西，所以，通常我么还是会以适当的扩展名表示该文件是什么种类的。底下有数种常用的扩展名：<br />*.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh<br />*Z, *.tar, *.tar.gz, *.zip, *.tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！<br />*.html, *.php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件。 .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果。    <br />基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件 ，如常用的/bin/ls这个显示文件属性的指令，不过，如果这个问价的权限被修改为无法执行时，那么ls就变成不能执行。<br />上述的这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的Linux系统中就是无法执行！呵呵！那么就是可能文件的属性被改变了。不要怀疑，从网络上床送到你的Linux系统中，文件的属性与权限确实是会被改变的。\n### Linux文件名长度限制\n在Linux底下，使用预设的Ext2/Ext3文件系统时，针对文件名长度限制为：<br />单一文件或目录的最大容许文件名为 255 个字符<br />包含完整路径名称及目录 (/) 之完整档名为 4096 个字符<br />是相当长的档名！我们希望Linux的文件名可以一看就知道该文件在干嘛的， 所以档名通常是很长很长。\n### Linux文件名的字符的限制\n由于Linux在文字接口下的一些指令操作关系，一般来说，你在设定Linux底下的文件名时， 最好可以避免一些特殊字符比较好！例如底下这些：<br />* ? > < ; & ! [ ] | \\ ' \" ` ( ) { }<br />因为这些符号在文字接口下，是有特殊意义的。另外，文件名的开头为小数点“.”时， 代表这个文件为隐藏文件！同时，由于指令下达当中，常常会使用到 -option 之类的选项， 所以你最好也避免将文件档名的开头以 - 或 + 来命名。\n\n# Linux文件属性详解\n## 概述\nLinux文件或目录的属性主要包括：文件或目录的节点、种类、权限模式、链接数量、所归属的用户和用户组、最近访问或修改的时间等内容。具体情况如下：<br />**命令：** <br />ls -lih<br />**输出：**<br />[root@localhost test]# ls -lih<br />总计 316K<br />2095120 lrwxrwxrwx 1 root root   11 11-22 06:58 linklog.log -> log2012.log<br />2095112 -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log<br />2095110 -rw-r--r-- 1 root root   61 11-13 06:03 log2013.log<br />2095107 -rw-r--r-- 1 root root    0 11-13 06:03 log2014.log<br />2095117 -rw-r--r-- 1 root root    0 11-13 06:06 log2015.log<br />2095118 -rw-r--r-- 1 root root    0 11-16 14:41 log2016.log<br />2095119 -rw-r--r-- 1 root root    0 11-16 14:43 log2017.log<br />2095113 drwxr-xr-x 6 root root 4.0K 10-27 01:58 scf<br />2095109 drwxrwxr-x 2 root root 4.0K 11-13 06:08 test3<br />2095131 drwxrwxr-x 2 root root 4.0K 11-13 05:50 test4<br />**说明：**<br />第一列：inode<br />第二列：文件种类和权限；<br />第三列： 硬链接个数；<br />第四列： 属主；<br />第五列：所归属的组；<br />第六列：文件或目录的大小；<br />第七列和第八列：最后访问或修改时间；<br />第九列：文件名或目录名<br />我们以log2012.log为例：<br />2095112 -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log<br />inode 的值是：2095112 <br />文件类型：文件类型是-，表示这是一个普通文件； 关于文件的类型，请参考：[每天一个linux命令(24)：Linux文件类型与扩展名](http://www.cnblogs.com/peida/archive/2012/11/22/2781912.html) <br />文件权限：文件权限是rw-r--r-- ，表示文件属主可读、可写、不可执行，文件所归属的用户组不可写，可读，不可执行，其它用户不可写，可读，不可执行；<br />硬链接个数： log2012.log这个文件没有硬链接；因为数值是1，就是他本身；<br />文件属主：也就是这个文件归哪于哪个用户 ，它归于root，也就是第一个root；<br />文件属组：也就是说，对于这个文件，它归属于哪个用户组，在这里是root用户组；<br />文件大小：文件大小是296k个字节；<br />访问可修改时间 ：这里的时间是最后访问的时间，最后访问和文件被修改或创建的时间，有时并不是一致的；<br />当然文档的属性不仅仅包括这些，这些是我们最常用的一些属性。\n## 关于inode\ninode 译成中文就是索引节点。每个存储设备或存储设备的分区(存储设备是硬盘、软盘、u盘等等)被格式化为文件系统后，应该有两部分，一部分是inode，另一部分是Block，Block是用来存储数据用的。而inode为每个文件进行信息索引，所以就有了inode的数值。操作系统根据指令，能通过inode值最快的找到相对应的文件。<br />做个比喻，比如一本书，存储设备或跟去就相当于这本书，Block相当于书中的每一页，inode 就相当与这本书前面的目录，一本书有很多的内容，如果想查找某部分的内容，我们可以先查目录，通过目录能最快的找到我们想要看的内容。虽然不太恰当，但还是比较形象。<br />当我们用ls查看某个目录或文件时，如果加上-i参数，就可以看到inode节点了，比如我们前面所说的例子：<br />[root@localhost test]#  ls -li log2012.log <br />2095112 -rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log<br />log2012.log 的inode值是 2095112 ； 查看一个文件或目录的inode，要通过ls 命令的的 -i参数。\n\n>       编译：peida     \n>       链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html\n\n",
    "body_draft": "",
    "body_html": "<p>categories: Linux</p><p><br /></p><hr /><p><br /></p><p>&lt;blockquote class=&quot;blockquote-center&quot;&gt;**文件和目录属性**&lt;/blockquote&gt;</p><p>&lt;!-- more --&gt;</p><p><br /></p><blockquote style=\"padding-left: 1em;\"><p>      编译：peida     </p><p>      链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html</p></blockquote><h1 id=\"90bc5752\">Linux目录结构</h1><h2 id=\"a4d3b02a\">概述</h2><p style=\"text-indent: 2em;\">对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学号Linux的至关重要的一步，深入了解Linux文件目录结构的标准和每个目录的详细功能，对于我们用好Linux系统至关重要，下面我们就开始了解Linux目录结构的相关知识。</p><p style=\"text-indent: 2em;\">当在使用Linux的时候，如果您通过ls -l/ 就会发现，在/下包含很多的目录，比如etc、usr、var、bin...等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就像树形结构，所以我们可以把文件新系统的结构形象称为树形结构。</p><p style=\"text-indent: 2em;\">文件系统是用力啊组织和排列文件存取的，所以他是可见的，在Linux中，我们可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/起始的树形结构。Linux文件系统的最顶端是/，我们称/为Linux的root，也就是Linux操作系统的文件系统。Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是上级的领导者。</p><p style=\"text-indent: 2em;\">由于Linux是开放源代码，各大公司和团体根据Linux的核心代码做各自的操作，编程。这样就造成在根下的目录的不同。这样就造成个人不能使用他人的linux系统的pc。因为你根本不知道一些基本的配置，文件在哪里。。这就造成了混乱。这就是FHS(Filesystem Hierarchy Standard )机构诞生对的原因。该机构是Linux爱好者自发组成的一个团体，主要是对Linux做一些基本的要求，不至于是操作者换一台主机就成了Linux的“文盲”。</p><p style=\"text-indent: 2em;\">根据FHS (<span style=\"color: #333333;\">http://www.pathname.com/fhs/</span>) 的官方文件指出，他们的主要目的是希望让使用者可以了解发哦已安装软件通常放置于哪个目录下，所以他们希望独立的软件开发上、操作系统制作者、以及想要维护系统的用户，都能遵循FHS的标准。也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。这样做的好处非常多，因为Linux操作系统就能够与在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。</p><p style=\"text-indent: 2em;\">事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动，而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样：</p><table class=\"lake-table\" style=\"width: 721px;\"><colgroup><col width=\"240\"></col><col width=\"240\"></col><col width=\"240\"></col></colgroup><tbody><tr><td></td><td><p style=\"text-align: center;\"><strong>可分享的(shareable)</strong></p></td><td><p style=\"text-align: center;\"><strong>不可分享的(unshareable)</strong></p></td></tr><tr><td rowspan=\"2\"><p style=\"text-align: center;\"><strong>不变的(static)</strong></p></td><td><p><span>/usr (软件放置处)</span></p></td><td><p><span>/etc (配置文件)</span></p></td></tr><tr><td><p><span>/opt (第三方协力软件)</span></p></td><td><p><span>/boot (开机与核心档)</span></p></td></tr><tr><td rowspan=\"2\"><p style=\"text-align: center;\"><strong>可变动的(variable)</strong></p></td><td><p><span>/var/mail (使用者邮件信箱)</span></p></td><td><p><span>/var/run (程序相关)</span></p></td></tr><tr><td><p><span>/var/spool/news (新闻组)</span></p></td><td><p><span>/var/lock (程序相关)</span></p></td></tr></tbody></table><p> 四种类型</p><h3 id=\"df522997\">可分享的</h3><p>可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；</p><h3 id=\"8cd644fe\">不可分享的</h3><p>自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。</p><h3 id=\"bb2dbf8b\">不变的</h3><p>有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；</p><h3 id=\"80cce4dd\">可变动的</h3><p>经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</p><p>事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：</p><p>/(root，根目录)：与开机系统有关</p><p>/usr (unix software resource)：与软件安装/执行有关；</p><p>/var (variable)：与系统运作过程有关。</p><h2 id=\"92a2977a\">根目录(/)的意义与内容</h2><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。</span><strong>说白了，就是根目录和Windows的C盘一个样</strong><strong>。</strong></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">根据以上原因，FHS认为根目录(/)下应该包含如下子目录：</span></p><table class=\"lake-table\" style=\"width: 721px;\"><colgroup><col width=\"360\"></col><col width=\"360\"></col></colgroup><tbody><tr><td><p><strong>目录</strong></p></td><td><p style=\"text-align: center;\"><strong>应放置档案内容</strong></p></td></tr><tr><td><p><span>/bin</span></p></td><td><p><span>系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,</span><span><a href=\"http://hi.baidu.com/haifengjava/blog/item/e540a894c0f36a1bd21b70d1.html\">chmod(修改权限)</a></span>, chown, date, mv, mkdir, cp, bash等等常用的指令。</p></td></tr><tr><td><p><span>/boot</span></p></td><td><p><span>主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录</span><span>。</span></p></td></tr><tr><td><p><span>/dev</span></p></td><td><p><span>在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等</span></p></td></tr><tr><td><p><span>/etc</span></p></td><td><p><span>系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop</span></p><p><span>/etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。</span></p><p><span>/etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。</span></p></td></tr><tr><td><p><span>/home</span></p></td><td><p><span>这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： </span><span><br /></span><span>~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录</span><span>。</span></p></td></tr><tr><td><p><span>/lib</span></p></td><td><p><span>系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)</span><span>。</span></p></td></tr><tr><td><p><span>/media</span></p></td><td><p><span>media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置</span><span>。</span><span> 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。</span></p></td></tr><tr><td><p><span>/mnt</span></p></td><td><p><span>如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦</span><span>。</span><span> 只是有了/media之后，这个目录就用来暂时挂载用了。</span></p></td></tr><tr><td><p><span>/opt</span></p></td><td><p><span>这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下</span><span>。</span></p></td></tr><tr><td><p><span>/root</span></p></td><td><p><span>系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。</span></p></td></tr><tr><td><p><span>/sbin</span></p></td><td><p><span>Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。</span></p></td></tr><tr><td><p><span>/srv</span></p></td><td><p><span>srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。</span></p></td></tr><tr><td><p><span>/tmp</span></p></td><td><p><span>这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊</span><span>。</span><span> 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除</span><span>。</span></p></td></tr></tbody></table><p>事实上FHS针对根目录所定义的标准就仅限与上表，不过仍旧有些目录也需要我们了解一下，具体如下：</p><table class=\"lake-table\" style=\"width: 721px;\"><colgroup><col width=\"360\"></col><col width=\"360\"></col></colgroup><tbody><tr><td><p><strong>目录</strong></p></td><td><p style=\"text-align: center;\"><strong>应放置文件内容</strong></p></td></tr><tr><td><p><span>/lost+found</span></p></td><td><p><span>这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found</span></p></td></tr><tr><td><p><span>/proc</span></p></td><td><p><span>这个目录本身是一个虚拟文件系统(virtual filesystem)喔</span><span>。</span><span> 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间</span><span>。</span><span>比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？</span></p></td></tr><tr><td><p><span>/sys</span></p></td><td><p><span>这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量</span><span>。</span></p></td></tr></tbody></table><p>除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录户被挂载，其他跟去则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录，就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些：</p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">/etc：配置文件</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">/bin：重要执行档</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">/dev：所需要的装置文件</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">/lib：执行档所需的函式库与核心所需的模块</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">/sbin：重要的系统执行文件</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">这五个目录千万不可与根目录分开在不同的分区</span><span class=\"lake-fontsize-10\">。</span><span class=\"lake-fontsize-10\">请背下来啊</span><span class=\"lake-fontsize-10\">。</span> </p><h2 id=\"c70f6ec8\">/usr的意义与内容</h2><p style=\"text-indent: 2em;\">依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的<span style=\"color: #333333;\">(shareable, static)，如果你知道如何透过网络进行分区的挂载（例如在服务器篇会谈到的NFS服务器），那么/usr确实可以分享给局域网络内的其他主机来使用喔。</span></p><p style=\"text-indent: 2em;\"><span style=\"color: #333333;\">/usr不是user的缩写，其实usr是Unix Software Resource的缩写，也就是Unix操作系统软件资源放置的目录，而不是用户的数据啦。这点要注意。FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</span></p><p style=\"text-indent: 2em;\"><span style=\"color: #333333;\">因为是所有系统默认的软件(<span style=\"color: #333333;\">distribution发布者提供的软件</span>)都会放置到/usr底下，因此这个目录有点类似Windows系统的<span style=\"color: #333333;\">C:\\Windows\\ + C:\\Program files\\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，/usr的次目录建议有底下这些：</span></span></p><table class=\"lake-table\" style=\"width: 721px;\"><colgroup><col width=\"360\"></col><col width=\"360\"></col></colgroup><tbody><tr><td><p><strong>目录</strong></p></td><td><p style=\"text-align: center;\"><strong>应放置文件内容</strong></p></td></tr><tr><td><p><span>/usr/X11R6/</span> </p></td><td><p><span>为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。</span> </p></td></tr><tr><td><p><span>/usr/bin/</span> </p></td><td><p><span>绝大部分的用户可使用指令都放在这里</span><span>。</span><span>请注意到他与/bin的不同之处。(是否与开机过程有关)</span> </p></td></tr><tr><td><p><span>/usr/include/</span> </p></td><td><p><span>c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档</span><span>。</span> </p></td></tr><tr><td><p><span>/usr/lib/</span> </p></td><td><p><span>包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生</span> </p></td></tr><tr><td><p><span>/usr/local/</span> </p></td><td><p><span>统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦</span><span>。</span><span> 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib...的次目录</span> </p></td></tr><tr><td><p><span>/usr/sbin/</span> </p></td><td><p><span>非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)</span> </p></td></tr><tr><td><p><span>/usr/share/</span> </p></td><td><p><span>放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛</span><span>。</span><span>在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件</span></p><p><span>/usr/share/doc：软件杂项的文件说明</span></p><p><span>/usr/share/zoneinfo：与时区有关的时区文件</span></p></td></tr><tr><td><p><span>/usr/src/</span> </p></td><td><p><span>一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。</span> </p></td></tr></tbody></table><h2 id=\"d8ffb6e1\">/var的意义与内容</h2><p>如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件，包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：</p><table class=\"lake-table\" style=\"width: 721px;\"><colgroup><col width=\"360\"></col><col width=\"360\"></col></colgroup><tbody><tr><td><p><strong>目录</strong></p></td><td><p style=\"text-align: center;\"><strong>应放置文件内容</strong></p></td></tr><tr><td><p><span>/var/cache/</span></p></td><td><p><span>应用程序本身运作过程中会产生的一些暂存档</span></p></td></tr><tr><td><p><span>/var/lib/</span><span></span></p></td><td><p><span>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去</span></p></td></tr><tr><td><p><span>/var/lock/</span></p></td><td><p><span>某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用</span></p></td></tr><tr><td><p><span>/var/log/</span><span></span></p></td><td><p><span>非常</span><span>重要</span><span>。</span><span>这是登录文件放置的目录</span><span>。</span><span>里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。</span></p></td></tr><tr><td><p><span>/var/mail/</span></p></td><td><p><span>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中</span><span>，</span><span>通常这两个目录是互为链接文件</span><span>。</span></p></td></tr><tr><td><p><span>/var/run/</span><span></span></p></td><td><p><span>某些程序或者是服务启动后，会将他们的PID放置在这个目录下</span></p></td></tr><tr><td><p><span>/var/spool/</span></p></td><td><p><span>这个目录通常放置一些队列数据，所谓的</span><span>“</span><span>队列</span><span>”</span><span>就是排队等待其他程序使用的数据</span><span>。</span><span> 这些数据被使用</span></p></td></tr></tbody></table><p style=\"text-indent: 2em;\">由于FHS仅是定义出最上层(/)及次层(/usr,/var)的目录内容应该要放置的文件或目录数据，因此，在其他次目录层级内，就可以随开发者自行来配置了。</p><h2 id=\"6a1a03b0\">目录树<strong>(directory tree)</strong><span style=\"color: #333333;\"> </span><strong>:</strong></h2><p style=\"text-indent: 2em;\">在Linux底下，所有文件与目录都是由根目录开始的。那是所有目录与文件的源头，然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directoty tree)，这个目录的主要特性有：</p><p style=\"text-indent: 2em;\">目录树的起始点为根目录(/，root)；</p><p style=\"text-indent: 2em;\">每一个目录不止能使用本地端的partition的文件系统，也可以使用网络上的filesystem。举例来说，可以利用Network File System(NFS)服务器挂载某特定目录等。</p><p style=\"text-indent: 2em;\">每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。</p><p style=\"text-indent: 2em;\">如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示：</p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1549101208779-3e78a392-e781-434d-bb01-588504ab5836.png#align=left&amp;display=inline&amp;height=432&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=432&amp;originWidth=488&amp;size=57239&amp;width=488\" style=\"max-width: 600px; width: 488px;\" /></p><h2 id=\"1b076efb\">绝对路径和相对路径</h2><p>除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名的写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。这两种文件名/路径的写法依据是这样的：</p><p style=\"text-indent: 21pt;\"><strong>绝对路径：</strong></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；</span></p><p style=\"text-indent: 21pt;\"><strong>相对路径：</strong></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 http://www.cnblogs.com/home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">cd /var/log   (absolute)</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">cd ../var/log (relative)</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">.  ：代表当前的目录，也可以使用 ./ 来表示；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">.. ：代表上一层目录，也可以 ../ 来代表。</span></p><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-10\">这个.与..目录概念是很重要的，你常常会看到cd ..或./command 之类的指令下达方式，就是代表上一层与目前所在目录的工作状态。</span></p><h2 id=\"480c216f\">实例</h2><p>网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？</p><p>由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin,/usr/bin等为正规),此时要执行指令就要严格指定该执行档。./代表某目录的意思，所以./run.sh代表执行本目录下，名为run.sh的文件。</p><p><br /></p><h1 id=\"a593dedd\">Linux文件类型与扩展名</h1><h2 id=\"a4d3b02a\">概述</h2><p style=\"text-indent: 2em;\">Linux文件类型和Linux文件的文件名所代表的意义是两个不同的概念。我们通过一般应用程序而创建的比如file.txt、file.tar.gz，这些文件虽然要用不同的程序来打开，但放在Linux文件类型中衡量的话，大多是常规文件（也被称为普通文件）。</p><h2 id=\"28b988ce\">文件类型</h2><p style=\"text-indent: 2em;\">Linux文件类型常见的有：普通文件、目录文件、字符设备文件和块设备文件、符号链接文件等，现在我们进行一个简要的说明。</p><h3 id=\"caafc473\">普通文件</h3><p style=\"text-indent: 2em;\">我们用ls -lh来查看某个文件的属性，可以看到有类似<span style=\"color: #333333;\">-rwxrwxrwx，值得注意的是第一个符号是-，这样的文件在Linux中就是普通文件。这些文件一般使用一些相关的应用程序创建，比如图像工具、文档工具、归档工具...或cp工具等。这类文件的删除方式是用rm命令。另外，依照文件的内容，有大略可以分为：</span></p><h4 id=\"8e0d3575\">纯文本档(ASCII):</h4><p style=\"text-indent: 2em;\">这是Linux系统中最多的一种文件类型，称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。</p><p>几乎只要我们可以用来做为设定的文件都属于这一种文件类型。举例来说，你可以用命令：cat ~/.bashrc看到该文件的内容。(cat是将一个文件内容读出来的指令)。</p><h4 id=\"af823250\">二进制文件(binary)：</h4><p style=\"text-indent: 2em;\">Linux系统其实仅认识切可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts,文字型批处理文件不算)就是这种格式的文件。刚刚使用的cat命令就是一个binary file。</p><h4 id=\"ba743d34\">数据格式文件(data)：</h4><p style=\"text-indent: 2em;\">有些程序在运作的过程中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件(data file)。举例来说，我们的Linux在使用者登录时，都会精登录的数据记录在/var/log/wtmp那个文件内，该文件是一个data file，他能够透过last这个指令读出来！但是使用cat时，会读出乱码~因为贪睡属于一种特殊格式的文件</p><h3 id=\"f6fd223e\">目录文件</h3><p style=\"text-indent: 2em;\">当我们在某个目录下执行，看到有类似drwxr-xr-x，这样的文件就是目录，目录在Linux是一个比较特殊的文件。注意它的第一个字符是d。创建目录的命令可以用mkdir命令，或cp命令，cp可以把一个目录复制为另一份目录。删除用rm或rmdir命令。</p><h3 id=\"49e21976\">字符设备或块设备文件</h3><p style=\"text-indent: 2em;\">如果你进入/dev目录，列一下文件，会看到类似如下的:</p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">[root@localhost ~]# ls -al /dev/tty</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">crw-rw-rw- 1 root tty 5, 0 11-03 15:11 /dev/tty</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">[root@localhost ~]# ls -la /dev/sda1</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">brw-r----- 1 root disk 8, 1 11-03 07:11 /dev/sda1</span></p><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-9\">我们看到/dev/tty的属性是crw-rw-rw-,注意前面第一个字符是c，这表示字符设备文件。比如猫等串口设备。我们看到/dev/sdal 的属性是brw-r----，注意前面的第一个字符是b，这表示块设备，比如硬盘，光驱等设备。</span></p><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-9\">这个种类的文件，使用mknode来创建，用rm来删除。目前在最新的Linux发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。</span></p><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-9\">与系统周边及存储相关的一些文件，通常都集中在/dev这个目录之下通常又分成两种：</span></p><h4 id=\"957a3f67\">区块<strong>(block)</strong>设备档</h4><p style=\"text-indent: 2em;\">就是一些存储数据，以提供系统随机存取的接口设备，举例来说，硬盘与软盘等就是啦。你可以随机的在硬盘的不同区块读写，这种装置就是成组设备！你可以自行查一下/dev/sda看看，会发现第一个属性为 [b] ！</p><h4 id=\"60697ced\">字符<strong>(character)</strong>设备文件</h4><p style=\"text-indent: 2em;\">亦即是一些串行端口的接口设备，例如键盘、鼠标等等！这些设备的特设就是一次性读取的，不能够结算输出。举例来说，你不可能让鼠标调到另一个画面，而是滑动到另一个地方！第一个属性为[c]。</p><h3 id=\"48381f2b\">数据接口文件(sockets)：</h3><p style=\"text-indent: 2em;\">数据接口问文件(或者：套接口文件)，这种类型的文件通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求，而客户端就可以透过这个socket来进行数据的沟通了。第一个数次那个为[s]，最常在/var/run这个目录中看到这种文件类型了。</p><p style=\"text-indent: 2em;\">例如：当我们启动MySQL服务器时，会产生一个mysql.sock的文件。</p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">[root@localhost ~]# ls -lh /var/lib/mysql/mysql.sock </span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">srwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock</span></p><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-9\">注意这个文件的属性的第一个字符是s。</span></p><h3 id=\"86e27da8\">符号链接文件：</h3><p style=\"text-indent: 2em;\">当我们查看文件属性时，会看到有类似lrwxrw<span style=\"color: #333333;\">xrwx,注意第一个字符是l，这类文件是链接文件。是通过ln -s源文件名 新文件名。上面是一个例子，表示setup.log是instal.log的软链接文件。怎么理解呢？这和Windows操作系统中的快捷方式有点相似。</span></p><p style=\"text-indent: 2em;\"><span style=\"color: #333333;\">符号链接文件的创建方法举例：</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">[root@localhost test]# ls -lh log2012.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">[root@localhost test]# ln -s log2012.log  linklog.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">[root@localhost test]# ls -lh *.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">lrwxrwxrwx 1 root root   11 11-22 06:58 linklog.log -&gt; log2012.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</span></p><h3 id=\"92758146\">数据输送文件(FIFO，pipe):</h3><p>FIFO也是一种特殊的文件了类型，他主要的目的在解决多个程序同时存取一个问价所造成的错误问题。FIFO是first-in-first-out的缩写。第一个属性为[p]。</p><h2 id=\"c99eceae\">Linux文件扩展名</h2><h3 id=\"8249e0f0\">扩展名类型</h3><p style=\"text-indent: 2em;\">基本上，Linux的文件是没有所谓的扩展名的，一个Linux文件能不能被执行，与他的第一栏的是个属性有关，与档名根本一点关系也没有。这个观念和Windows的情况不相同。在Windows底下，能被执行的文件扩展名通常是.com,.exe,.bat等等。而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ]即代表这个文件可以被执行。</p><p style=\"text-indent: 2em;\">不过，可以被执行根可以执行成功破那个是不一样的，举例来说，在root/home 目录下的install.log 是一个纯文本档，如果经由修改权限成为 -rwxrwxrwx 后，这个问价能够真的执行成功吗？当然就要看该文件的内容。</p><p style=\"text-indent: 2em;\">虽然如此，不过我们任然希望可以藉由扩展名来了解该文件是什么东西，所以，通常我么还是会以适当的扩展名表示该文件是什么种类的。底下有数种常用的扩展名：</p><p style=\"text-indent: 2em;\">*.sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh</p><p style=\"text-indent: 2em;\">*Z, *.tar, *.tar.gz, *.zip, *.tgz： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！</p><p style=\"text-indent: 2em;\">*.html, *.php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件。 .html 的文件可使用网页浏览器来直接开启，至于 .php 的文件， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果。    </p><p style=\"text-indent: 2em;\">基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件 ，如常用的/bin/ls这个显示文件属性的指令，不过，如果这个问价的权限被修改为无法执行时，那么ls就变成不能执行。</p><p style=\"text-indent: 2em;\">上述的这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的Linux系统中就是无法执行！呵呵！那么就是可能文件的属性被改变了。不要怀疑，从网络上床送到你的Linux系统中，文件的属性与权限确实是会被改变的。</p><h3 id=\"ef3c5d58\">Linux文件名长度限制</h3><p>在Linux底下，使用预设的Ext2/Ext3文件系统时，针对文件名长度限制为：</p><p>单一文件或目录的最大容许文件名为 255 个字符</p><p>包含完整路径名称及目录 (/) 之完整档名为 4096 个字符</p><p>是相当长的档名！我们希望Linux的文件名可以一看就知道该文件在干嘛的， 所以档名通常是很长很长。</p><h3 id=\"32965283\">Linux文件名的字符的限制</h3><p style=\"text-indent: 2em;\">由于Linux在文字接口下的一些指令操作关系，一般来说，你在设定Linux底下的文件名时， 最好可以避免一些特殊字符比较好！例如底下这些：</p><p style=\"text-indent: 2em;\">* ? &gt; &lt; ; &amp; ! [ ] | \\ ' &quot; ` ( ) { }</p><p style=\"text-indent: 2em;\">因为这些符号在文字接口下，是有特殊意义的。另外，文件名的开头为小数点“.”时， 代表这个文件为隐藏文件！同时，由于指令下达当中，常常会使用到 -option 之类的选项， 所以你最好也避免将文件档名的开头以 - 或 + 来命名。</p><p><br /></p><h1 id=\"8fe3fe66\">Linux文件属性详解</h1><h2 id=\"a4d3b02a\">概述</h2><p>Linux文件或目录的属性主要包括：文件或目录的节点、种类、权限模式、链接数量、所归属的用户和用户组、最近访问或修改的时间等内容。具体情况如下：</p><p style=\"text-indent: 21pt;\"><strong>命令：</strong> </p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">ls -lih</span></p><p style=\"text-indent: 21pt;\"><strong>输出：</strong></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">[root@localhost test]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span> <span class=\"lake-fontsize-9\" style=\"color: #008000;\">ls -lih</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">总计 316K</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095120 lrwxrwxrwx 1 root root   11 11-22 06:58 linklog.log -&gt; </span><span class=\"lake-fontsize-9\">log2012.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095112 -rw-r--r-- 1 root root 296K 11-13 06:03 </span><span class=\"lake-fontsize-9\">log2012.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095110 -rw-r--r-- 1 root root   61 11-13 06:03 </span><span class=\"lake-fontsize-9\">log2013.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095107 -rw-r--r-- 1 root root    0 11-13 06:03 </span><span class=\"lake-fontsize-9\">log2014.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095117 -rw-r--r-- 1 root root    0 11-13 06:06 </span><span class=\"lake-fontsize-9\">log2015.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095118 -rw-r--r-- 1 root root    0 11-16 14:41 </span><span class=\"lake-fontsize-9\">log2016.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095119 -rw-r--r-- 1 root root    0 11-16 14:43 </span><span class=\"lake-fontsize-9\">log2017.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095113 drwxr-xr-x 6 root root 4.0K 10-27 01:58 </span><span class=\"lake-fontsize-9\">scf</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095109 drwxrwxr-x 2 root root 4.0K 11-13 06:08 </span><span class=\"lake-fontsize-9\">test3</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095131 drwxrwxr-x 2 root root 4.0K 11-13 05:50 test4</span></p><p style=\"text-indent: 21pt;\"><strong>说明：</strong></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第一列：inode</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第二列：文件种类和权限；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第三列： 硬链接个数；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第四列： 属主；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第五列：所归属的组；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第六列：文件或目录的大小；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第七列和第八列：最后访问或修改时间；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第九列：文件名或目录名</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">我们以</span><span class=\"lake-fontsize-9\" style=\"background-color: #F5F5F5;\">log2012.log</span><span class=\"lake-fontsize-10\">为例：</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095112 -rw-r--r-- 1 root root 296K 11-13 06:03 </span><span class=\"lake-fontsize-9\">log2012.log</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">inode 的值是：</span><span class=\"lake-fontsize-9\">2095112 </span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">文件类型：文件类型是-，表示这是一个普通文件； 关于文件的类型，请参考：</span><a href=\"http://www.cnblogs.com/peida/archive/2012/11/22/2781912.html\" target=\"_blank\"><span class=\"lake-fontsize-10\" style=\"color: #0000FF;\">每天一个linux命令(24)：Linux文件类型与扩展名</span></a> </p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">文件权限：文件权限是</span><span class=\"lake-fontsize-9\">rw-r--r--</span><span class=\"lake-fontsize-10\"> ，表示文件属主可读、可写、不可执行，文件所归属的用户组不可写，可读，不可执行，其它用户不可写，可读，不可执行；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">硬链接个数： </span><span class=\"lake-fontsize-9\" style=\"background-color: #F5F5F5;\">log2012.log</span><span class=\"lake-fontsize-10\">这个文件没有硬链接；因为数值是1，就是他本身；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">文件属主：也就是这个文件归哪于哪个用户 ，它归于root，也就是第一个root；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">文件属组：也就是说，对于这个文件，它归属于哪个用户组，在这里是root用户组；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">文件大小：文件大小是296k个字节；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">访问可修改时间 ：这里的时间是最后访问的时间，最后访问和文件被修改或创建的时间，有时并不是一致的；</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">当然文档的属性不仅仅包括这些，这些是我们最常用的一些属性。</span></p><h2 id=\"793d72b2\">关于inode</h2><p style=\"text-indent: 2em;\">inode 译成中文就是索引节点。每个存储设备或存储设备的分区(存储设备是硬盘、软盘、u盘等等)被格式化为文件系统后，应该有两部分，一部分是inode，另一部分是Block，Block是用来存储数据用的。而inode为每个文件进行信息索引，所以就有了inode的数值。操作系统根据指令，能通过inode值最快的找到相对应的文件。</p><p style=\"text-indent: 2em;\">做个比喻，比如一本书，存储设备或跟去就相当于这本书，Block相当于书中的每一页，inode 就相当与这本书前面的目录，一本书有很多的内容，如果想查找某部分的内容，我们可以先查目录，通过目录能最快的找到我们想要看的内容。虽然不太恰当，但还是比较形象。</p><p>当我们用ls查看某个目录或文件时，如果加上-i参数，就可以看到inode节点了，比如我们前面所说的例子：</p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">[root@localhost test]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span> <span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ls -li log2012.log </span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-9\">2095112 -rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log</span></p><p>log2012.log 的inode值是 2095112 ； 查看一个文件或目录的inode，要通过ls 命令的的 -i参数。</p><p><br /></p><blockquote style=\"padding-left: 1em;\"><p>      编译：peida     </p><p>      链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html</p></blockquote>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-05T13:56:48.000Z",
    "deleted_at": null,
    "created_at": "2019-02-02T06:09:14.000Z",
    "updated_at": "2019-02-05T13:56:48.000Z",
    "published_at": "2019-02-05T13:56:48.000Z",
    "first_published_at": "2019-02-02T08:11:49.000Z",
    "word_count": 8973,
    "cover": null,
    "description": "categories: Linux&lt;blockquote class=&quot;blockquote-center&quot;&gt;**文件和目录属性**&lt;/blockquote&gt;&lt;!-- more --&gt;      编译：peida           链接...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1217155,
    "slug": "num_264",
    "title": "264. Ugly Number II",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 19,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-13T01:08:41.500Z",
      "updated_at": "2019-02-13T01:08:41.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n![carbon.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548993522023-e08a0595-f805-4d93-9b0f-e3a5a13fa985.png#align=left&display=inline&height=760&linkTarget=_blank&name=carbon.png&originHeight=1166&originWidth=1144&size=175876&width=746)\n\n<!-- more -->\n## 题目描述\nWrite a program to find the `n`-th ugly number.<br />Ugly numbers are** positive numbers** whose prime factors only include `2, 3, 5`. <br />**Example:**\n**Input:** n = 10\n**Output:** 12\n**Explanation: **```\n1, 2, 3, 4, 5, 6, 8, 9, 10, 12\n```\n is the sequence of the first ```\n10\n```\n ugly numbers.**Note: ** \n1. `1` is typically treated as an ugly number.\n1. `n` **does not exceed 1690**.\n## 参考代码\n\n```java\nclass Solution {\n    public int nthUglyNumber(int n) {\n        int factors[] = {2,3,5};\n        //优先队列\n        Queue<Long> queue = new PriorityQueue<>();\n        queue.offer(1L);\n        注意第1690个可能会超过int的范围\n        while (true) {\n            long min = queue.poll();//每次取最小值相乘，取得第n个数\n            if (n == 1) {\n                return (int)min;\n            }\n            for (int i = 0; i < 3; i++) {\n                long ugly = factors[i] * min;\n                if(!queue.contains(ugly)) {//去重\n                    queue.offer(ugly);\n                }\n            }\n            n--;\n        }\n    }\n}\n```\n\n## 思路及总结\n利用优先队列进行排序，然后将2、3、5中最小值作为下次相乘的因子，确保没有重复的数字，queue.poll()取得的是即是第 1\\2\\3\\4\\5。。。 个数,当n = 1 时，min即是第n个数.\n## 参考\n[https://chuansongme.com/n/1648591652025](https://chuansongme.com/n/1648591652025)\n",
    "body_draft": "categories: leetcode\n\n---\n![215.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548506060055-118e8488-7b24-4981-8a99-75880675fde5.png#align=left&display=inline&height=411&linkTarget=_blank&name=215.png&originHeight=806&originWidth=1464&size=153252&width=746)<br /><!-- more -->\n## 题目描述\n在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br />**示例 1:**\n**输入:** ```\n[3,2,1,5,6,4] 和\n```\n k = 2\n**输出:** 5**示例 2:**\n**输入:** ```\n[3,2,3,1,2,4,5,5,6] 和\n```\n k = 4\n**输出:** 4**说明:**<br />你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n## 参考代码\n\n```java\nclass Solution {\n   public static int findKthLargest(int[] nums, int k) {\n\t\tPriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n       for(int num :nums) {\n           priorityQueue.add(num);\n           if(priorityQueue.size() > k) {\n               priorityQueue.poll();\n           }\n       }\n       return priorityQueue.peek();\n   }\n}\n```\n\n## 思路及总结\n主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。\n## 参考\n[https://www.kancloud.cn/maliming/leetcode/844880](https://www.kancloud.cn/maliming/leetcode/844880)\n",
    "body_html": "<p>categories: leetcode</p><p><br /></p><hr /><p><img alt=\"carbon.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1548993522023-e08a0595-f805-4d93-9b0f-e3a5a13fa985.png#align=left&amp;display=inline&amp;height=760&amp;linkTarget=_blank&amp;name=carbon.png&amp;originHeight=1166&amp;originWidth=1144&amp;size=175876&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>Write a program to find the <code>n</code>-th ugly number.</p><p>Ugly numbers are<strong> positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>. </p><p><strong>Example:</strong></p><pre><strong>Input:</strong> n = 10\n<strong>Output:</strong> 12\n<strong>Explanation: </strong><code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</pre><p><strong>Note: </strong> </p><ol><li><code>1</code> is typically treated as an ugly number.</li><li><code>n</code> <strong>does not exceed 1690</strong>.</li></ol><h2 id=\"36967e2c\">参考代码</h2><p><br /></p><pre data-lang=\"java\"><code>class Solution {\n    public int nthUglyNumber(int n) {\n        int factors[] = {2,3,5};\n        //优先队列\n        Queue&lt;Long&gt; queue = new PriorityQueue&lt;&gt;();\n        queue.offer(1L);\n        注意第1690个可能会超过int的范围\n        while (true) {\n            long min = queue.poll();//每次取最小值相乘，取得第n个数\n            if (n == 1) {\n                return (int)min;\n            }\n            for (int i = 0; i &lt; 3; i++) {\n                long ugly = factors[i] * min;\n                if(!queue.contains(ugly)) {//去重\n                    queue.offer(ugly);\n                }\n            }\n            n--;\n        }\n    }\n}</code></pre><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p>利用优先队列进行排序，然后将2、3、5中最小值作为下次相乘的因子，确保没有重复的数字，queue.poll()取得的是即是第 1\\2\\3\\4\\5。。。 个数,当n = 1 时，min即是第n个数.</p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://chuansongme.com/n/1648591652025\" target=\"_blank\">https://chuansongme.com/n/1648591652025</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-01T06:44:49.000Z",
    "deleted_at": null,
    "created_at": "2019-02-01T03:57:23.000Z",
    "updated_at": "2019-02-01T06:44:49.000Z",
    "published_at": "2019-02-01T06:44:49.000Z",
    "first_published_at": "2019-02-01T04:03:17.000Z",
    "word_count": 252,
    "cover": null,
    "description": "categories: leetcode&lt;!-- more --&gt;题目描述Write a program to find the n-th ugly number.Ugly numbers are positive numbers whose prime factors only ...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1196360,
    "slug": "linux_learning5",
    "title": "LInux学习5",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 19,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-13T01:08:41.500Z",
      "updated_at": "2019-02-13T01:08:41.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Linux\n\n---\n\n<blockquote class=\"blockquote-center\">**网络命令**</blockquote><br /><!-- more -->\n>       编译：peida     \n>       链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html\n\n# ifconfig命令\n## 概述\n许多Windows非常熟悉ipconfig命令工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有类似的工具，也就是ifconfig（interfaces config）。通常需要以root身份登录或者使用sudo以便在LInux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息等，还可以修改这些配置\n## 命令格式\nifconfig[网络设备][参数]\n## 命令参数\n\n```\nup 启动指定网络设备/网卡。\ndown 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。\narp 设置指定网卡是否支持ARP协议。\n-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包\n-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包\n-a 显示全部接口信息\n-s 显示摘要信息（类似于 netstat -i）\nadd 给指定网卡配置IPv6地址\ndel 删除指定网卡的IPv6地址\n<硬件地址> 配置网卡最大的传输单元\nmtu<字节数> 设置网卡的最大传输单元 (bytes)\nnetmask<子网掩码> 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。\ntunel 建立隧道\ndstaddr 设定一个远端地址，建立点对点通信\n-broadcast<地址> 为指定网卡设置广播协议\n-pointtopoint<地址> 为网卡设置点对点通讯协议\nmulticast 为网卡设置组播标志\naddress 为网卡设置IPv4地址\ntxqueuelen<长度> 为网卡设置传输列队的长度\n```\n## 常用命令\n实例：显示网络设备信息（激活状态的）<br />命令：ifconfig<br />[root@localhost ~]# ifconfig<br />eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:20  <br />          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0<br />          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br />          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:1000 <br />          RX bytes:596390239 (568.7 MiB)  TX bytes:2886956 (2.7 MiB)<br />lo        Link encap:Local Loopback  <br />          inet addr:127.0.0.1  Mask:255.0.0.0<br />          UP LOOPBACK RUNNING  MTU:16436  Metric:1<br />          RX packets:68 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:0 <br />          RX bytes:2856 (2.7 KiB)  TX bytes:2856 (2.7 KiB)<br />说明：eth0表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址（MAC地址）是 00:50:56:BF:26:20<br />inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.168.120.204，广播地址， Bcast:192.168.120.255，掩码地址Mask:255.255.255.0 <br />lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。<br />第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）<br />第二行：网卡的IP地址、子网、掩码<br />第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节<br />第四、五行：接收、发送数据包情况统计<br />第七行：接收、发送数据字节数统计信息。<br /><br /><br />实例：启动关闭指定网卡<br />命令：<br />ifconfig eth0 up<br />ifconfig eth0 down<br />说明：ifconfig eth0 up 为启动网卡eth0 ；ifconfig eth0 down 为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。\n\n实例：为网卡配置和删除IPv6地址<br />命令：<br />ifconfig eth0 add 33ffe:3240:800:1005::2/64<br />ifconfig eth0 del 33ffe:3240:800:1005::2/64<br />说明：<br />ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0配置IPv6地址；<br />ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0删除IPv6地址；<br />练习的时候，ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。\n\n实例：用ifconfig修改MAC地址<br />命令：ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE<br />[root@localhost ~]# ifconfig eth0 down //关闭网卡<br />[root@localhost ~]# ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE //修改MAC地址<br />[root@localhost ~]# ifconfig eth0 up //启动网卡<br />[root@localhost ~]# ifconfig<br />eth0      Link encap:Ethernet  HWaddr 00:AA:BB:CC:DD:EE  <br />          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0<br />          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br />          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:1000 <br />          RX bytes:596390239 (568.7 MiB)  TX bytes:2886956 (2.7 MiB)<br />lo        Link encap:Local Loopback  <br />          inet addr:127.0.0.1  Mask:255.0.0.0<br />          UP LOOPBACK RUNNING  MTU:16436  Metric:1<br />          RX packets:68 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:0 <br />          RX bytes:2856 (2.7 KiB)  TX bytes:2856 (2.7 KiB)<br />[root@localhost ~]# ifconfig eth0 hw ether 00:50:56:BF:26:20 //关闭网卡并修改MAC地址 <br />[root@localhost ~]# ifconfig eth0 up //启动网卡<br />[root@localhost ~]# ifconfig<br />eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:20  <br />          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0<br />          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br />          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:1000 <br />          RX bytes:596390239 (568.7 MiB)  TX bytes:2886956 (2.7 MiB)<br />lo        Link encap:Local Loopback  <br />          inet addr:127.0.0.1  Mask:255.0.0.0<br />          UP LOOPBACK RUNNING  MTU:16436  Metric:1<br />          RX packets:68 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:0 <br />          RX bytes:2856 (2.7 KiB)  TX bytes:2856 (2.7 KiB) \n\n实例：配置IP地址<br />命令：<br />[root@localhost ~]# ifconfig eth0 192.168.120.56 <br />[root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 <br />[root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255<br />说明：<br />ifconfig eth0 192.168.120.56 <br />给eth0网卡配置IP地：192.168.120.56<br /> ifconfig eth0 192.168.120.56 netmask 255.255.255.0 <br />给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0<br />ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255<br />/给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255<br /><br /><br />实例：启动和关闭ARP协议<br />命令：<br />[root@localhost ~]# ifconfig eth0 arp <br />[root@localhost ~]# ifconfig eth0 -arp<br />说明：<br />ifconfig eth0 arp 开启网卡eth0 的arp协议；<br />ifconfig eth0 -arp 关闭网卡eth0 的arp协议；\n\n实例：设置最大传输单元<br />命令：ifconfig eth0 mtu 1500<br />[root@localhost ~]# ifconfig eth0 mtu 1480<br />[root@localhost ~]# ifconfig<br />eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:1F  <br />          inet addr:192.168.120.203  Bcast:192.168.120.255  Mask:255.255.255.0<br />          UP BROADCAST RUNNING MULTICAST  MTU:1480  Metric:1<br />          RX packets:8712395 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:36631 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:1000 <br />          RX bytes:597062089 (569.4 MiB)  TX bytes:2643973 (2.5 MiB)<br /><br />[root@localhost ~]# ifconfig eth0 mtu 1500[root@localhost ~]# ifconfigeth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:1F  <br />          inet addr:192.168.120.203  Bcast:192.168.120.255  Mask:255.255.255.0<br />          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br />          RX packets:8712548 errors:0 dropped:0 overruns:0 frame:0<br />          TX packets:36685 errors:0 dropped:0 overruns:0 carrier:0<br />          collisions:0 txqueuelen:1000 <br />          RX bytes:597072333 (569.4 MiB)  TX bytes:2650581 (2.5 MiB)<br />说明：设置能通过的最大数据包大小为1500bytes<br />备注：用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在，要想将上述的配置信息永远的存在电脑里，那就要修改网卡的配置文件了。\n\n---\n\n# route命令\n## 概述\nLinux系统的toute命令用于显示和操作IP路由表（show / manipulate the IP routing table）。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在 Linux 系统中，设置路由通常是为了解决以下问题：该 Linux 系统在一个局域网中，局域网中有一个网关，能够让机器访问 Internet，那么就需要将这台机器的 IP 地址设置为 Linux 机器的默认路由。要注意的是，直接在命令行下执行 route 命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在 / etc/rc.local 中添加 route 命令来保证该路由设置永久有效。\n## 命令格式\nroute [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] \n## 命令功能\nRoute命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络连接口，如eth0。当使用参数时，路由表被修改，如果没有参数，则显示路由表当前内容\n## 命令参数\n\n```\n-c 显示更多信息\n-n 不解析名字\n-v 显示详细的处理信息\n-F 显示发送信息\n-C 显示路由缓存\n-f 清除所有网关入口的路由表。 \n-p 与 add 命令一起使用时使路由具有永久性。\nadd: 添加一条新路由。\ndel: 删除一条路由。\n-net: 目标地址是一个网络。\n-host: 目标地址是一个主机。\nnetmask: 当添加一个网络路由时，需要使用网络掩码。\ngw: 路由数据包通过网关。注意，你指定的网关必须能够达到。\nmetric：设置路由跳数。\nCommand 指定您想运行的命令 (Add/Change/Delete/Print)。 \nDestination 指定该路由的网络目标。 \nmask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。 \nGateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。 \nmetric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表 (与转发的数据包目标地址最匹配) 的多个路由中进行选择时可以使用。 \nif Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。\n```\n## 常用命令\n实例：显示当前路由<br />命令：<br />route<br />route -n<br />[root@localhost ~]# route<br />Kernel IP routing table<br />Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br />192.168.120.0   *               255.255.255.0   U     0      0        0 eth0<br />e192.168.0.0     192.168.120.1   255.255.0.0     UG    0      0        0 eth0<br />10.0.0.0        192.168.120.1   255.0.0.0       UG    0      0        0 eth0<br />default         192.168.120.240 0.0.0.0         UG    0      0        0 eth0<br />[root@localhost ~]# route -n<br />Kernel IP routing table<br />Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br />192.168.120.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0<br />192.168.0.0     192.168.120.1   255.255.0.0     UG    0      0        0 eth0<br />10.0.0.0        192.168.120.1   255.0.0.0       UG    0      0        0 eth0<br />0.0.0.0         192.168.120.240 0.0.0.0         UG    0      0        0 eth0<br />说明：<br />第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;<br />第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240<br />其中Flags为路由标志，标记当前网络节点的状态。<br />Flags标志说明：\n\n```\nU Up表示此路由当前为启动状态\nH Host，表示此网关为一主机\nG Gateway，表示此网关为一路由器a\nR Reinstate Route，使用动态路由重新初始化的路由\nD Dynamically,此路由是动态性地写入a\nM Modified，此路由是由路由守护程序或导向器动态修改\n! 表示此路由当前为关闭状态\n```\n\n备注：route -n (-n 表示不解析名字,列出速度会比route 快)\n\n实例：添加网关/设置网管<br />命令：route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0<br />说明：增加一条 到达 244.0.0.0 的路由\n\n实例：删除路由记录<br />命令：<br />route del -net 224.0.0.0 netmask 240.0.0.0<br />route del -net 224.0.0.0 netmask 240.0.0.0 reject<br />说明：删除224.0.0.0的路由记录\n\n实例 ：删除和添加设置默认网关<br />命令：<br />route del default gw 192.168.120.240<br />route add default gw 192.168.120.240\n# ping命令\n## 概述\nLinux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性，我们经常会说\"ping一下某机器，看是不是开着“、不能打开网页时会说\"”你先ping网关地址192.168.1.1试试“。<br />它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样而我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。<br />linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。\n## 命令格式\nping [参数] [主机名或IP地址]\n## 命令功能\nping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。<br />ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在**程序超时或当接收到 SIGINT 信号时结束**。Host 参数或者是一个有效的主机名或者是因特网地址。\n## 命令参数\n\n```\n-d 使用Socket的SO_DEBUG功能。\n-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。\n-n 只输出数值。\n-q 不显示任何传送封包的信息，只显示最后的结果。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。\n-R 记录路由过程。\n-v 详细显示指令的执行过程。\n<p>-c 数目：在发送指定数目的包后停止。\n-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。\n-I 网络界面：使用指定的网络界面送出数据包。\n-l 前置载入：设置在送出要求信息之前，先行发出的数据包。\n-p 范本样式：设置填满数据包的范本样式。\n-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。\n-t 存活数值：设置存活数值TTL的大小。\n```\n## 常用命令\n实例：ping的通的情况<br />命令：ping 192.168.120.205<br />输出：<br />[root@localhost ~]# ping 192.168.120.205<br />PING 192.168.120.205 (192.168.120.205) 56(84) bytes of data.<br />64 bytes from 192.168.120.205: icmp_seq=1 ttl=64 time=0.720 ms<br />64 bytes from 192.168.120.205: icmp_seq=2 ttl=64 time=0.181 ms<br />64 bytes from 192.168.120.205: icmp_seq=3 ttl=64 time=0.191 ms<br />64 bytes from 192.168.120.205: icmp_seq=4 ttl=64 time=0.188 ms<br />64 bytes from 192.168.120.205: icmp_seq=5 ttl=64 time=0.189 ms<br /><br />--- 192.168.120.205 ping statistics ---<br />5 packets transmitted, 5 received, 0% packet loss, time 4000ms<br />rtt min/avg/max/mdev = 0.181/0.293/0.720/0.214 ms<br />[root@localhost ~]# <br /><br /><br />实例：ping不通的情况<br />命令：ping 192.168.120.202<br />输出：<br />[root@localhost ~]# ping 192.168.120.202<br />PING 192.168.120.202 (192.168.120.202) 56(84) bytes of data.<br />From 192.168.120.204 icmp_seq=1 Destination Host Unreachable<br />From 192.168.120.204 icmp_seq=2 Destination Host Unreachable<br /><br /><br />实例：ping指定次数<br />命令：ping -c 10 192.168.120.206\n\n实例：时间间隔和次数限制的ping<br />命令：ping -c 10 -i 0.5 192.168.120.206\n\n实例：多参数使用<br />命令：ping -i 3 -s 1024 -t 255 192.168.120.206<br />说明：-i 3 发送周期为 3秒 -s 设置发送包的大小为1024 -t 设置TTL值为 255\n# traceroute命令\n## 概述\n通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。<br />在大多数情况下，我们会在linux主机系统下，直接执行命令行：<br />traceroute hostname<br />而在Windows系统下是执行tracert的命令：<br />tracert hostname\n## 命令格式\ntraceroute[参数][主机]\n## 命令功能\ntraceroute命令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。具体参数格式：traceroute [-dFlnrvx][-f<存活数值>][-g<网关>...][-i<网络界面>][-m<存活数值>][-p<通信端口>][-s<来源地址>][-t<服务类型>][-w<超时秒数>][主机名称或IP地址][数据包大小]\n## 命令参数\n\n```\n-d 使用Socket层级的排错功能。\n-f 设置第一个检测数据包的存活数值TTL的大小。\n-F 设置勿离断位。\n-g 设置来源路由网关，最多可设置8个。\n-i 使用指定的网络界面送出数据包。\n-I 使用ICMP回应取代UDP资料信息。\n-m 设置检测数据包的最大存活数值TTL的大小。\n-n 直接使用IP地址而非主机名称。\n-p 设置UDP传输协议的通信端口。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n-s 设置本地主机送出数据包的IP地址。\n-t 设置检测数据包的TOS数值。\n-v 详细显示指令的执行过程。\n-w 设置等待远端主机回报的时间。\n-x 开启或关闭数据包的正确性检验。\n```\n## 常用命令\n实例1：traceroute 用法简单、最常用的用法<br />命令：<br />traceroute www.baidu.com<br />输出：<br />[root@localhost ~]# traceroute www.baidu.com<br />traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br /> 1  192.168.74.2 (192.168.74.2)  2.606 ms  2.771 ms  2.950 ms<br /> 2  211.151.56.57 (211.151.56.57)  0.596 ms  0.598 ms  0.591 ms<br /> 3  211.151.227.206 (211.151.227.206)  0.546 ms  0.544 ms  0.538 ms<br /> 4  210.77.139.145 (210.77.139.145)  0.710 ms  0.748 ms  0.801 ms<br /> 5  202.106.42.101 (202.106.42.101)  6.759 ms  6.945 ms  7.107 ms<br /> 6  61.148.154.97 (61.148.154.97)  718.908 ms * bt-228-025.bta.net.cn (202.106.228.25)  5.177 ms<br /> 7  124.65.58.213 (124.65.58.213)  4.343 ms  4.336 ms  4.367 ms<br /> 8  202.106.35.190 (202.106.35.190)  1.795 ms 61.148.156.138 (61.148.156.138)  1.899 ms  1.951 ms<br /> 9  * * *<br />30  * * *<br />[root@localhost ~]# <br />说明：<br />记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。<br />有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。<br />有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。<br />如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。\n## Traceroute的工作原理\nTraceroute最简单的基本用法是：traceroute hostname<br />Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器...... traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？<br />Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。<br />Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。\n# scp命令\n## 概述\nscp命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp知识在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读read only system时，用scp可以帮你把文件移出来。另外scp还非常不占资源，不会提高多少系统负荷，在这一点上rsync就远远不及它了。虽然rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。\n## 命令格式\nscp [参数] [原路径] [目标路径]\n## 命令功能\nscp是secure copy的缩写，scp是Linux系统基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在Linux服务器之间复制文件和目录。\n## 命令参数\n\n```\n-1  强制scp命令使用协议ssh1  \n-2  强制scp命令使用协议ssh2  \n-4  强制scp命令只使用IPv4寻址  \n-6  强制scp命令只使用IPv6寻址  \n-B  使用批处理模式（传输过程中不询问传输口令或短语）  \n-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  \n-p 保留原文件的修改时间，访问时间和访问权限。  \n-q  不显示传输进度条。  \n-r  递归复制整个目录。  \n-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。   \n-c cipher  以cipher将数据传输进行加密，这个选项将直接传递给ssh。   \n-F ssh_config  指定一个替代的ssh配置文件，此参数直接传递给ssh。  \n-i identity_file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。    \n-l limit  限定用户所能使用的带宽，以Kbit/s为单位。     \n-o ssh_option  如果习惯于使用ssh_config(5)中的参数传递方式，   \n-P port  注意是大写的P, port是指定数据传输用到的端口号   \n-S program  指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n```\n\n## 常用命令\n实例：从远处复制到本地/从本地复制到远处<br />命令：<br />scp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/<br />scp -r /opt/soft/mongodb root@192.168.120.204:/opt/soft/scptest<br />说明：从192.168.120.204机器上的/opt/soft/中下载mongodb 目录到本地的/opt/soft/目录来。\n",
    "body_draft": "",
    "body_html": "<p>categories: Linux</p><p><br /></p><hr /><p><br /></p><p>&lt;blockquote class=&quot;blockquote-center&quot;&gt;**网络命令**&lt;/blockquote&gt;</p><p>&lt;!-- more --&gt;</p><blockquote><p>      编译：peida     </p><p><span style=\"color: #8C8C8C;\">      链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html</span></p></blockquote><h1 id=\"529370d9\">ifconfig命令</h1><h2 id=\"a4d3b02a\">概述</h2><p>许多Windows非常熟悉ipconfig命令工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有类似的工具，也就是ifconfig（interfaces config）。通常需要以root身份登录或者使用sudo以便在LInux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息等，还可以修改这些配置</p><h2 id=\"7a2b6560\">命令格式</h2><p>ifconfig[网络设备][参数]</p><h2 id=\"abba4775\">命令参数</h2><p><br /></p><pre><code>up 启动指定网络设备/网卡。\ndown 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。\narp 设置指定网卡是否支持ARP协议。\n-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包\n-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包\n-a 显示全部接口信息\n-s 显示摘要信息（类似于 netstat -i）\nadd 给指定网卡配置IPv6地址\ndel 删除指定网卡的IPv6地址\n&lt;硬件地址&gt; 配置网卡最大的传输单元\nmtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)\nnetmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。\ntunel 建立隧道\ndstaddr 设定一个远端地址，建立点对点通信\n-broadcast&lt;地址&gt; 为指定网卡设置广播协议\n-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议\nmulticast 为网卡设置组播标志\naddress 为网卡设置IPv4地址\ntxqueuelen&lt;长度&gt; 为网卡设置传输列队的长度</code></pre><h2 id=\"0dfbe902\">常用命令</h2><p>实例：显示网络设备信息（激活状态的）</p><p>命令：ifconfig</p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:20  </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          collisions:0 txqueuelen:1000 </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX bytes:596390239 (568.7 MiB)  TX bytes:2886956 (2.7 MiB)</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">lo        Link encap:Local Loopback  </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX packets:68 errors:0 dropped:0 overruns:0 frame:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          collisions:0 txqueuelen:0 </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX bytes:2856 (2.7 KiB)  TX bytes:2856 (2.7 KiB)</span></p><p>说明：eth0表示第一块网卡，其中HWaddr表示网卡的物理地址，可以看到目前这个网卡的物理地址（MAC地址）<span class=\"lake-fontsize-10\">是 00:50:56:BF:26:20</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.168.120.204，广播地址， Bcast:192.168.120.255，掩码地址Mask:255.255.255.0 </span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第二行：网卡的IP地址、子网、掩码</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第四、五行：接收、发送数据包情况统计</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">第七行：接收、发送数据字节数统计信息。</span></p><p><span class=\"lake-fontsize-10\"><br /></span></p><p>实例：启动关闭指定网卡</p><p>命令：</p><p style=\"text-indent: 2em;\">ifconfig eth0 up</p><p style=\"text-indent: 2em;\">ifconfig eth0 down</p><p>说明：ifconfig eth0 up 为启动网卡eth0 ；ifconfig eth0 down 为关闭网卡eth0。ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。</p><p><br /></p><p>实例：为网卡配置和删除IPv6地址</p><p>命令：</p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">ifconfig eth0 add 33ffe:3240:800:1005::2/64</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">ifconfig eth0 del 33ffe:3240:800:1005::2/64</span></p><p>说明：</p><p>ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0配置IPv6地址；</p><p>ifconfig eth0 add 33ffe:3240:800:1005::2/64 为网卡eth0删除IPv6地址；</p><p>练习的时候，ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。</p><p><br /></p><p>实例：用ifconfig修改MAC地址</p><p>命令：ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE</p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 down //关闭网卡</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE //修改MAC地址</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 up //启动网卡</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">eth0      Link encap:Ethernet  HWaddr 00:AA:BB:CC:DD:EE  </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          collisions:0 txqueuelen:1000 </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX bytes:596390239 (568.7 MiB)  TX bytes:2886956 (2.7 MiB)</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">lo        Link encap:Local Loopback  </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX packets:68 errors:0 dropped:0 overruns:0 frame:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          collisions:0 txqueuelen:0 </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX bytes:2856 (2.7 KiB)  TX bytes:2856 (2.7 KiB)</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 hw ether 00:50:56:BF:26:20 //关闭网卡并修改MAC地址 </span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 up //启动网卡</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:20  </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          collisions:0 txqueuelen:1000 </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX bytes:596390239 (568.7 MiB)  TX bytes:2886956 (2.7 MiB)</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">lo        Link encap:Local Loopback  </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX packets:68 errors:0 dropped:0 overruns:0 frame:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          collisions:0 txqueuelen:0 </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX bytes:2856 (2.7 KiB)  TX bytes:2856 (2.7 KiB)</span><span style=\"color: #000000;\"> </span></p><p><br /></p><p>实例：配置IP地址</p><p>命令：</p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 192.168.120.56 </span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 192.168.120.56 netmask 255.255.255.0 </span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255</span></p><p>说明：</p><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-10\">ifconfig eth0 192.168.1</span><span class=\"lake-fontsize-10\">20</span><span class=\"lake-fontsize-10\">.56 </span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">给eth0网卡配置IP地</span><span class=\"lake-fontsize-10\">：</span><span class=\"lake-fontsize-10\">192.168.1</span><span class=\"lake-fontsize-10\">20</span><span class=\"lake-fontsize-10\">.56</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\"> ifconfig eth0 192.168.1</span><span class=\"lake-fontsize-10\">20</span><span class=\"lake-fontsize-10\">.56 netmask 255.255.255.0 </span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">给eth0网卡配置IP地址</span><span class=\"lake-fontsize-10\">：</span><span class=\"lake-fontsize-10\">192.168.1</span><span class=\"lake-fontsize-10\">20</span><span class=\"lake-fontsize-10\">.56 </span><span class=\"lake-fontsize-10\">，</span><span class=\"lake-fontsize-10\">并加上子掩码</span><span class=\"lake-fontsize-10\">：</span><span class=\"lake-fontsize-10\">255.255.255.0</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">ifconfig eth0 192.168.1</span><span class=\"lake-fontsize-10\">20</span><span class=\"lake-fontsize-10\">.56 netmask 255.255.255.0 broadcast 192.168.1</span><span class=\"lake-fontsize-10\">20</span><span class=\"lake-fontsize-10\">.255</span></p><p style=\"text-indent: 21pt;\"><span class=\"lake-fontsize-10\">/给eth0网卡配置IP地址</span><span class=\"lake-fontsize-10\">：</span><span class=\"lake-fontsize-10\">192.168.1</span><span class=\"lake-fontsize-10\">20</span><span class=\"lake-fontsize-10\">.56</span><span class=\"lake-fontsize-10\">，</span><span class=\"lake-fontsize-10\">加上子掩码</span><span class=\"lake-fontsize-10\">：</span><span class=\"lake-fontsize-10\">255.255.255.0</span><span class=\"lake-fontsize-10\">，</span><span class=\"lake-fontsize-10\">加上个广播地址</span><span class=\"lake-fontsize-10\">：</span><span class=\"lake-fontsize-10\"> 192.168.1</span><span class=\"lake-fontsize-10\">20</span><span class=\"lake-fontsize-10\">.255</span></p><p><span class=\"lake-fontsize-10\"><br /></span></p><p>实例：启动和关闭ARP协议</p><p>命令：</p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 arp </span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 -arp</span></p><p>说明：</p><p style=\"text-indent: 2em;\">ifconfig eth0 arp 开启网卡eth0 的arp协议；</p><p style=\"text-indent: 2em;\">ifconfig eth0 -arp 关闭网卡eth0 的arp协议；</p><p><br /></p><p>实例：设置最大传输单元</p><p>命令：ifconfig eth0 mtu 1500</p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 mtu 1480</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:1F  </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          inet addr:192.168.120.203  Bcast:192.168.120.255  Mask:255.255.255.0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          UP BROADCAST RUNNING MULTICAST  MTU:1480  Metric:1</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX packets:8712395 errors:0 dropped:0 overruns:0 frame:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          TX packets:36631 errors:0 dropped:0 overruns:0 carrier:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          collisions:0 txqueuelen:1000 </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX bytes:597062089 (569.4 MiB)  TX bytes:2643973 (2.5 MiB)</span><br /></p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig eth0 mtu 1500</span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ifconfig</span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:1F  </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          inet addr:192.168.120.203  Bcast:192.168.120.255  Mask:255.255.255.0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX packets:8712548 errors:0 dropped:0 overruns:0 frame:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          TX packets:36685 errors:0 dropped:0 overruns:0 carrier:0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          collisions:0 txqueuelen:1000 </span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">          RX bytes:597072333 (569.4 MiB)  TX bytes:2650581 (2.5 MiB)</span></p><p>说明：设置能通过的最大数据包大小为1500bytes</p><p>备注：用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在，要想将上述的配置信息永远的存在电脑里，那就要修改网卡的配置文件了。</p><p><br /></p><hr /><p><br /></p><h1 id=\"5b08dd9e\">route命令</h1><h2 id=\"a4d3b02a\">概述</h2><p>Linux系统的toute命令用于显示和操作IP路由表<span style=\"color: #363636;\">（show / manipulate the IP routing table）。要</span><span class=\"lake-fontsize-10\" style=\"color: #363636;\">实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在 Linux 系统中，设置路由通常是为了解决以下问题：该 Linux 系统在一个局域网中，局域网中有一个网关，能够让机器访问 Internet，那么就需要将这台机器的 IP 地址设置为 Linux 机器的默认路由。要注意的是，直接在命令行下执行 route 命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在 / etc/rc.local 中添加 route 命令来保证该路由设置永久有效</span><span class=\"lake-fontsize-10\" style=\"color: #363636;\">。</span></p><h2 id=\"7a2b6560\">命令格式</h2><p><span class=\"lake-fontsize-10\" style=\"color: #363636;\">route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]]</span><span class=\"lake-fontsize-12\" style=\"color: #363636;\"> </span></p><h2 id=\"3b76d0fc\">命令功能</h2><p>Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络连接口，如eth0。当使用参数时，路由表被修改，如果没有参数，则显示路由表当前内容</p><h2 id=\"abba4775\">命令参数</h2><p><br /></p><pre><code>-c 显示更多信息\n-n 不解析名字\n-v 显示详细的处理信息\n-F 显示发送信息\n-C 显示路由缓存\n-f 清除所有网关入口的路由表。 \n-p 与 add 命令一起使用时使路由具有永久性。\nadd: 添加一条新路由。\ndel: 删除一条路由。\n-net: 目标地址是一个网络。\n-host: 目标地址是一个主机。\nnetmask: 当添加一个网络路由时，需要使用网络掩码。\ngw: 路由数据包通过网关。注意，你指定的网关必须能够达到。\nmetric：设置路由跳数。\nCommand 指定您想运行的命令 (Add/Change/Delete/Print)。 \nDestination 指定该路由的网络目标。 \nmask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。 \nGateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。 \nmetric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表 (与转发的数据包目标地址最匹配) 的多个路由中进行选择时可以使用。 \nif Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。</code></pre><h2 id=\"0dfbe902\">常用命令</h2><p>实例：显示当前路由</p><p>命令：</p><p>route</p><p>route -n</p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> route</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">Kernel IP routing table</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">192.168.120.0   *               255.255.255.0   U     0      0        0 eth0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">e192.168.0.0     192.168.120.1   255.255.0.0     UG    0      0        0 eth0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">10.0.0.0        192.168.120.1   255.0.0.0       UG    0      0        0 eth0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #0000FF;\">default</span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">         192.168.120.240 0.0.0.0         UG    0      0        0 eth0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> route -n</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">Kernel IP routing table</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">192.168.120.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">192.168.0.0     192.168.120.1   255.255.0.0     UG    0      0        0 eth0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">10.0.0.0        192.168.120.1   255.0.0.0       UG    0      0        0 eth0</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">0.0.0.0         192.168.120.240 0.0.0.0         UG    0      0        0 eth0</span></p><p>说明：</p><p>第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;</p><p>第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240</p><p>其中Flags为路由标志，标记当前网络节点的状态。</p><p>Flags标志说明：</p><p><br /></p><pre><code>U Up表示此路由当前为启动状态\nH Host，表示此网关为一主机\nG Gateway，表示此网关为一路由器a\nR Reinstate Route，使用动态路由重新初始化的路由\nD Dynamically,此路由是动态性地写入a\nM Modified，此路由是由路由守护程序或导向器动态修改\n! 表示此路由当前为关闭状态</code></pre><p><br /></p><p>备注：route -n (-n 表示不解析名字,列出速度会比route 快)</p><p><br /></p><p>实例：添加网关/设置网管</p><p>命令：<span style=\"color: #363636;\">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0</span></p><p>说明：增加一条 到达 244.0.0.0 的路由</p><p><br /></p><p>实例：删除路由记录</p><p>命令：</p><p>route del -net 224.0.0.0 netmask 240.0.0.0</p><p>route del -net 224.0.0.0 netmask 240.0.0.0 reject</p><p>说明：删除224.0.0.0的路由记录</p><p><br /></p><p>实例 ：删除和添加设置默认网关</p><p>命令：</p><p>route del default gw 192.168.120.240</p><p>route add default gw 192.168.120.240</p><h1 id=\"86fdc4e7\">ping命令</h1><h2 id=\"a4d3b02a\">概述</h2><p>Linux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性，我们经常会说&quot;ping一下某机器，看是不是开着“、不能打开网页时会说&quot;”你先ping网关地址192.168.1.1试试“。</p><p>它通过发送<span style=\"color: #333333;\">ICMP ECHO_REQUEST数据包到网络主机<span style=\"color: #333333;\">（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样而我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。<span style=\"color: #333333;\">有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。</span></span></span></p><p><span class=\"lake-fontsize-10\" style=\"color: #333333;\">linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数</span><span class=\"lake-fontsize-10\" style=\"color: #333333;\">。</span></p><h2 id=\"7a2b6560\">命令格式</h2><p><span style=\"color: #333333;\">ping [参数] [主机名或IP地址]</span></p><h2 id=\"3b76d0fc\">命令功能</h2><p>ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。<span style=\"color: #333333;\">如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。</span></p><p><span style=\"color: #333333;\">ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在</span><strong><span style=\"color: #333333;\">程序超时或当接收到 SIGINT 信号时结束</span></strong><span style=\"color: #333333;\">。Host 参数或者是一个有效的主机名或者是因特网地址。</span></p><h2 id=\"abba4775\">命令参数</h2><p><br /></p><pre><code>-d 使用Socket的SO_DEBUG功能。\n-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。\n-n 只输出数值。\n-q 不显示任何传送封包的信息，只显示最后的结果。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。\n-R 记录路由过程。\n-v 详细显示指令的执行过程。\n&lt;p&gt;-c 数目：在发送指定数目的包后停止。\n-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。\n-I 网络界面：使用指定的网络界面送出数据包。\n-l 前置载入：设置在送出要求信息之前，先行发出的数据包。\n-p 范本样式：设置填满数据包的范本样式。\n-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。\n-t 存活数值：设置存活数值TTL的大小。</code></pre><h2 id=\"0dfbe902\">常用命令</h2><p>实例：ping的通的情况</p><p>命令：ping 192.168.120.205</p><p>输出：</p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ping 192.168.120.205</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">PING 192.168.120.205 (192.168.120.205) 56(84) bytes of data.</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">64 bytes from 192.168.120.205: icmp_seq=1 ttl=64 time=0.720 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">64 bytes from 192.168.120.205: icmp_seq=2 ttl=64 time=0.181 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">64 bytes from 192.168.120.205: icmp_seq=3 ttl=64 time=0.191 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">64 bytes from 192.168.120.205: icmp_seq=4 ttl=64 time=0.188 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">64 bytes from 192.168.120.205: icmp_seq=5 ttl=64 time=0.189 ms</span><br /><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">--- 192.168.120.205 ping statistics ---</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">5 packets transmitted, 5 received, 0% packet loss, time 4000ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">rtt min/avg/max/mdev = 0.181/0.293/0.720/0.214 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> </span></p><p><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span></p><p>实例：ping不通的情况</p><p>命令：ping 192.168.120.202</p><p>输出：</p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> ping 192.168.120.202</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">PING 192.168.120.202 (192.168.120.202) 56(84) bytes of data.</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">From 192.168.120.204 icmp_seq=1 Destination Host Unreachable</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">From 192.168.120.204 icmp_seq=2 Destination Host Unreachable</span></p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\"><br /></span></p><p>实例：ping指定次数</p><p>命令：ping -c 10 192.168.120.206</p><p><br /></p><p>实例：时间间隔和次数限制的ping</p><p>命令：ping -c 10 -i 0.5 192.168.120.206</p><p><br /></p><p>实例：多参数使用</p><p>命令：ping -i 3 -s 1024 -t 255 192.168.120.206</p><p>说明：-i 3 发送周期为 3秒 -s 设置发送包的大小为1024 -t 设置TTL值为 255</p><h1 id=\"58574632\">traceroute命令</h1><h2 id=\"a4d3b02a\">概述</h2><p>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。</p><p>在大多数情况下，我们会在linux主机系统下，直接执行命令行：</p><p>traceroute hostname</p><p>而在Windows系统下是执行tracert的命令：</p><p>tracert hostname</p><h2 id=\"7a2b6560\">命令格式</h2><p><span style=\"color: #333333;\">traceroute[参数][主机]</span></p><h2 id=\"3b76d0fc\">命令功能</h2><p>traceroute命令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;...][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小]</p><h2 id=\"abba4775\">命令参数</h2><p><br /></p><pre><code>-d 使用Socket层级的排错功能。\n-f 设置第一个检测数据包的存活数值TTL的大小。\n-F 设置勿离断位。\n-g 设置来源路由网关，最多可设置8个。\n-i 使用指定的网络界面送出数据包。\n-I 使用ICMP回应取代UDP资料信息。\n-m 设置检测数据包的最大存活数值TTL的大小。\n-n 直接使用IP地址而非主机名称。\n-p 设置UDP传输协议的通信端口。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n-s 设置本地主机送出数据包的IP地址。\n-t 设置检测数据包的TOS数值。\n-v 详细显示指令的执行过程。\n-w 设置等待远端主机回报的时间。\n-x 开启或关闭数据包的正确性检验。</code></pre><h2 id=\"0dfbe902\">常用命令</h2><p>实例1：traceroute 用法简单、最常用的用法</p><p>命令：</p><p>traceroute www.baidu.com</p><p>输出：</p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> traceroute www.baidu.com</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"><br /></span><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\"> 1  192.168.74.2 (192.168.74.2)  2.606 ms  2.771 ms  2.950 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\"> 2  211.151.56.57 (211.151.56.57)  0.596 ms  0.598 ms  0.591 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\"> 3  211.151.227.206 (211.151.227.206)  0.546 ms  0.544 ms  0.538 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\"> 4  210.77.139.145 (210.77.139.145)  0.710 ms  0.748 ms  0.801 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\"> 5  202.106.42.101 (202.106.42.101)  6.759 ms  6.945 ms  7.107 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\"> 6  61.148.154.97 (61.148.154.97)  718.908 ms * bt-228-025.bta.net.cn (202.106.228.25)  5.177 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\"> 7  124.65.58.213 (124.65.58.213)  4.343 ms  4.336 ms  4.367 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\"> 8  202.106.35.190 (202.106.35.190)  1.795 ms 61.148.156.138 (61.148.156.138)  1.899 ms  1.951 ms</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\"> 9  * * *</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">30  * * *</span><br /><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost ~]</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\">#</span><span class=\"lake-fontsize-9\" style=\"color: #008000;\"> </span></p><p>说明：</p><p>记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。</p><p>有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。</p><p>有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。</p><p>如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。</p><h2 id=\"332ed3d6\">Traceroute的工作原理</h2><p>Traceroute最简单的基本用法是：traceroute hostname</p><p>Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器...... traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？</p><p>Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。</p><p>Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。</p><h1 id=\"a49161d7\">scp命令</h1><h2 id=\"a4d3b02a\">概述</h2><p>scp命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp知识在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读read only system时，用scp可以帮你把文件移出来。另外scp还非常不占资源，不会提高多少系统负荷，在这一点上rsync就远远不及它了。虽然rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p><h2 id=\"7a2b6560\">命令格式</h2><p><span class=\"lake-fontsize-10\" style=\"color: #333333;\">s</span><span class=\"lake-fontsize-10\" style=\"color: #333333;\">cp</span><span style=\"color: #333333;\"> </span><span class=\"lake-fontsize-10\" style=\"color: #333333;\">[参数]</span><span style=\"color: #333333;\"> </span><span class=\"lake-fontsize-10\" style=\"color: #333333;\">[原路径]</span><span style=\"color: #333333;\"> </span><span class=\"lake-fontsize-10\" style=\"color: #333333;\">[目标路径]</span></p><h2 id=\"3b76d0fc\">命令功能</h2><p>scp是secure copy的缩写，scp是Linux系统基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在Linux服务器之间复制文件和目录。</p><h2 id=\"abba4775\">命令参数</h2><p><br /></p><pre><code>-1  强制scp命令使用协议ssh1  \n-2  强制scp命令使用协议ssh2  \n-4  强制scp命令只使用IPv4寻址  \n-6  强制scp命令只使用IPv6寻址  \n-B  使用批处理模式（传输过程中不询问传输口令或短语）  \n-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）  \n-p 保留原文件的修改时间，访问时间和访问权限。  \n-q  不显示传输进度条。  \n-r  递归复制整个目录。  \n-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。   \n-c cipher  以cipher将数据传输进行加密，这个选项将直接传递给ssh。   \n-F ssh_config  指定一个替代的ssh配置文件，此参数直接传递给ssh。  \n-i identity_file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。    \n-l limit  限定用户所能使用的带宽，以Kbit/s为单位。     \n-o ssh_option  如果习惯于使用ssh_config(5)中的参数传递方式，   \n-P port  注意是大写的P, port是指定数据传输用到的端口号   \n-S program  指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</code></pre><p><br /></p><h2 id=\"0dfbe902\">常用命令</h2><p>实例：从远处复制到本地/<span>从本地复制到远处</span></p><p>命令：</p><p>scp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/</p><p><span style=\"color: #333333;\">scp -r /opt/soft/mongodb root@192.168.120.204:/opt/soft/scptest</span></p><p>说明：从192.168.120.204机器上的/opt/soft/中下载mongodb 目录到本地的/opt/soft/目录来。</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-28T14:58:01.000Z",
    "deleted_at": null,
    "created_at": "2019-01-28T14:24:23.000Z",
    "updated_at": "2019-02-06T06:38:51.000Z",
    "published_at": "2019-02-06T06:38:51.000Z",
    "first_published_at": "2019-01-28T14:24:23.000Z",
    "word_count": 6674,
    "cover": "",
    "description": "categories: Linux&lt;blockquote class=&quot;blockquote-center&quot;&gt;**网络命令**&lt;/blockquote&gt;&lt;!-- more --&gt;      编译：peida           链接：ht...",
    "custom_description": "categories: Linux&lt;blockquote class=&quot;blockquote-center&quot;&gt;**网络命令**&lt;/blockquote&gt;&lt;!-- more --&gt;      编译：peida           链接：ht...",
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1194425,
    "slug": "num_155",
    "title": "155. Min Stack",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 19,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-13T01:08:41.500Z",
      "updated_at": "2019-02-13T01:08:41.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n![155.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548684459282-96ae33fe-d713-417e-beb2-dbf9a2e6a76c.png#align=left&display=inline&height=763&linkTarget=_blank&name=155.png&originHeight=763&originWidth=622&size=105378&width=622)<br /><!-- more -->\n## 题目描述\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n* push(x) -- Push element x onto stack.\n* pop() -- Removes the element on top of the stack.\n* top() -- Get the top element.\n* getMin() -- Retrieve the minimum element in the stack.\n\n**Example:**<br /><br />MinStack minStack = new MinStack();<br />minStack.push(-2);<br />minStack.push(0);<br />minStack.push(-3);<br />minStack.getMin();   --> Returns -3.<br />minStack.pop();<br />minStack.top();      --> Returns 0.<br />minStack.getMin();   --> Returns -2.\n## 参考代码\n```java\nclass MinStack {\n        private Stack<Integer> stackData;\n        private Stack<Integer> stackMin;\n    /** initialize your data structure here. */\n    public MinStack() { \n        stackData = new Stack<Integer>();\n        stackMin = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        stackData.push(x);\n        if(stackMin.isEmpty() || x <= stackMin.peek()) {//最小值栈的为空或这最小值小于等于\n            stackMin.push(x);\n        } \n    }\n    \n    public void pop() {\n        Integer num = stackData.pop();\n        if(num.equals(stackMin.peek())) {//要用equals函数\n            stackMin.pop();\n        }\n        \n    }\n    \n    public int top() {\n            return stackData.peek();\n    }\n    \n    public int getMin() {\n            return stackMin.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n```\n\n## 思路及总结\n利用两个栈，一个代表最小值，一个代表普通情况。注意最小值栈要依靠普通栈，普通栈中最小值出栈，最小值栈的最小值也要出栈。另外自己基础太差，wrong answer的时候一直没发现要用equals才能进行更合理的比较。希望自己以后更深入的时候能有更好的理解。<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548684031905-32a04870-a970-4d7c-ab23-65964876cfbc.png#align=left&display=inline&height=1535&linkTarget=_blank&name=image.png&originHeight=1535&originWidth=2733&size=1480656&width=2733)\n## 参考\n[https://blog.csdn.net/loophome/article/details/83749444](https://blog.csdn.net/loophome/article/details/83749444)<br />[https://blog.csdn.net/returnzhang/article/details/78608898](https://blog.csdn.net/returnzhang/article/details/78608898)\n",
    "body_draft": "categories: leetcode\n\n---\n<!-- more -->\n## 题目描述\n\n## 参考代码\n\n## 思路及总结\n\n## 参考\n\n",
    "body_html": "<p>categories: leetcode</p><p><br /></p><hr /><p><img alt=\"155.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1548684459282-96ae33fe-d713-417e-beb2-dbf9a2e6a76c.png#align=left&amp;display=inline&amp;height=763&amp;linkTarget=_blank&amp;name=155.png&amp;originHeight=763&amp;originWidth=622&amp;size=105378&amp;width=622\" style=\"max-width: 600px; width: 622px;\" /></p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) -- Push element x onto stack.</li><li>pop() -- Removes the element on top of the stack.</li><li>top() -- Get the top element.</li><li>getMin() -- Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong><br /></p><p>MinStack minStack = new MinStack();</p><p>minStack.push(-2);</p><p>minStack.push(0);</p><p>minStack.push(-3);</p><p>minStack.getMin();   --&gt; Returns -3.</p><p>minStack.pop();</p><p>minStack.top();      --&gt; Returns 0.</p><p>minStack.getMin();   --&gt; Returns -2.</p><h2 id=\"36967e2c\">参考代码</h2><pre data-lang=\"java\"><code>class MinStack {\n        private Stack&lt;Integer&gt; stackData;\n        private Stack&lt;Integer&gt; stackMin;\n    /** initialize your data structure here. */\n    public MinStack() { \n        stackData = new Stack&lt;Integer&gt;();\n        stackMin = new Stack&lt;Integer&gt;();\n    }\n    \n    public void push(int x) {\n        stackData.push(x);\n        if(stackMin.isEmpty() || x &lt;= stackMin.peek()) {//最小值栈的为空或这最小值小于等于\n            stackMin.push(x);\n        } \n    }\n    \n    public void pop() {\n        Integer num = stackData.pop();\n        if(num.equals(stackMin.peek())) {//要用equals函数\n            stackMin.pop();\n        }\n        \n    }\n    \n    public int top() {\n            return stackData.peek();\n    }\n    \n    public int getMin() {\n            return stackMin.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(x);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */</code></pre><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p>利用两个栈，一个代表最小值，一个代表普通情况。注意最小值栈要依靠普通栈，普通栈中最小值出栈，最小值栈的最小值也要出栈。另外自己基础太差，wrong answer的时候一直没发现要用equals才能进行更合理的比较。希望自己以后更深入的时候能有更好的理解。</p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1548684031905-32a04870-a970-4d7c-ab23-65964876cfbc.png#align=left&amp;display=inline&amp;height=1535&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=1535&amp;originWidth=2733&amp;size=1480656&amp;width=2733\" style=\"max-width: 600px; width: 2733px;\" /></p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://blog.csdn.net/loophome/article/details/83749444\" target=\"_blank\">https://blog.csdn.net/loophome/article/details/83749444</a></p><p><a href=\"https://blog.csdn.net/returnzhang/article/details/78608898\" target=\"_blank\">https://blog.csdn.net/returnzhang/article/details/78608898</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-28T14:07:42.000Z",
    "deleted_at": null,
    "created_at": "2019-01-28T06:16:10.000Z",
    "updated_at": "2019-01-28T14:07:42.000Z",
    "published_at": "2019-01-28T14:07:42.000Z",
    "first_published_at": "2019-01-28T06:16:47.000Z",
    "word_count": 350,
    "cover": null,
    "description": "categories: leetcode&lt;!-- more --&gt;题目描述Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.push(x)...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1190850,
    "slug": "num_215",
    "title": "215. 数组中的第K个最大元素",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 19,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-13T01:08:41.500Z",
      "updated_at": "2019-02-13T01:08:41.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n![215.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548506060055-118e8488-7b24-4981-8a99-75880675fde5.png#align=left&display=inline&height=411&linkTarget=_blank&name=215.png&originHeight=806&originWidth=1464&size=153252&width=746)<br /><!-- more -->\n## 题目描述\n在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br />**示例 1:**\n**输入:** ```\n[3,2,1,5,6,4] 和\n```\n k = 2\n**输出:** 5**示例 2:**\n**输入:** ```\n[3,2,3,1,2,4,5,5,6] 和\n```\n k = 4\n**输出:** 4**说明:**<br />你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n## 参考代码\n\n```java\nclass Solution {\n   public static int findKthLargest(int[] nums, int k) {\n\t\tPriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n       for(int num :nums) {\n           priorityQueue.add(num);\n           if(priorityQueue.size() > k) {\n               priorityQueue.poll();\n           }\n       }\n       return priorityQueue.peek();\n   }\n}\n```\n\n## 思路及总结\n主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。\n## 参考\n[https://www.kancloud.cn/maliming/leetcode/844880](https://www.kancloud.cn/maliming/leetcode/844880)\n",
    "body_draft": "",
    "body_html": "<p>categories: leetcode</p><p><br /></p><hr /><p><img alt=\"215.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1548506060055-118e8488-7b24-4981-8a99-75880675fde5.png#align=left&amp;display=inline&amp;height=411&amp;linkTarget=_blank&amp;name=215.png&amp;originHeight=806&amp;originWidth=1464&amp;size=153252&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> <code>[3,2,1,5,6,4] 和</code> k = 2\n<strong>输出:</strong> 5</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> <code>[3,2,3,1,2,4,5,5,6] 和</code> k = 4\n<strong>输出:</strong> 4</pre><p><strong>说明:</strong></p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h2 id=\"36967e2c\">参考代码</h2><p><br /></p><pre data-lang=\"java\"><code>class Solution {\n   public static int findKthLargest(int[] nums, int k) {\n\t\tPriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;();\n       for(int num :nums) {\n           priorityQueue.add(num);\n           if(priorityQueue.size() &gt; k) {\n               priorityQueue.poll();\n           }\n       }\n       return priorityQueue.peek();\n   }\n}</code></pre><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p>主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。</p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://www.kancloud.cn/maliming/leetcode/844880\" target=\"_blank\">https://www.kancloud.cn/maliming/leetcode/844880</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-26T12:40:34.000Z",
    "deleted_at": null,
    "created_at": "2019-01-26T12:27:39.000Z",
    "updated_at": "2019-01-27T10:35:56.000Z",
    "published_at": "2019-01-26T12:40:34.000Z",
    "first_published_at": "2019-01-26T12:28:52.000Z",
    "word_count": 301,
    "cover": null,
    "description": "categories: leetcode&lt;!-- more --&gt;题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。示例 1:输入: [3,2,1,5,6,4] 和 k = 2 输出: 5示例 2:输...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1184808,
    "slug": "num_11",
    "title": "11. Container With Most Water",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 17,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-18T14:57:05.225Z",
      "updated_at": "2019-02-18T14:57:05.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n\n\n![](https://cdn.nlark.com/yuque/0/2019/png/203310/1548413561701-4da063ec-2c59-45b0-8b3d-2e876a9be112.png)<br /><!-- more -->\n## 题目描述\nGiven _n_ non-negative integers _a_, _a_, ..., _a_, where each represents a point at coordinate (_i_, _a_). _n_ vertical lines are drawn such that the two endpoints of line _i_ is at (_i_, _a_) and (_i_, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br />**Note: **You may not slant the container and _n_ is at least 2.<br /> <br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/203310/1550501812423-3cf8d9bb-dbe9-4829-817f-e4e20fc81e24.jpeg#align=left&display=inline&height=287&linkTarget=_blank&originHeight=383&originWidth=801&size=0&width=600)<br />The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.<br /> <br />**Example:**\n**Input:** [1,8,6,2,5,4,8,3,7]\n**Output:** 49\n## 参考代码\n\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int max = 0;\n        boolean temp;\n        for(int i = 0,j = height.length - 1;i < j;) {\n            int h = (height[i] > height[j]) ? height[j] : height[i];\n            if(h * (j - i)>max) max = h * (j - i);\n            temp = (height[i] < height[j]) ? true : false;\n            \n            if(temp) i++;\n            else j--;\n        }\n        return max;\n    }\n}\n```\n## 思路及总结\n较为简单的思路就是采用双指针，从两边往中间逼近，并没有什么边界问题，主要是注意在寻找最多水的容器过程中要一直把较深的一边留下，即沿着较小的边界进行移动（因为较小的边界不可能再产生更多的水）。\n## 参考\n[https://blog.csdn.net/qq_40435621/article/details/84790436](https://blog.csdn.net/qq_40435621/article/details/84790436)\n",
    "body_draft": "",
    "body_html": "<p><span>categories: leetcode</span></p><p><span><br /></span></p><hr /><p><br /></p><p><br /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1548413561701-4da063ec-2c59-45b0-8b3d-2e876a9be112.png\" style=\"width: 724px; height: 457px;\" /></p><p><span>&lt;!-- more --&gt;</span></p><h2 id=\"273a27cc\">题目描述</h2><p>Given <em>n</em> non-negative integers <em>a<sub>1</sub></em>, <em>a<sub>2</sub></em>, ..., <em>a<sub>n </sub></em>, where each represents a point at coordinate (<em>i</em>, <em>a<sub>i</sub></em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>a<sub>i</sub></em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p><strong>Note: </strong>You may not slant the container and <em>n</em> is at least 2.</p><p> </p><p><img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/203310/1550501812423-3cf8d9bb-dbe9-4829-817f-e4e20fc81e24.jpeg#align=left&amp;display=inline&amp;height=287&amp;linkTarget=_blank&amp;originHeight=383&amp;originWidth=801&amp;size=0&amp;width=600\" style=\"max-width: 600px; width: 600px;\" /></p><p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><p> </p><p><strong>Example:</strong></p><pre><strong>Input:</strong> [1,8,6,2,5,4,8,3,7]\n<strong>Output:</strong> 49</pre><p><br /></p><h2 id=\"36967e2c\">参考代码</h2><p><br /></p><pre data-lang=\"java\"><code>class Solution {\n    public int maxArea(int[] height) {\n        int max = 0;\n        boolean temp;\n        for(int i = 0,j = height.length - 1;i &lt; j;) {\n            int h = (height[i] &gt; height[j]) ? height[j] : height[i];\n            if(h * (j - i)&gt;max) max = h * (j - i);\n            temp = (height[i] &lt; height[j]) ? true : false;\n            \n            if(temp) i++;\n            else j--;\n        }\n        return max;\n    }\n}</code></pre><h2 id=\"d7d37168\">思路及总结</h2><p>较为简单的思路就是采用双指针，从两边往中间逼近，并没有什么边界问题，主要是注意在寻找最多水的容器过程中要一直把较深的一边留下，即沿着较小的边界进行移动（因为较小的边界不可能再产生更多的水）。</p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://blog.csdn.net/qq_40435621/article/details/84790436\" target=\"_blank\">https://blog.csdn.net/qq_40435621/article/details/84790436</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-18T14:57:05.000Z",
    "deleted_at": null,
    "created_at": "2019-01-24T13:02:11.000Z",
    "updated_at": "2019-02-18T14:57:05.000Z",
    "published_at": "2019-02-18T14:57:05.000Z",
    "first_published_at": "2019-01-24T13:16:42.000Z",
    "word_count": 302,
    "cover": null,
    "description": "categories: leetcode&lt;!-- more --&gt;题目描述Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n v...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1146359,
    "slug": "vim_skill",
    "title": "Vim实用技巧",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 21,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-28T07:30:26.315Z",
      "updated_at": "2019-02-28T07:30:26.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 4,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-26T11:15:43.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 4,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-26T11:15:43.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Vim\n\n---\n\n<blockquote class=\"blockquote-center\">**希望由厚至薄**</blockquote><br /><!-- more -->\n\n![](https://cdn.nlark.com/yuque/0/2019/jpeg/203310/1547523970324-ad085afb-d91a-4b7a-bc5e-07c6133eeca7.jpeg#align=left&display=inline&height=614&linkTarget=_blank&originHeight=693&originWidth=552&size=0&status=done&width=489)\n<a name=\"a4d3b02a\"></a>\n# 概述\n 学习Vim，最难受的就是它对新手出名的不友好，网上一大堆乱七八糟的东西，还是自己进行学习对自己的帮助最大。建议首先学习 :vimtutor 入门vim学习。最好会盲打，自己看了这本 vim 实用技巧。\n<a name=\"454d0617\"></a>\n# 第 1 章 Vim解决问题的方式\n{char} 是指任意字符<br /><CR> 指<Enter><br />cw会删除光标位置到当前词位置结尾处的文本，并进入插入模式<br />>G是首行缩进<br />C=c$ 删除到行尾再插入<br />o=A<CR>下一行插入<br />s删除光标处再插入<br />@：重复命令行命令<br />&重复替换命令<br />f{char} 搜索，; 下一个字符，, 上一个字符<br />* 可以查看当前光标下的单词<br />理想模式：用一个键移动，另一键执行。又称为 “.范式”。\n<a name=\"d65edfb7\"></a>\n# 第一部分 模式\nVim 提供一个区分模式的用户界面，就是说在 Vim 中按键盘上的任意键所产生的结果可能会不一样，而这取决于当前正处于哪种模式，以及如何在各模式间切换，是极其重要的。在本书的这一部分，我们将学习每种模式的工作方式及其用途。\n<a name=\"f5859b09\"></a>\n## 第 2 章 普通模式\nb 把光标移动到单词开头<br />daw 在单词末尾也能删除<br /><c-a> 在数字上执行加一，不在数字上，在当前行正向查找一个数字，10<c-a><br /><c-x> 在数字上执行减一<br />最好不要用数字 d2w 这样，因为 . 能很好代替，但是 c3w 有用，行中间来快速进行修改<br />g~ 反转大小写，gu 转成小写，gU转成大写。gUap 将一段转换为大写，g 当成操作符前缀<br />gc{motion} 切换为注释状态，gcap 切换当前段落的注释状态。gcG 当前行到文件结尾间的所有内容注释掉，gcc 注释当前行，gg=G 自动缩进整个文件。\n<a name=\"e67876bd\"></a>\n## 第 3 章 插入模式\n在输入错误时，专业打字员会建议先删除整个单词，然后再重新输入一遍。<br /><c-h> 删除前一个字符（同退格键）<c-w> 删除前一个单词<c-u> 删至行首。<br /><c-[>切换到普通模式，<c-o> 切换到插入-普通模式。在此模式中，可以执行一个普通模式命令，执行完后，马上又返回到插入模式\n\n| 按键操作 | 缓冲区内容 |  |\n| --- | --- | --- |\n| yt,  | Practical Vim, by Drew Neil<br />Read Drew Neil's |  |\n| jA␣ | Practical Vim, by Drew Neil<br />Read Drew Neil's |  |\n| <C-r>0 | Practical Vim, by Drew Neil<br />Read Drew Neil's Practical Vim |  |\n| .<Esc> | Practical Vim, by Drew Neil<br />Read Drew Neil's Practical Vim. |  |\n\nyt, 命令把“Practical Vim”复制到复制专用寄存器中,<C-r>0 把刚才复制的文本粘贴到光<br />标所在位置<br />= 符号指明使用表达式寄存器,<C-r>=6*35<CR>，将执行结果插入到文档的当前位置<br /><C-v>{code}根据字符编码插入字符，{code} 是要插入字符的编码，<C-v>065插入A<br /><C-v>u{1234} 以十六进制字符编码插入字符<br />ga 分别以十进制和十六进制的形式显示出其字符编码<br /><C-k>{char1}{char2} 插入以**二合字母**{char1}{char2}表示的字符，<C-k>?I 表示的“¿”字符，二合字母 12 指1⁄2<br />R 命令可以由普通模式进入替换模式，“,␣b” 替换原有的“. ␣ B”字符<br />gR 进入虚拟替换模式(Virtual Replace mode)，把制表符当成一组空格进行处理，输入制表符占据的最后一个字符，该字符会替换制表符。\n<a name=\"4e7f5ecd\"></a>\n## 第 4 章 可视模式\nviw 来高亮选择这个词,用 c 命令进行修改<br />V 激活面向行的可视模式<br /><C-v> 激活面向列块的可视模式<br />gv 重选上次的高亮选区<br />o 切换高亮选区的活动端，vbb ，o ，e<br />重复执行面向行的可视命令，Vj ，>.<br />vit 可被解读为高亮选中标签内部的内容(visually select inside the tag),it 命令是一种被称为文本对象(text object)<br />gUit 要优于 vitU 命令，首选操作符命令，再者是可是模式命令，可视模式擅长一次性处理和动作命令难以构建的文本范围<br />技巧24 面向列块的可是模式编辑表格数据，在一行下生成分割线 yyp，Vr-<br />列块可视模式,插入操作只影响顶行，但实际影响所有，插入模式时间很短暂<br />I 命令把光标置于当前行的开头\n<a name=\"007fa2d7\"></a>\n## 第 5 章 命令行模式\n有些命令在插入模式和命令行模式中可以通用。例如,可以用 <C-w> 和 <C-u>分别删除至上个单词的开头及行首,也可以用 <C-v> 或 <C-k> 来插入键盘上找不到的字符,还可以用 <C-r>{register} 命令把任意寄存器的内容插入到命令行。Ex 命令可以在任意位置执行\n\n:3d 等于 3G dd 一定程度上要比普通模式命令要快<br />. 代表当前行的地址，:.,$d 这样的命令可能很实用<br />% 代表当前文件中的所有行，:%s/Practical/Pragmatic/<br />可视模式加命令行模式，VG，输入 ：命令行上就会预先填充一个范围 :'<,'> 。代表高亮选区的范围<br />:6copy. 命令解读为“为第 6 行创建一份副本,并放到当前行下方”，:copy 简写:co 或是 :t<br />:t6 把当前行复制到第 6 行下方，:t$ 把当前行复制到文本结尾<br />快速跳回原先的位置( <C-o> )，在复制距离较远的行时, :t 命令通常更加高效。<br />: yyp 会使用寄存器，不想覆盖默认寄存器中的当前内容时，可以考虑使用 :t. 来复制行<br />:'<,'>m$ 等于 :'<,'>m$，重复上次的 Ex 命令 @:<br />'<,'>normal . 命令可以解读为“对高亮选区中的每一行,对其执行普通模式下的 . 命令”。<br />:%normal i// 把整个 JavaScript 文件注释掉<br />:normal 命令则让我们可以把具有强大表现力的 Vim 普通模式命令与具有大范围影响力的 Ex 命令结合在一起<br />遍历缓冲区列表的条目，:bn[ext] 可以在列表中逐项正向移动,而 :bp[revious] 命令则进行反向移动\n\n逐个查看每个缓冲区 :bnext，@: 命令和:bprevious 命令可能会出现反向遍历缓冲区列表，将人搞糊涂，更好用<C-o> 命令，该命令会回到跳转列表的上条记录。想往回跳,就用 <C-o> 命令。\n\n<C-d> 命令会让 Vim 显示可用的补全列表，按 <Tab> 键依次显示<br /><C-r><C-w> 用于插入光标下的单词，插入光标下的字串<C-r><C-a>，一般和 * 、:%s 一起使用，:%s//<C-r><C-w>/g<br />命令行窗口就像是一个常规的 Vim 缓冲区,只不过它的每行内容都对应着命令历史中的一个条目。我们可以用 k 及 j 键在历史中向前或向后移动,也可以用 Vim 的查找功能查找某一行。在按下 <CR> 键时,将会把当前行的内容当成 Ex 命令加以执行。好处是强大的vim编辑能力可以派上用场。<br />q: 调出命令行窗口，J 命令合并下一行，命令行窗口处于打开状态时,它会始终拥有焦点。<br /><Ctrl-f> 从命令行模式切换到命令行窗口，已经输入到命令行上的内容仍然会得以保留<br />:!ls 执行 Shell 中的程序，在 Vim 的命令行中,符号 % 代表当前文件名(指调用了shell程序时)<br />执行几条命令:shell 命令来启动一个交互的 shell 会话,用 exit 命令可以退出此 shell 并返回 Vim<br />把 Vim 置于后台，看书 p 94 <br />命令会产生大量输出，用:read !{cmd} 命令，它让我们把命令的标准输出重定向到缓冲区。<br />:write !{cmd} 做相反的事。它把缓冲区内容作为指定 {cmd} 的标准输入<br />:write! sh 把缓冲区内容写到一个名为 sh 的文件，叹号放得位置不同,命令的作用]也大相径庭。<br />:write !sh 命 令 的 作 用 是 在 shell 中 执 行 当 前 缓 冲 区 中 的 每 行 内 容<br />Vim 把过滤器定义为“一个由标准输入读取文本,并对其进行某种形式的修改后输出到标准输出的程序”<br />:2,$!sort -t',' -k2，命令行结合 shell 来对文本进行处理。<br />Vim 提供了一种方便的快捷方式来设置 :[range]!{filter} 命令中的范围。我们可以用 !{motion} 操作符切换到命令行模式,并把指定 {motion} 所涵盖的范围预置在命令行上，如果我们把光标移到第 2 行,然后执行 !G ,Vim 就会打开命令行并把范围 :.,$! 预置在命令行上。虽然此后我们仍需输入剩下的 {filter} 命令,但这毕竟节省了部分工作。<br />:read !{cmd} 在 shell 中执行 {cmd} ,并把其标准输出插入到光标下方<br />:[range]write !{cmd} 在 shell 中执行 {cmd} ,以 [range] 作为其标准输入<br />:[range]!{filter} 使用外部程序 {filter} 过滤指定的 [range]\n<a name=\"b76203f4\"></a>\n# 第二部分 文件\n在本书的这一部分，我们将学习如何使用文件及缓冲区。Vim 允许在一个编辑会话中编辑多个文件，我们既可以每次显示一个文件，也可以把工作区分成若干个分割窗口或标签页，每个窗口或标签页包含一个独立的缓冲区。另外，我们还会看到在 Vim 中打开文件的机种不同方式，并掌握一些方法来解决无法把缓冲区保存到文件的问题。\n<a name=\"d239b0a0\"></a>\n## 第 6 章 管理多个文件\n我们编辑的只是内存中的映像，也就是 Vim 术语中的“缓冲区”。 \n\n:ls 命令会列出所有被载入到内存中的缓冲区的列表， :bnext 命令可以切换到列表中的下一个缓冲区，% 符号指明哪个缓冲区在当前窗口中可见，而 # 符号则代表轮换文件。按 <C-^> 可以在当前文件和轮换文件间快速切换。\n\n:bprev (bp) 和 :bnext (bn)在列表中反向或正向移动；而 :bfirst 和 :blast 则分别跳到列表的开头和结尾\n\n```bash\n《 1 #  \"a.txt\"   line 1\n\t 2 %a  \"b.txt\"   line 1 \n```\n\n:buffer N 命令直接凭编号跳转到一个缓冲区，:buffer {bufname} 格式实现同样的功能。{bufname} 只需包含文件路径中 足以唯一标识此缓冲区的字符即可\n\n删除缓冲区，可以用 :bdelete 命令, :5,10bd ,删除编号 5～10（包含 5 和 10）的缓冲区\n\n用 :argdo 命令可以在参数列表中的每个文件上执行一条 Ex 命令。 当不带参数运行 :args 命令时，它会打印当前参数列表的内容。 :args {arglist} {arglist} 可以包括文件名、通配符，甚至是一条 shell 命令的输出结果\n\n填充参数列表最简单的方式是逐一指定文件的名字：➾ :args index.html app.js  ** 通配符也匹配 0 个或多个字符，但它可以递归进入指定目录的子目录 :args **/*.js ,  :args **/*.js **/*.css  :args `cat .chapters`\n\n按 Go 在缓冲区的结尾增加一个空行,缓冲区 a.txt 前有一个 + 号，表示这个缓冲区被修改过了,被标记为 h，表示它是一个隐藏缓冲区（hidden）\n\n:w[rite] 把缓冲区内容写入磁盘 :e[dit]! 把磁盘文件内容读入缓冲区（即回滚所做修改） :qa[ll]! 关闭所有窗口，摒弃修改而无需警告 :wa[ll]! 把所有改变的缓冲区写入磁盘 \n\n启用‘hidden’选项,运行完 :argdo {cmd} 后,一切正常，可以运行 :argdo write （或 :wall）来保存所有的缓冲区。\n\n用 <C-w>s 命令可以水平切分此窗口，使之成 为两个高度相同的窗口；或者可以用 <C-w>v 命令对其进行垂直切分，这样会产生两 个宽度相同的窗口\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1550644590245-77a4763f-ed46-470e-9a1d-4512ea7167ac.png#align=left&display=inline&height=503&linkTarget=_blank&name=image.png&originHeight=503&originWidth=685&size=34313&status=done&width=685)<br />编辑长文件时,可以滚动其中一个窗口，使之显示缓冲区的一部分，这样，在修改第二 个窗口中缓冲区的另外一部分时，就可以参考第一个窗口中的内容。\n\n:sp[lit] {file} 水平切分当前窗口，并在新窗口中载入{file} :vsp[lit] {file} 垂直切分当前窗口，并在新窗口中载入{file}<br /><C-w>w 在窗口间循环切换 <C-w>h 切换到左边的窗口 <C-w>j 切换到下边的窗口 <C-w>k 切换到上边的窗口 <C-w>l 切换到右边的窗口,按住 <Ctrl> 键，然后再输入 ww （或 wj ，或上表中的其他命令）来切换活动窗口。 \n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1550645102529-39f26124-6f39-4015-9320-753465134bd9.png#align=left&display=inline&height=152&linkTarget=_blank&name=image.png&originHeight=152&originWidth=842&size=25654&status=done&width=842)\n\n<C-w>= 使所有窗口等宽、等高 <C-w>_ 最大化活动窗口的高度 <C-w>|  最大化活动窗口的宽度 [N]<C-w>_  把活动窗口的高度设为[N]行 [N]<C-w>| 把活动窗口的宽度设为[N]列,用鼠标做最好\n\n用 :edit 命令打开一个文件时，Vim 却不会自动创建一 个新标签页，而是会创建一个新缓冲区，并把该缓冲区显示到当前窗口。应该把标签页想成容纳一系 列窗口的容器\n\n:lcd {path} 命令让我们可以设置当前窗口的本地工作目录。如果我们创建了一 个新标签页，并用 :lcd 命令切换到另一个目录，那么就可以把每个标签页限制在不 同的工程范围内。用 :tabedit {filename} 命令可以打开一个新的标签页，如果省略了 {filename} 参数的话，那么 Vim 会创建一个新标签页，里面包含一个空缓冲区\n\n<C-w>T 命 令把当前窗口移到一个新标签页中 :tabc[lose] 关闭当前标签页及其中的所有窗口 :tabo[nly] 只保留活动标签页，关闭所有其他标签页<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1550645990944-5586df98-b275-4ac8-9663-185a464c59af.png#align=left&display=inline&height=199&linkTarget=_blank&name=image.png&originHeight=199&originWidth=896&size=36002&status=done&width=896)\n\n :tabmove [N] 命令可以重新排列标签页。省略了 [N]，当前标签页会被移到结尾，如果支持鼠标，则用鼠标拖拽\n\n<a name=\"a185fab5\"></a>\n## 第 7 章 打开及保存文件\n:edit {file} 命令可以接受相对于工作目录的文件路径\n\n% 符号代表活动缓冲区的完整文件路径，:h 修饰符会去除文件名，但保留路径中的其他部分 :edit %:h<Tab>M<Tab> \n\n $ vim . 在按<CR> 键时，Vim 会打开光标下的条 目。如果光标位于目录上，那么此窗口的内容会更新为该目录的内容；如果光标位于文件上，那么该文件会被载入一个缓冲区里，并把它显示在当前窗口中。这将导致当 前窗口中的文件管理器被该缓冲区的内容所替代<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1550646730436-643f6d61-8093-40cb-a791-42b31a95f6a4.png#align=left&display=inline&height=464&linkTarget=_blank&name=image.png&originHeight=464&originWidth=807&size=97939&status=done&width=807)\n\n:edit . :e. 打开文件管理器，并显示当前工作目录 :Explore :E 打开文件管理器，并显示活动缓冲区所在的目录 :E 及 :e. 命令表现得有些古怪，因为它们会用文件管理器替换掉当前窗口的内容，想象成一张纸牌，如果在调出文 件管理器后，又想切换回刚才正在编辑的那个文件，此时可以使用 <C-^> 命令。 \n\n杀手级功能，其名字正因为此功能而来，即 netrw 可 以通过网络读写文件。该插件可以利用多种协议读写网络文件，包括 scp、ftp、curl 及 wget，这取决于你的系统上可以用哪些协议。（手动流汗）\n\n<C-g> 命令用于显示当前文件的文件名及状态，以超级用户执行，tee /etc/hosts > /dev/null。这条命令会把缓冲区的内容当作标准输入，并用它来覆盖 /etc/hosts 文件的内容，下面文件与缓冲区的内容刚好是完全一致的。<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1550647263953-ba725e78-53c9-4888-a1c3-01bf77f715ab.png#align=left&display=inline&height=233&linkTarget=_blank&name=image.png&originHeight=233&originWidth=747&size=32937&status=done&width=747)\n<a name=\"3852f4b5\"></a>\n# 第三部分 更快地移动及跳转\n动作命令是进行 Vim 操作的最重要的一些命令。我们不仅可以用它们四处移动光标，还能够用它们与操作符待决模式配合使用，指定一段文本范围并在其上进行操作。在本书的这一部分，我们将结识一些最为有用的动作命令，另外，我们还会学习 Vim 的跳转命令，这些命令让我们可以在文件间快速地跳转。\n<a name=\"ec48adac\"></a>\n## 第 8 章 用动作命令在文档中移动\n我们不用把手从本位行上移开，就可以上下左右移动，操作符待决模式中最出彩的明星是文本对象<br />如果你在一行中连续按了两次以上的 h 键，那就是在浪费时间（手动流汗）。\n\n即 j、k、0和 $ 都用于操作实际行，而如果在这些 键前加上 g 前缀的话，就会让 Vim 对屏幕行进行操作\n\nw 正向移动到下一单词的开头   (for-)word<br />b 反向移动到当前单词/上一单词的开头  back-word<br />e 正向移动到当前单词/下一单词的结尾<br />ge 反向移动到上一单词的结尾<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1551021099056-92eee3a8-553a-4244-a911-5215fed7c090.png#align=left&display=inline&height=241&linkTarget=_blank&name=image.png&originHeight=301&originWidth=542&size=46783&status=done&width=434)<br />ea 命令连在一起可被解读为“在当前单词结尾后添加”<br />gea 命令当成“在上一单词结尾后 添加”的命令\n\n我们之前遇到过的每个面向单词的动作命令，都有一个面向字串的命令与其对 应，这当中包括 W、B、E和 gE<br />一个单词由字母、数字、下划线，或其他非空白字符的序列组成，单词间以空白 字符分隔，字串的定义则更简单，它由非空白字符序列组成， 字串间以空白字符分隔\n\nVim 会记录 上次执行过的 f{char} 命令，随后用 ; 命令就可以重复该命令了，用 , 命令就可以再跳回来<br />f{char} 正向移动到下一个 {char} 所在之处<br />F{char} 反向移动到上一个 {char} 所在之处<br />t{char} 正向移动到下一个 {char} 所在之处的前一个字符上<br />T{char} 反向移动到上一个 {char} 所在之处的后一个字符上<br />; 重复上次的字符查找命令<br />, 反转方向查找上次的字符查找命令<br /> f,dt.训练成手指的下意识动作（删除 , 和 . 之间的内容）\n\n缺省的<Leader> 键是 \\\n\n查找命令不仅限于在普通模式下使用，我们也可以在可视模式及操作符待决模式 中使用它，用来完成实际的工作<br />删除工作会更方便，先高亮然后通过命令行模式进行大范围选择。<br />d/ge<CR> 用 /ge<CR> 查找动作告诉 d{motion} 命令删除什么。查找命令是 一个开动作，也就是说，虽然光标是在单词“gets”开头的“g”上的，但此字符却被 排除在删除操作之外，用 v 还需要 h 一下<br />把 d{motion} 操作符与查找动作结 合在一起使用，这是个很大的进步，你可以好好在朋友和同事们面前炫耀一番了\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1551022390533-baf49e0f-bcdf-4264-bee3-76f4eb4e25f8.png#align=left&display=inline&height=427&linkTarget=_blank&name=image.png&originHeight=534&originWidth=578&size=49815&status=done&width=462)\n\n可以把 i 想成“inside”，而把 a 想成 “around” 或“all”。<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1551022505589-cada3bcd-b055-427d-a850-31630f07c346.png#align=left&display=inline&height=453&linkTarget=_blank&name=image.png&originHeight=566&originWidth=484&size=75169&status=done&width=387)\n\n文本对象自身并不是动作命令，我们不能用它们在文档中移动。但是我们却可以 在可视模式及操作符待决模式中使用文本对象 ：每当在命令语法里看到 {motion} 时，你也可以在这个地方使用文本对象，常见的例子包括 d{motion}、 c{motion}和 y{motion} <br />把 ci\" 命令解读为“修改双引号内部的内容”，把 cit 命令解读为“修 改标签内部的内容”。另外，我们也可以很容易地用 yit 命令拷贝标签内的文本，或 者是用 dit 删除这些文本。\n\n如果说 f{char} 和 /pattern<CR> 命令如同单足飞踹， 那么文本对象则像是一次攻击两个目标的剪刀腿<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1551022681107-241777fb-ce43-4d52-819c-c55c1b28e6c7.png#align=left&display=inline&height=218&linkTarget=_blank&name=image.png&originHeight=272&originWidth=685&size=31159&status=done&width=548)\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1551022790391-f03ad92b-de0b-4381-9ce9-7ac70b68ef19.png#align=left&display=inline&height=279&linkTarget=_blank&name=image.png&originHeight=349&originWidth=350&size=28484&status=done&width=280)<br />iw 和 aw 之间的区别很微妙，为什么会需要这样两个文本对象呢？<br />ciw 命令只删除该单词，而不删除其前后的空白字符，随后它会进入插入模式， 这刚好是我们想要的效果。如果用的是 caw 的话，那最后两个单词就会连在一起<br />一般来说，d{motion} 命令和 aw、as 和 ap 配合起来使用比较好，而 c{motion} 命令和 iw 及类似的文本对象一起用效果会更好。\n\nm{a-zA-Z} 命令会用选定的字母标记当前光标所在位置,mm 和 `m 命令是一对便于使用的命令，它们分别设置位置标记 m，以及跳转到 该标记<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1551060576906-eb4d92e6-28f9-40f9-8c9c-4be5ccba3c49.png#align=left&display=inline&height=209&linkTarget=_blank&name=image.png&originHeight=262&originWidth=438&size=34262&status=done&width=350)<br />% 命令允许我们在一组开、闭括号间跳转,在执行 % 命令时，Vim 会 自动为发生跳转的地方设置一个位置标记, % 命令只能用在配对的括号上,所以利用替换命令时最好利用位置标记，防止陷阱。\n<a name=\"08071332\"></a>\n## 第 9 章 在文件间跳转\n:jumps 查看跳转列表的内容，如果我们运行 :edit 命令 打开了一个新文件，那么就可以用 <C-o> 和 <C-i> 命令在这个新文 件以及原本的文件之间来回跳转，会始终在 当前活动窗口的跳转列表范围内进行跳转， Vim 本来就把 <C-i> 和 <Tab> 当成同一个东西。映射需谨慎。\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1551063629792-edf970a6-eef3-440f-95bf-5eb3cff4325f.png#align=left&display=inline&height=242&linkTarget=_blank&name=image.png&originHeight=303&originWidth=593&size=47322&status=done&width=474)<br />Vim 会在编辑会话期间维护一张表，里面记载我们对每个缓冲区所做的修改， 此表就是所谓的改变列表 :changes，用 g; 和 g, 命令反向或正向遍历改变列表。改变列表中则保存了多组位置。我们可以多次按 g; 命令，每次它都会把 我们带到改变列表中较早的一个位置，而 `. 则总是把我们带到改变列表的最后一项。\n\n执行 gf 命令“go to file”加上 .rb 扩展名，用 ‘suffixesadd’ 选项做到这一点 :set suffixesadd+=.rb<br />查看 'path' 选项的值<br />:set path?<br />《 path=.,/usr/include,,<br /><C-]> 命令的作用也类似。它也需要进行一些配置（在技巧 102 中讨论），然而 一旦正确配置好，它就允许我们从函数调用的地方直接跳到该函数定义的地方\n\n用两次按键就可以打开你的 vimrc 文件，先打开你的 vimrc 文件，按 mV 设置一个全局标记（助记词 V 代 表 vimrc），然后切换到另一个文件中按 `V\n\n缺省情况下，:vimgrep 会直接跳到它所找到的第一处匹配上，这或许会切换到 另外一个文件。<br />一般来说，要养成在使用与 quickfix 列表有关的命令前，如:grep、:vimgrep 及:make，设置全局标记的习惯。另外，在执行与缓冲区列表或参数列表有关的命令前， 如:args {arglist}和:argdo（参见技巧 37），也要设置全局标记。 你总共可以设置 26 个全局位置标记，可以迅速跳回。\n\n<a name=\"2e0bcfbf\"></a>\n# 第四部分 寄存器\nVim 的寄存器是一组用于保存文件的简单容器。它们既可像剪贴板那样，剪切、复制和粘贴文本；也可以记录一系列按键操作，把它们录制成宏。通过本书的这一部分，我们将掌握这一核心功能。\n<a name=\"59b9a56d\"></a>\n## 第 10 章 复制与粘贴\nxp，可被用于“调换光标之后的两个字符”ddp，可被用于“调换当前行和它的下一行” \n\ndiw 命令不仅删除了单词，而且还将它拷贝到了无名寄存器，按 P时得到的是刚刚删除的单词，而不是之前复制的单词，给命令加 \"{register} 前缀的方式指定要用的寄存器，Vim 将缺省使用无 名寄存器。\"ayiw复制，用 \"bdd删除，\"ap粘贴，可以解决无名寄存器的问题，使用复制寄存器也可以解决，黑洞集训器从删除方面也可以解决\n\nVim 的 delete 命令也与标准剪切操作的作用一致。也就是说，该命令会先把 指定文本复制到寄存器后再从文档中删掉，引用黑洞寄存器，\"_d{motion}会执行真正的删除操作。\n\n无名寄存器（\"\"）， \"\"p，它完全等同于 p命令，x 和 d{motion} 经常被当作“删除”命 令。这其实是用词不当，把它们理解为“剪切”命令会更合适\n\n复制专用寄存器（\"0）使用 y{motion} 命令时，要复制的文本不仅会被拷贝到无名寄存器中，而且也被拷贝到了复制专用寄存器中，因为专用，只有 y 能触发\n\n检查无名寄存器和复制专用寄存器的内容，:reg \"0 ，小问题用复制专用寄存器，如果碰到需要将一段或多段文本粘贴到多处的情况，有名寄存器就会大显神通。用小写字母引用有名寄存器，会覆盖该寄存器的原有内容，而换用大写字母的话，则会将新内容添加到该寄存器的原有内容之后\n\n如果我们在外部程序中用剪切或复制命令获取了文本，就可以通过 \"+p 命令（或 在插入模式下用 <C-r>+）将其粘贴到 Vim 内部。相反地，如果在 Vim 的复制或删除 命令之前加入 \"+ ，相应的文本将被捕获至系统剪贴板。<br />\"+ X11 剪贴板，用剪切、复制与粘贴命令操作 \"* X11 主剪贴板，用鼠标中键操作把它们粘贴出来，Windows与Mac OS X操作系统并没有主剪贴板的概念，因此 \"+ 寄存器与 \"* 寄 存器可以混用，它们都代表系统剪贴板。\n\n表达式寄存器（\"=）当我们从表达式寄存器获取内容时，Vim 将跳到命 令行模式，并显示提示符“=”。这时，我们可以输入一段 Vim 脚本表达式并按 <CR> 执行，如果返回的是字符串（或者可被强制转换成字符串的数据），Vim 将会使用它\n\n只读寄存器 \"% 当前文件名 \"# 轮换文件名 \". 上次插入的文本 \": 上次执行的Ex命令 \"/ 上次查找的模式 \n\n在可视模式下使用 p 命令时，Vim 将用我们指定的寄存器内容来替换高亮选区中的文本，可视再次解决了文本\"丢失\"现象，我们输入 u 撤销上次的修改。然后，按 gv重选上一次高亮选区的内容，再按一次 p键。发生了什么？显然什么也没发生，第一次使用 p时，之所以成功，是因为无名寄存器恰巧包含了我们想要的 文本。但在第二次使用 p时，无名寄存器包含的是被覆盖的内容，所以可是模式替换内容也会进入无名寄存器\n\n在 Vim 的可视模式下使用 p命令时。首先，从无名寄存器里取出内容，然后，把高亮选区中的内容存入无名寄存器。（花里胡哨）\n\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1551176775970-4a023ff6-26fa-4f41-8fb3-ecab6fe9c7da.png#align=left&display=inline&height=125&linkTarget=_blank&name=image.png&originHeight=125&originWidth=364&size=13396&status=done&width=364)<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1551176803751-7d556e52-aa61-4993-8056-4abf12f643c7.png#align=left&display=inline&height=174&linkTarget=_blank&name=image.png&originHeight=174&originWidth=363&size=15099&status=done&width=363)<br />c3w命令删除“chips and fish”并重新输入“fish and chips”， 应该会更快地完成任务。但是，以上方法可被用于交换更长的短语\n\np 命令旨在将寄存器中的文本粘贴到光标之后，P 命令用于将文本插入到光标之前，puP 和 Pup几乎成了下意识动作。当要粘贴的内容来自于面向行的寄存器时，p 和 P 命令会把它们粘贴至当前行的 上一行或下一行。这一点比面向字符的行为更直观\n\n在插入模式下，我们可以通过输入 <C-r>\" 来插入无名寄存器的内容，或者输入 <C-r>0来插入复制专用寄存器的内容<br />gp和 gP命令也值得关注，它们会把光标的位置移到被粘贴出来的文本结尾而不是开头。 当复制多行文本时，gP命令尤为管用，P 和 gP 命令区别\n\n如果你运行的 Vim 是已集成系统剪贴板的版本，就可以完全避免与'paste' 选项打交道了。普通模式下的 \"+p 命令用来粘贴加号寄存器中的内容，即系统剪 贴板的镜像。\n<a name=\"b51d83bf\"></a>\n## 第 11章 宏\n\n",
    "body_draft": "",
    "body_html": "<p>categories: Vim</p><p><br /></p><hr /><p><br /></p><p>&lt;blockquote class=&quot;blockquote-center&quot;&gt;**希望由厚至薄**&lt;/blockquote&gt;</p><p>&lt;!-- more --&gt;</p><p><br /></p><p style=\"text-align: center;\"><img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/203310/1547523970324-ad085afb-d91a-4b7a-bc5e-07c6133eeca7.jpeg#align=left&amp;display=inline&amp;height=614&amp;linkTarget=_blank&amp;originHeight=693&amp;originWidth=552&amp;size=0&amp;status=done&amp;width=489\" style=\"max-width: 600px; width: 489px;\" /></p><h1 id=\"a4d3b02a\">概述</h1><p> 学习Vim，最难受的就是它对新手出名的不友好，网上一大堆乱七八糟的东西，还是自己进行学习对自己的帮助最大。建议首先学习 :vimtutor 入门vim学习。最好会盲打，自己看了这本 vim 实用技巧。</p><h1 id=\"454d0617\">第 1 章 Vim解决问题的方式</h1><p>{char} 是指任意字符</p><p>&lt;CR&gt; 指&lt;Enter&gt;</p><p>cw会删除光标位置到当前词位置结尾处的文本，并进入插入模式</p><p>&gt;G是首行缩进</p><p><span style=\"color: #F5222D;\">C=c$ 删除到行尾再插入</span></p><p>o=A&lt;CR&gt;下一行插入</p><p>s删除光标处再插入</p><p>@：重复命令行命令</p><p>&amp;重复替换命令</p><p>f{char} 搜索，; 下一个字符，, 上一个字符</p><p>* 可以查看当前光标下的单词</p><p>理想模式：用一个键移动，另一键执行。又称为 “.范式”。</p><h1 id=\"d65edfb7\">第一部分 模式</h1><p style=\"text-indent: 2em;\">Vim 提供一个区分模式的用户界面，就是说在 Vim 中按键盘上的任意键所产生的结果可能会不一样，而这取决于当前正处于哪种模式，以及如何在各模式间切换，是极其重要的。在本书的这一部分，我们将学习每种模式的工作方式及其用途。</p><h2 id=\"f5859b09\">第 2 章 普通模式</h2><p>b 把光标移动到单词开头</p><p>daw 在单词末尾也能删除</p><p>&lt;c-a&gt; 在数字上执行加一，不在数字上，在当前行正向查找一个数字，10<span>&lt;c-a&gt;</span></p><p>&lt;c-x&gt; 在数字上执行减一</p><p>最好不要用数字 d2w 这样，因为 . 能很好代替，但是 c3w 有用，行中间来快速进行修改</p><p>g~ 反转大小写，gu 转成小写，gU转成大写。gUap 将一段转换为大写，g 当成操作符前缀</p><p>gc{motion} 切换为注释状态，gcap 切换当前段落的注释状态。gcG 当前行到文件结尾间的所有内容注释掉，gcc 注释当前行，gg=G 自动缩进整个文件。</p><h2 id=\"e67876bd\">第 3 章 插入模式</h2><p>在输入错误时，专业打字员会建议先删除整个单词，然后再重新输入一遍。</p><p>&lt;c-h&gt; 删除前一个字符（同退格键）&lt;c-w&gt; 删除前一个单词&lt;c-u&gt; 删至行首。</p><p>&lt;c-[&gt;切换到普通模式，&lt;c-o&gt; 切换到插入-普通模式。在此模式中，可以执行一个普通模式命令，执行完后，马上又返回到插入模式</p><table class=\"lake-table\" style=\"width: 721px;\"><colgroup><col width=\"240\"></col><col width=\"240\"></col><col width=\"240\"></col></colgroup><tbody><tr><td><p>按键操作</p></td><td><p>缓冲区内容</p></td><td><p><br /></p></td></tr><tr><td rowspan=\"1\" colspan=\"1\"><span style=\"color: #262626; background-color: #FFFFFF;\">yt,<span> </span></span></td><td rowspan=\"1\" colspan=\"1\"><p><span style=\"color: #262626; background-color: #FFFFFF;\">Practical Vim, by Drew Neil</span></p><p><span style=\"color: #262626; background-color: #FFFFFF;\"><span>Read Drew Neil's</span></span></p></td><td><p><br /></p></td></tr><tr><td><p><span>jA␣</span></p></td><td><p><span>Practical Vim, by Drew Neil</span><br /><span>Read Drew Neil's</span></p></td><td><p><br /></p></td></tr><tr><td colspan=\"1\" style=\"background-color: #FFFFFF;\"><p><span>&lt;C-r&gt;0</span></p></td><td colspan=\"1\" rowspan=\"1\" style=\"background-color: #FFFFFF;\"><span style=\"color: #262626; background-color: #FFFFFF;\">Practical Vim, by Drew Neil</span><br /><span style=\"color: #262626; background-color: #FFFFFF;\">Read Drew Neil's Practical Vim</span></td><td colspan=\"1\" style=\"background-color: #FFFFFF;\"><p><br /></p></td></tr><tr><td colspan=\"1\" rowspan=\"1\" style=\"background-color: #FFFFFF;\"><p>.&lt;Esc&gt;</p></td><td colspan=\"1\" style=\"background-color: #FFFFFF;\"><p><span>Practical Vim, by Drew Neil</span><br /><span>Read Drew Neil's Practical Vim.</span></p></td><td colspan=\"1\" style=\"background-color: #FFFFFF;\"><p><br /></p></td></tr></tbody></table><p>yt, 命令把“Practical Vim”复制到复制专用寄存器中,&lt;C-r&gt;0 把刚才复制的文本粘贴到光</p><p>标所在位置</p><p>= 符号指明使用表达式寄存器,&lt;C-r&gt;=6*35&lt;CR&gt;，将执行结果插入到文档的当前位置</p><p>&lt;C-v&gt;{code}根据字符编码插入字符，{code} 是要插入字符的编码，&lt;C-v&gt;065插入A</p><p>&lt;C-v&gt;u{1234} 以十六进制字符编码插入字符</p><p>ga 分别以十进制和十六进制的形式显示出其字符编码</p><p>&lt;C-k&gt;{char1}{char2} 插入以<strong>二合字母</strong>{char1}{char2}表示的字符，&lt;C-k&gt;?I 表示的“¿”字符，二合字母 12 指1⁄2</p><p>R 命令可以由普通模式进入替换模式，“,␣b” 替换原有的“. ␣ B”字符</p><p>gR 进入虚拟替换模式(Virtual Replace mode)，把制表符当成一组空格进行处理，输入制表符占据的最后一个字符，该字符会替换制表符。</p><h2 id=\"4e7f5ecd\">第 4 章 可视模式</h2><p>viw 来高亮选择这个词,用 c 命令进行修改</p><p>V 激活面向行的可视模式</p><p>&lt;C-v&gt; 激活面向列块的可视模式</p><p>gv 重选上次的高亮选区</p><p>o 切换高亮选区的活动端，vbb ，o ，e</p><p>重复执行面向行的可视命令，Vj ，&gt;.</p><p>vit 可被解读为高亮选中标签内部的内容(visually select inside the tag),it 命令是一种被称为文本对象(text object)</p><p>gUit 要优于 vitU 命令，首选操作符命令，再者是可是模式命令，可视模式擅长一次性处理和动作命令难以构建的文本范围</p><p>技巧24 面向列块的可是模式编辑表格数据，在一行下生成分割线 yyp，Vr-</p><p>列块可视模式,插入操作只影响顶行，但实际影响所有，插入模式时间很短暂</p><p>I 命令把光标置于当前行的开头</p><h2 id=\"007fa2d7\">第 5 章 命令行模式</h2><p style=\"text-indent: 2em;\">有些命令在插入模式和命令行模式中可以通用。例如,可以用 &lt;C-w&gt; 和 &lt;C-u&gt;分别删除至上个单词的开头及行首,也可以用 &lt;C-v&gt; 或 &lt;C-k&gt; 来插入键盘上找不到的字符,还可以用 &lt;C-r&gt;{register} 命令把任意寄存器的内容插入到命令行。Ex 命令可以在任意位置执行</p><p><br /></p><p>:3d 等于 3G dd 一定程度上要比普通模式命令要快</p><p>. 代表当前行的地址，:.,$d 这样的命令可能很实用</p><p>% 代表当前文件中的所有行，:%s/Practical/Pragmatic/</p><p>可视模式加命令行模式，VG，输入 ：命令行上就会预先填充一个范围 :'&lt;,'&gt; 。代表高亮选区的范围</p><p>:6copy. 命令解读为“为第 6 行创建一份副本,并放到当前行下方”，:copy 简写:co 或是 :t</p><p>:t6 把当前行复制到第 6 行下方，:t$ 把当前行复制到文本结尾</p><p>快速跳回原先的位置( &lt;C-o&gt; )，在复制距离较远的行时, :t 命令通常更加高效。</p><p>: yyp 会使用寄存器，不想覆盖默认寄存器中的当前内容时，可以考虑使用 :t. 来复制行</p><p>:'&lt;,'&gt;m$ 等于 :'&lt;,'&gt;m$，重复上次的 Ex 命令 @:</p><p>'&lt;,'&gt;normal . 命令可以解读为“对高亮选区中的每一行,对其执行普通模式下的 . 命令”。</p><p>:%normal i// 把整个 JavaScript 文件注释掉</p><p>:normal 命令则让我们可以把具有强大表现力的 Vim 普通模式命令与具有大范围影响力的 Ex 命令结合在一起</p><p>遍历缓冲区列表的条目，:bn[ext] 可以在列表中逐项正向移动,而 :bp[revious] 命令则进行反向移动</p><p><br /></p><p>逐个查看每个缓冲区 :bnext，@: 命令和:bprevious 命令可能会出现反向遍历缓冲区列表，将人搞糊涂，更好用&lt;C-o&gt; 命令，该命令会回到跳转列表的上条记录。想往回跳,就用 &lt;C-o&gt; 命令。</p><p><br /></p><p>&lt;C-d&gt; 命令会让 Vim 显示可用的补全列表，按 &lt;Tab&gt; 键依次显示</p><p>&lt;C-r&gt;&lt;C-w&gt; 用于插入光标下的单词，插入光标下的字串&lt;C-r&gt;&lt;C-a&gt;，一般和 * 、:%s 一起使用，:%s//&lt;C-r&gt;&lt;C-w&gt;/g</p><p>命令行窗口就像是一个常规的 Vim 缓冲区,只不过它的每行内容都对应着命令历史中的一个条目。我们可以用 k 及 j 键在历史中向前或向后移动,也可以用 Vim 的查找功能查找某一行。在按下 &lt;CR&gt; 键时,将会把当前行的内容当成 Ex 命令加以执行。好处是强大的vim编辑能力可以派上用场。</p><p>q: 调出命令行窗口，J 命令合并下一行，命令行窗口处于打开状态时,它会始终拥有焦点。</p><p>&lt;Ctrl-f&gt; 从命令行模式切换到命令行窗口，已经输入到命令行上的内容仍然会得以保留</p><p>:!ls 执行 Shell 中的程序，在 Vim 的命令行中,符号 % 代表当前文件名(指调用了shell程序时)</p><p>执行几条命令:shell 命令来启动一个交互的 shell 会话,用 exit 命令可以退出此 shell 并返回 Vim</p><p>把 Vim 置于后台，看书 p 94 </p><p>命令会产生大量输出，用:read !{cmd} 命令，它让我们把命令的标准输出重定向到缓冲区。</p><p>:write !{cmd} 做相反的事。它把缓冲区内容作为指定 {cmd} 的标准输入</p><p>:write! sh 把缓冲区内容写到一个名为 sh 的文件，叹号放得位置不同,命令的作用]也大相径庭。</p><p>:write !sh 命 令 的 作 用 是 在 shell 中 执 行 当 前 缓 冲 区 中 的 每 行 内 容</p><p>Vim 把过滤器定义为“一个由标准输入读取文本,并对其进行某种形式的修改后输出到标准输出的程序”</p><p>:2,$!sort -t',' -k2，命令行结合 shell 来对文本进行处理。</p><p>Vim 提供了一种方便的快捷方式来设置 :[range]!{filter} 命令中的范围。我们可以用 !{motion} 操作符切换到命令行模式,并把指定 {motion} 所涵盖的范围预置在命令行上，如果我们把光标移到第 2 行,然后执行 !G ,Vim 就会打开命令行并把范围 :.,$! 预置在命令行上。虽然此后我们仍需输入剩下的 {filter} 命令,但这毕竟节省了部分工作。</p><p>:read !{cmd} 在 shell 中执行 {cmd} ,并把其标准输出插入到光标下方</p><p>:[range]write !{cmd} 在 shell 中执行 {cmd} ,以 [range] 作为其标准输入</p><p>:[range]!{filter} 使用外部程序 {filter} 过滤指定的 [range]</p><h1 id=\"b76203f4\">第二部分 文件</h1><p style=\"text-indent: 2em;\">在本书的这一部分，我们将学习如何使用文件及缓冲区。Vim 允许在一个编辑会话中编辑多个文件，我们既可以每次显示一个文件，也可以把工作区分成若干个分割窗口或标签页，每个窗口或标签页包含一个独立的缓冲区。另外，我们还会看到在 Vim 中打开文件的机种不同方式，并掌握一些方法来解决无法把缓冲区保存到文件的问题。</p><h2 id=\"d239b0a0\">第 6 章 管理多个文件</h2><p>我们编辑的只是内存中的映像，也就是 Vim 术语中的“缓冲区”。 </p><p><br /></p><p>:ls 命令会列出所有被载入到内存中的缓冲区的列表， :bnext 命令可以切换到列表中的下一个缓冲区，% 符号指明哪个缓冲区在当前窗口中可见，而 # 符号则代表轮换文件。按 &lt;C-^&gt; 可以在当前文件和轮换文件间快速切换。</p><p><br /></p><p>:bprev (bp) 和 :bnext (bn)在列表中反向或正向移动；而 :bfirst 和 :blast 则分别跳到列表的开头和结尾</p><p><br /></p><pre data-lang=\"bash\"><code>《 1 #  &quot;a.txt&quot;   line 1\n\t 2 %a  &quot;b.txt&quot;   line 1 </code></pre><p><br /></p><p>:buffer N 命令直接凭编号跳转到一个缓冲区，:buffer {bufname} 格式实现同样的功能。{bufname} 只需包含文件路径中 足以唯一标识此缓冲区的字符即可</p><p><br /></p><p>删除缓冲区，可以用 :bdelete 命令, :5,10bd ,删除编号 5～10（包含 5 和 10）的缓冲区</p><p><br /></p><p>用 :argdo 命令可以在参数列表中的每个文件上执行一条 Ex 命令。 当不带参数运行 :args 命令时，它会打印当前参数列表的内容。 :args {arglist} {arglist} 可以包括文件名、通配符，甚至是一条 shell 命令的输出结果</p><p><br /></p><p>填充参数列表最简单的方式是逐一指定文件的名字：➾ :args index.html app.js  ** 通配符也匹配 0 个或多个字符，但它可以递归进入指定目录的子目录 :args **/*.js ,  :args **/*.js **/*.css  :args `cat .chapters`</p><p><br /></p><p>按 Go 在缓冲区的结尾增加一个空行,缓冲区 a.txt 前有一个 + 号，表示这个缓冲区被修改过了,被标记为 h，表示它是一个隐藏缓冲区（hidden）</p><p><br /></p><p>:w[rite] 把缓冲区内容写入磁盘 :e[dit]! 把磁盘文件内容读入缓冲区（即回滚所做修改） :qa[ll]! 关闭所有窗口，摒弃修改而无需警告 :wa[ll]! 把所有改变的缓冲区写入磁盘 </p><p><br /></p><p>启用‘hidden’选项,运行完 :argdo {cmd} 后,一切正常，可以运行 :argdo write （或 :wall）来保存所有的缓冲区。</p><p><br /></p><p>用 &lt;C-w&gt;s 命令可以水平切分此窗口，使之成 为两个高度相同的窗口；或者可以用 &lt;C-w&gt;v 命令对其进行垂直切分，这样会产生两 个宽度相同的窗口</p><p><br /></p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1550644590245-77a4763f-ed46-470e-9a1d-4512ea7167ac.png#align=left&amp;display=inline&amp;height=503&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=503&amp;originWidth=685&amp;size=34313&amp;status=done&amp;width=685\" style=\"max-width: 600px; width: 685px;\" /></p><p>编辑长文件时,可以滚动其中一个窗口，使之显示缓冲区的一部分，这样，在修改第二 个窗口中缓冲区的另外一部分时，就可以参考第一个窗口中的内容。</p><p><br /></p><p>:sp[lit] {file} 水平切分当前窗口，并在新窗口中载入{file} :vsp[lit] {file} 垂直切分当前窗口，并在新窗口中载入{file}</p><p>&lt;C-w&gt;w 在窗口间循环切换 &lt;C-w&gt;h 切换到左边的窗口 &lt;C-w&gt;j 切换到下边的窗口 &lt;C-w&gt;k 切换到上边的窗口 &lt;C-w&gt;l 切换到右边的窗口,按住 &lt;Ctrl&gt; 键，然后再输入 ww （或 wj ，或上表中的其他命令）来切换活动窗口。 </p><p><br /></p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1550645102529-39f26124-6f39-4015-9320-753465134bd9.png#align=left&amp;display=inline&amp;height=152&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=152&amp;originWidth=842&amp;size=25654&amp;status=done&amp;width=842\" style=\"max-width: 600px; width: 842px;\" /></p><p><br /></p><p>&lt;C-w&gt;= 使所有窗口等宽、等高 &lt;C-w&gt;_ 最大化活动窗口的高度 &lt;C-w&gt;|  最大化活动窗口的宽度 [N]&lt;C-w&gt;_  把活动窗口的高度设为[N]行 [N]&lt;C-w&gt;| 把活动窗口的宽度设为[N]列,用鼠标做最好</p><p><br /></p><p>用 :edit 命令打开一个文件时，Vim 却不会自动创建一 个新标签页，而是会创建一个新缓冲区，并把该缓冲区显示到当前窗口。应该把标签页想成容纳一系 列窗口的容器</p><p><br /></p><p>:lcd {path} 命令让我们可以设置当前窗口的本地工作目录。如果我们创建了一 个新标签页，并用 :lcd 命令切换到另一个目录，那么就可以把每个标签页限制在不 同的工程范围内。用 :tabedit {filename} 命令可以打开一个新的标签页，如果省略了 {filename} 参数的话，那么 Vim 会创建一个新标签页，里面包含一个空缓冲区</p><p><br /></p><p>&lt;C-w&gt;T 命 令把当前窗口移到一个新标签页中 :tabc[lose] 关闭当前标签页及其中的所有窗口 :tabo[nly] 只保留活动标签页，关闭所有其他标签页</p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1550645990944-5586df98-b275-4ac8-9663-185a464c59af.png#align=left&amp;display=inline&amp;height=199&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=199&amp;originWidth=896&amp;size=36002&amp;status=done&amp;width=896\" style=\"max-width: 600px; width: 896px;\" /></p><p><br /></p><p> :tabmove [N] 命令可以重新排列标签页。省略了 [N]，当前标签页会被移到结尾，如果支持鼠标，则用鼠标拖拽</p><p><br /></p><h2 id=\"a185fab5\">第 7 章 打开及保存文件</h2><p>:edit {file} 命令可以接受相对于工作目录的文件路径</p><p><br /></p><p>% 符号代表活动缓冲区的完整文件路径，:h 修饰符会去除文件名，但保留路径中的其他部分 :edit %:h&lt;Tab&gt;M&lt;Tab&gt; </p><p><br /></p><p> $ vim . 在按&lt;CR&gt; 键时，Vim 会打开光标下的条 目。如果光标位于目录上，那么此窗口的内容会更新为该目录的内容；如果光标位于文件上，那么该文件会被载入一个缓冲区里，并把它显示在当前窗口中。这将导致当 前窗口中的文件管理器被该缓冲区的内容所替代</p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1550646730436-643f6d61-8093-40cb-a791-42b31a95f6a4.png#align=left&amp;display=inline&amp;height=464&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=464&amp;originWidth=807&amp;size=97939&amp;status=done&amp;width=807\" style=\"max-width: 600px; width: 807px;\" /></p><p><br /></p><p>:edit . :e. 打开文件管理器，并显示当前工作目录 :Explore :E 打开文件管理器，并显示活动缓冲区所在的目录 :E 及 :e. 命令表现得有些古怪，因为它们会用文件管理器替换掉当前窗口的内容，想象成一张纸牌，如果在调出文 件管理器后，又想切换回刚才正在编辑的那个文件，此时可以使用 &lt;C-^&gt; 命令。 </p><p><br /></p><p>杀手级功能，其名字正因为此功能而来，即 netrw 可 以通过网络读写文件。该插件可以利用多种协议读写网络文件，包括 scp、ftp、curl 及 wget，这取决于你的系统上可以用哪些协议。（<span style=\"color: #F5222D;\">手动流汗</span>）</p><p><br /></p><p>&lt;C-g&gt; 命令用于显示当前文件的文件名及状态，以超级用户执行，tee /etc/hosts &gt; /dev/null。这条命令会把缓冲区的内容当作标准输入，并用它来覆盖 /etc/hosts 文件的内容，下面文件与缓冲区的内容刚好是完全一致的。</p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1550647263953-ba725e78-53c9-4888-a1c3-01bf77f715ab.png#align=left&amp;display=inline&amp;height=233&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=233&amp;originWidth=747&amp;size=32937&amp;status=done&amp;width=747\" style=\"max-width: 600px; width: 747px;\" /></p><h1 id=\"3852f4b5\">第三部分 更快地移动及跳转</h1><p style=\"text-indent: 2em;\">动作命令是进行 Vim 操作的最重要的一些命令。我们不仅可以用它们四处移动光标，还能够用它们与操作符待决模式配合使用，指定一段文本范围并在其上进行操作。在本书的这一部分，我们将结识一些最为有用的动作命令，另外，我们还会学习 Vim 的跳转命令，这些命令让我们可以在文件间快速地跳转。</p><h2 id=\"ec48adac\">第 8 章 用动作命令在文档中移动</h2><p>我们不用把手从本位行上移开，就可以上下左右移动，操作符待决模式中最出彩的明星是文本对象</p><p>如果你在一行中连续按了两次以上的 h 键，那就是在浪费时间（<span style=\"color: #F5222D;\">手动流汗</span>）。</p><p><br /></p><p>即 j、k、0和 $ 都用于操作实际行，而如果在这些 键前加上 g 前缀的话，就会让 Vim 对屏幕行进行操作</p><p><br /></p><p>w 正向移动到下一单词的开头   (for-)word</p><p>b 反向移动到当前单词/上一单词的开头  back-word</p><p>e 正向移动到当前单词/下一单词的结尾</p><p>ge 反向移动到上一单词的结尾</p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1551021099056-92eee3a8-553a-4244-a911-5215fed7c090.png#align=left&amp;display=inline&amp;height=241&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=301&amp;originWidth=542&amp;size=46783&amp;status=done&amp;width=434\" style=\"max-width: 600px; width: 434px;\" /></p><p>ea 命令连在一起可被解读为“在当前单词结尾后添加”</p><p>gea 命令当成“在上一单词结尾后 添加”的命令</p><p><br /></p><p>我们之前遇到过的每个面向单词的动作命令，都有一个面向字串的命令与其对 应，这当中包括 W、B、E和 gE</p><p>一个单词由字母、数字、下划线，或其他非空白字符的序列组成，单词间以空白 字符分隔，字串的定义则更简单，它由非空白字符序列组成， 字串间以空白字符分隔</p><p><br /></p><p>Vim 会记录 上次执行过的 f{char} 命令，随后用 ; 命令就可以重复该命令了，用 , 命令就可以再跳回来</p><p>f{char} 正向移动到下一个 {char} 所在之处</p><p>F{char} 反向移动到上一个 {char} 所在之处</p><p>t{char} 正向移动到下一个 {char} 所在之处的前一个字符上</p><p>T{char} 反向移动到上一个 {char} 所在之处的后一个字符上</p><p>; 重复上次的字符查找命令</p><p>, 反转方向查找上次的字符查找命令</p><p> f,dt.训练成手指的下意识动作（删除 , 和 . 之间的内容）</p><p><br /></p><p>缺省的&lt;Leader&gt; 键是 \\</p><p><br /></p><p>查找命令不仅限于在普通模式下使用，我们也可以在可视模式及操作符待决模式 中使用它，用来完成实际的工作</p><p>删除工作会更方便，先高亮然后通过命令行模式进行大范围选择。</p><p>d/ge&lt;CR&gt; 用 /ge&lt;CR&gt; 查找动作告诉 d{motion} 命令删除什么。查找命令是 一个开动作，也就是说，虽然光标是在单词“gets”开头的“g”上的，但此字符却被 排除在删除操作之外，用 v 还需要 h 一下</p><p>把 d{motion} 操作符与查找动作结 合在一起使用，这是个很大的进步，你可以好好在朋友和同事们面前<span style=\"color: #F5222D;\">炫耀一番</span>了</p><p><br /></p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1551022390533-baf49e0f-bcdf-4264-bee3-76f4eb4e25f8.png#align=left&amp;display=inline&amp;height=427&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=534&amp;originWidth=578&amp;size=49815&amp;status=done&amp;width=462\" style=\"max-width: 600px; width: 462px;\" /></p><p><br /></p><p>可以把 i 想成“inside”，而把 a 想成 “around” 或“all”。</p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1551022505589-cada3bcd-b055-427d-a850-31630f07c346.png#align=left&amp;display=inline&amp;height=453&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=566&amp;originWidth=484&amp;size=75169&amp;status=done&amp;width=387\" style=\"max-width: 600px; width: 387px;\" /></p><p><br /></p><p>文本对象自身并不是动作命令，我们不能用它们在文档中移动。但是我们却可以 在可视模式及操作符待决模式中使用文本对象 ：每当在命令语法里看到 {motion} 时，你也可以在这个地方使用文本对象，常见的例子包括 d{motion}、 c{motion}和 y{motion} </p><p>把 ci&quot; 命令解读为“修改双引号内部的内容”，把 cit 命令解读为“修 改标签内部的内容”。另外，我们也可以很容易地用 yit 命令拷贝标签内的文本，或 者是用 dit 删除这些文本。</p><p><br /></p><p>如果说 f{char} 和 /pattern&lt;CR&gt; 命令如同单足飞踹， 那么文本对象则像是一次攻击两个目标的剪刀腿</p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1551022681107-241777fb-ce43-4d52-819c-c55c1b28e6c7.png#align=left&amp;display=inline&amp;height=218&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=272&amp;originWidth=685&amp;size=31159&amp;status=done&amp;width=548\" style=\"max-width: 600px; width: 548px;\" /></p><p><br /></p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1551022790391-f03ad92b-de0b-4381-9ce9-7ac70b68ef19.png#align=left&amp;display=inline&amp;height=279&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=349&amp;originWidth=350&amp;size=28484&amp;status=done&amp;width=280\" style=\"max-width: 600px; width: 280px;\" /></p><p>iw 和 aw 之间的区别很微妙，为什么会需要这样两个文本对象呢？</p><p>ciw 命令只删除该单词，而不删除其前后的空白字符，随后它会进入插入模式， 这刚好是我们想要的效果。如果用的是 caw 的话，那最后两个单词就会连在一起</p><p>一般来说，d{motion} 命令和 aw、as 和 ap 配合起来使用比较好，而 c{motion} 命令和 iw 及类似的文本对象一起用效果会更好。</p><p><br /></p><p>m{a-zA-Z} 命令会用选定的字母标记当前光标所在位置,mm 和 `m 命令是一对便于使用的命令，它们分别设置位置标记 m，以及跳转到 该标记</p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1551060576906-eb4d92e6-28f9-40f9-8c9c-4be5ccba3c49.png#align=left&amp;display=inline&amp;height=209&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=262&amp;originWidth=438&amp;size=34262&amp;status=done&amp;width=350\" style=\"max-width: 600px; width: 350px;\" /></p><p>% 命令允许我们在一组开、闭括号间跳转,在执行 % 命令时，Vim 会 自动为发生跳转的地方设置一个位置标记, % 命令只能用在配对的括号上,所以利用替换命令时最好利用位置标记，防止陷阱。</p><h2 id=\"08071332\">第 9 章 在文件间跳转</h2><p>:jumps 查看跳转列表的内容，如果我们运行 :edit 命令 打开了一个新文件，那么就可以用 &lt;C-o&gt; 和 &lt;C-i&gt; 命令在这个新文 件以及原本的文件之间来回跳转，会始终在 当前活动窗口的跳转列表范围内进行跳转， Vim 本来就把 &lt;C-i&gt; 和 &lt;Tab&gt; 当成同一个东西。映射需谨慎。</p><p><br /></p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1551063629792-edf970a6-eef3-440f-95bf-5eb3cff4325f.png#align=left&amp;display=inline&amp;height=242&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=303&amp;originWidth=593&amp;size=47322&amp;status=done&amp;width=474\" style=\"max-width: 600px; width: 474px;\" /></p><p>Vim 会在编辑会话期间维护一张表，里面记载我们对每个缓冲区所做的修改， 此表就是所谓的改变列表 :changes，用 g; 和 g, 命令反向或正向遍历改变列表。改变列表中则保存了多组位置。我们可以多次按 g; 命令，每次它都会把 我们带到改变列表中较早的一个位置，而 `. 则总是把我们带到改变列表的最后一项。</p><p><br /></p><p>执行 gf 命令“go to file”加上 .rb 扩展名，用 ‘suffixesadd’ 选项做到这一点 :set suffixesadd+=.rb</p><p>查看 'path' 选项的值</p><p>:set path?</p><p>《 path=.,/usr/include,,</p><p>&lt;C-]&gt; 命令的作用也类似。它也需要进行一些配置（在技巧 102 中讨论），然而 一旦正确配置好，它就允许我们从函数调用的地方直接跳到该函数定义的地方</p><p><br /></p><p>用两次按键就可以打开你的 vimrc 文件，先打开你的 vimrc 文件，按 mV 设置一个全局标记（助记词 V 代 表 vimrc），然后切换到另一个文件中按 `V</p><p><br /></p><p>缺省情况下，:vimgrep 会直接跳到它所找到的第一处匹配上，这或许会切换到 另外一个文件。</p><p>一般来说，要养成在使用与 quickfix 列表有关的命令前，如:grep、:vimgrep 及:make，设置全局标记的习惯。另外，在执行与缓冲区列表或参数列表有关的命令前， 如:args {arglist}和:argdo（参见技巧 37），也要设置全局标记。 你总共可以设置 26 个全局位置标记，可以迅速跳回。</p><p><br /></p><h1 id=\"2e0bcfbf\">第四部分 寄存器</h1><p style=\"text-indent: 2em;\">Vim 的寄存器是一组用于保存文件的简单容器。它们既可像剪贴板那样，剪切、复制和粘贴文本；也可以记录一系列按键操作，把它们录制成宏。通过本书的这一部分，我们将掌握这一核心功能。</p><h2 id=\"59b9a56d\">第 10 章 复制与粘贴</h2><p>xp，可被用于“调换光标之后的两个字符”ddp，可被用于“调换当前行和它的下一行” </p><p><br /></p><p>diw 命令不仅删除了单词，而且还将它拷贝到了无名寄存器，按 P时得到的是刚刚删除的单词，而不是之前复制的单词，给命令加 &quot;{register} 前缀的方式指定要用的寄存器，Vim 将缺省使用无 名寄存器。&quot;ayiw复制，用 &quot;bdd删除，&quot;ap粘贴，可以解决无名寄存器的问题，使用复制寄存器也可以解决，黑洞集训器从删除方面也可以解决</p><p><br /></p><p>Vim 的 delete 命令也与标准剪切操作的作用一致。也就是说，该命令会先把 指定文本复制到寄存器后再从文档中删掉，引用黑洞寄存器，&quot;_d{motion}会执行真正的删除操作。</p><p><br /></p><p>无名寄存器（&quot;&quot;）， &quot;&quot;p，它完全等同于 p命令，x 和 d{motion} 经常被当作“删除”命 令。这其实是用词不当，把它们理解为“剪切”命令会更合适</p><p><br /></p><p>复制专用寄存器（&quot;0）使用 y{motion} 命令时，要复制的文本不仅会被拷贝到无名寄存器中，而且也被拷贝到了复制专用寄存器中，因为专用，只有 y 能触发</p><p><br /></p><p>检查无名寄存器和复制专用寄存器的内容，:reg &quot;0 ，小问题用复制专用寄存器，如果碰到需要将一段或多段文本粘贴到多处的情况，有名寄存器就会大显神通。用小写字母引用有名寄存器，会覆盖该寄存器的原有内容，而换用大写字母的话，则会将新内容添加到该寄存器的原有内容之后</p><p><br /></p><p>如果我们在外部程序中用剪切或复制命令获取了文本，就可以通过 &quot;+p 命令（或 在插入模式下用 &lt;C-r&gt;+）将其粘贴到 Vim 内部。相反地，如果在 Vim 的复制或删除 命令之前加入 &quot;+ ，相应的文本将被捕获至系统剪贴板。</p><p>&quot;+ X11 剪贴板，用剪切、复制与粘贴命令操作 &quot;* X11 主剪贴板，用鼠标中键操作把它们粘贴出来，Windows与Mac OS X操作系统并没有主剪贴板的概念，因此 &quot;+ 寄存器与 &quot;* 寄 存器可以混用，它们都代表系统剪贴板。</p><p><br /></p><p>表达式寄存器（&quot;=）当我们从表达式寄存器获取内容时，Vim 将跳到命 令行模式，并显示提示符“=”。这时，我们可以输入一段 Vim 脚本表达式并按 &lt;CR&gt; 执行，如果返回的是字符串（或者可被强制转换成字符串的数据），Vim 将会使用它</p><p><br /></p><p>只读寄存器 &quot;% 当前文件名 &quot;# 轮换文件名 &quot;. 上次插入的文本 &quot;: 上次执行的Ex命令 &quot;/ 上次查找的模式 </p><p><br /></p><p>在可视模式下使用 p 命令时，Vim 将用我们指定的寄存器内容来替换高亮选区中的文本，可视再次解决了文本&quot;丢失&quot;现象，我们输入 u 撤销上次的修改。然后，按 gv重选上一次高亮选区的内容，再按一次 p键。发生了什么？显然什么也没发生，第一次使用 p时，之所以成功，是因为无名寄存器恰巧包含了我们想要的 文本。但在第二次使用 p时，无名寄存器包含的是被覆盖的内容，所以可是模式替换内容也会进入无名寄存器</p><p><br /></p><p>在 Vim 的可视模式下使用 p命令时。首先，从无名寄存器里取出内容，然后，把高亮选区中的内容存入无名寄存器。（<span style=\"color: #F5222D;\">花里胡哨</span>）</p><p><br /></p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1551176775970-4a023ff6-26fa-4f41-8fb3-ecab6fe9c7da.png#align=left&amp;display=inline&amp;height=125&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=125&amp;originWidth=364&amp;size=13396&amp;status=done&amp;width=364\" style=\"max-width: 600px; width: 364px;\" /></p><p><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1551176803751-7d556e52-aa61-4993-8056-4abf12f643c7.png#align=left&amp;display=inline&amp;height=174&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=174&amp;originWidth=363&amp;size=15099&amp;status=done&amp;width=363\" style=\"max-width: 600px; width: 363px;\" /></p><p>c3w命令删除“chips and fish”并重新输入“fish and chips”， 应该会更快地完成任务。但是，以上方法可被用于交换更长的短语</p><p><br /></p><p>p 命令旨在将寄存器中的文本粘贴到光标之后，P 命令用于将文本插入到光标之前，puP 和 Pup几乎成了下意识动作。当要粘贴的内容来自于面向行的寄存器时，p 和 P 命令会把它们粘贴至当前行的 上一行或下一行。这一点比面向字符的行为更直观</p><p><br /></p><p>在插入模式下，我们可以通过输入 &lt;C-r&gt;&quot; 来插入无名寄存器的内容，或者输入 &lt;C-r&gt;0来插入复制专用寄存器的内容</p><p>gp和 gP命令也值得关注，它们会把光标的位置移到被粘贴出来的文本结尾而不是开头。 当复制多行文本时，gP命令尤为管用，P 和 gP 命令区别</p><p><br /></p><p>如果你运行的 Vim 是已集成系统剪贴板的版本，就可以完全避免与'paste' 选项打交道了。普通模式下的 &quot;+p 命令用来粘贴加号寄存器中的内容，即系统剪 贴板的镜像。</p><h2 id=\"b51d83bf\">第 11章 宏</h2><p><br /></p>",
    "body_lake": "<!doctype lake><p>categories: Vim</p><p><br /></p><card type=\"block\" name=\"hr\"></card><p><br /></p><p>&lt;blockquote class=&quot;blockquote-center&quot;&gt;**希望由厚至薄**&lt;/blockquote&gt;</p><p>&lt;!-- more --&gt;</p><p><br /></p><p style=\"text-align: center;\"><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F203310%2F1547523970324-ad085afb-d91a-4b7a-bc5e-07c6133eeca7.jpeg%22%2C%22originWidth%22%3A552%2C%22originHeight%22%3A693%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A489%2C%22height%22%3A614%7D\"></card></p><h1 id=\"a4d3b02a\">概述</h1><p> 学习Vim，最难受的就是它对新手出名的不友好，网上一大堆乱七八糟的东西，还是自己进行学习对自己的帮助最大。建议首先学习 :vimtutor 入门vim学习。最好会盲打，自己看了这本 vim 实用技巧。</p><h1 id=\"454d0617\">第 1 章 Vim解决问题的方式</h1><p>{char} 是指任意字符</p><p>&lt;CR&gt; 指&lt;Enter&gt;</p><p>cw会删除光标位置到当前词位置结尾处的文本，并进入插入模式</p><p>&gt;G是首行缩进</p><p><span style=\"color: #F5222D;\">C=c$ 删除到行尾再插入</span></p><p>o=A&lt;CR&gt;下一行插入</p><p>s删除光标处再插入</p><p>@：重复命令行命令</p><p>&amp;重复替换命令</p><p>f{char} 搜索，; 下一个字符，, 上一个字符</p><p>* 可以查看当前光标下的单词</p><p>理想模式：用一个键移动，另一键执行。又称为 “.范式”。</p><h1 id=\"d65edfb7\">第一部分 模式</h1><p style=\"text-indent: 2em;\">Vim 提供一个区分模式的用户界面，就是说在 Vim 中按键盘上的任意键所产生的结果可能会不一样，而这取决于当前正处于哪种模式，以及如何在各模式间切换，是极其重要的。在本书的这一部分，我们将学习每种模式的工作方式及其用途。</p><h2 id=\"f5859b09\">第 2 章 普通模式</h2><p>b 把光标移动到单词开头</p><p>daw 在单词末尾也能删除</p><p>&lt;c-a&gt; 在数字上执行加一，不在数字上，在当前行正向查找一个数字，10<span>&lt;c-a&gt;</span></p><p>&lt;c-x&gt; 在数字上执行减一</p><p>最好不要用数字 d2w 这样，因为 . 能很好代替，但是 c3w 有用，行中间来快速进行修改</p><p>g~ 反转大小写，gu 转成小写，gU转成大写。gUap 将一段转换为大写，g 当成操作符前缀</p><p>gc{motion} 切换为注释状态，gcap 切换当前段落的注释状态。gcG 当前行到文件结尾间的所有内容注释掉，gcc 注释当前行，gg=G 自动缩进整个文件。</p><h2 id=\"e67876bd\">第 3 章 插入模式</h2><p>在输入错误时，专业打字员会建议先删除整个单词，然后再重新输入一遍。</p><p>&lt;c-h&gt; 删除前一个字符（同退格键）&lt;c-w&gt; 删除前一个单词&lt;c-u&gt; 删至行首。</p><p>&lt;c-[&gt;切换到普通模式，&lt;c-o&gt; 切换到插入-普通模式。在此模式中，可以执行一个普通模式命令，执行完后，马上又返回到插入模式</p><card type=\"block\" name=\"table\" value=\"data:%7B%22rows%22%3A5%2C%22cols%22%3A3%2C%22html%22%3A%22%3Ctable%20class%3D%5C%22lake-table%5C%22%20style%3D%5C%22width%3A%20721px%3B%5C%22%3E%3Ccolgroup%3E%3Ccol%20width%3D%5C%22240%5C%22%20span%3D%5C%221%5C%22%20%2F%3E%3Ccol%20width%3D%5C%22240%5C%22%20span%3D%5C%221%5C%22%20%2F%3E%3Ccol%20width%3D%5C%22240%5C%22%20span%3D%5C%221%5C%22%20%2F%3E%3C%2Fcolgroup%3E%3Ctbody%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3E%3Cp%3E%E6%8C%89%E9%94%AE%E6%93%8D%E4%BD%9C%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%3E%3Cp%3E%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%85%E5%AE%B9%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%3E%3Cp%3E%3Cbr%20%2F%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20rowspan%3D%5C%221%5C%22%20colspan%3D%5C%221%5C%22%3E%3Cspan%20style%3D%5C%22color%3A%20%23262626%3B%20background-color%3A%20%23FFFFFF%3B%5C%22%3Eyt%2C%3Cspan%3E%C2%A0%3C%2Fspan%3E%3C%2Fspan%3E%3C%2Ftd%3E%3Ctd%20rowspan%3D%5C%221%5C%22%20colspan%3D%5C%221%5C%22%3E%3Cp%3E%3Cspan%20style%3D%5C%22color%3A%20%23262626%3B%20background-color%3A%20%23FFFFFF%3B%5C%22%3EPractical%20Vim%2C%20by%20Drew%20Neil%3C%2Fspan%3E%3C%2Fp%3E%3Cp%3E%3Cspan%20style%3D%5C%22color%3A%20%23262626%3B%20background-color%3A%20%23FFFFFF%3B%5C%22%3E%3Cspan%3ERead%20Drew%20Neil's%3C%2Fspan%3E%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%3E%3Cp%3E%3Cbr%20%2F%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%3E%3Cp%3E%3Cspan%3EjA%E2%90%A3%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%3E%3Cp%3E%3Cspan%3EPractical%20Vim%2C%20by%20Drew%20Neil%3C%2Fspan%3E%3Cbr%20%2F%3E%3Cspan%3ERead%20Drew%20Neil's%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%3E%3Cp%3E%3Cbr%20%2F%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%3Cspan%3E%26lt%3BC-r%26gt%3B0%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20rowspan%3D%5C%221%5C%22%20style%3D%5C%22vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cspan%20style%3D%5C%22color%3A%20%23262626%3B%20background-color%3A%20%23FFFFFF%3B%5C%22%3EPractical%20Vim%2C%20by%20Drew%20Neil%3C%2Fspan%3E%3Cbr%20%2F%3E%3Cspan%20style%3D%5C%22color%3A%20%23262626%3B%20background-color%3A%20%23FFFFFF%3B%5C%22%3ERead%20Drew%20Neil's%20Practical%20Vim%3C%2Fspan%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%3Cbr%20%2F%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3Ctr%20style%3D%5C%22height%3A%2033px%3B%5C%22%3E%3Ctd%20colspan%3D%5C%221%5C%22%20rowspan%3D%5C%221%5C%22%20style%3D%5C%22vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E.%26lt%3BEsc%26gt%3B%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%3Cspan%3EPractical%20Vim%2C%20by%20Drew%20Neil%3C%2Fspan%3E%3Cbr%20%2F%3E%3Cspan%3ERead%20Drew%20Neil's%20Practical%20Vim.%3C%2Fspan%3E%3C%2Fp%3E%3C%2Ftd%3E%3Ctd%20colspan%3D%5C%221%5C%22%20style%3D%5C%22vertical-align%3A%20top%3B%20background-color%3A%20%23FFFFFF%3B%20color%3A%20%23262626%3B%5C%22%3E%3Cp%3E%3Cbr%20%2F%3E%3C%2Fp%3E%3C%2Ftd%3E%3C%2Ftr%3E%3C%2Ftbody%3E%3C%2Ftable%3E%22%7D\"></card><p>yt, 命令把“Practical Vim”复制到复制专用寄存器中,&lt;C-r&gt;0 把刚才复制的文本粘贴到光</p><p>标所在位置</p><p>= 符号指明使用表达式寄存器,&lt;C-r&gt;=6*35&lt;CR&gt;，将执行结果插入到文档的当前位置</p><p>&lt;C-v&gt;{code}根据字符编码插入字符，{code} 是要插入字符的编码，&lt;C-v&gt;065插入A</p><p>&lt;C-v&gt;u{1234} 以十六进制字符编码插入字符</p><p>ga 分别以十进制和十六进制的形式显示出其字符编码</p><p>&lt;C-k&gt;{char1}{char2} 插入以<strong>二合字母</strong>{char1}{char2}表示的字符，&lt;C-k&gt;?I 表示的“¿”字符，二合字母 12 指1⁄2</p><p>R 命令可以由普通模式进入替换模式，“,␣b” 替换原有的“. ␣ B”字符</p><p>gR 进入虚拟替换模式(Virtual Replace mode)，把制表符当成一组空格进行处理，输入制表符占据的最后一个字符，该字符会替换制表符。</p><h2 id=\"4e7f5ecd\">第 4 章 可视模式</h2><p>viw 来高亮选择这个词,用 c 命令进行修改</p><p>V 激活面向行的可视模式</p><p>&lt;C-v&gt; 激活面向列块的可视模式</p><p>gv 重选上次的高亮选区</p><p>o 切换高亮选区的活动端，vbb ，o ，e</p><p>重复执行面向行的可视命令，Vj ，&gt;.</p><p>vit 可被解读为高亮选中标签内部的内容(visually select inside the tag),it 命令是一种被称为文本对象(text object)</p><p>gUit 要优于 vitU 命令，首选操作符命令，再者是可是模式命令，可视模式擅长一次性处理和动作命令难以构建的文本范围</p><p>技巧24 面向列块的可是模式编辑表格数据，在一行下生成分割线 yyp，Vr-</p><p>列块可视模式,插入操作只影响顶行，但实际影响所有，插入模式时间很短暂</p><p>I 命令把光标置于当前行的开头</p><h2 id=\"007fa2d7\">第 5 章 命令行模式</h2><p style=\"text-indent: 2em;\">有些命令在插入模式和命令行模式中可以通用。例如,可以用 &lt;C-w&gt; 和 &lt;C-u&gt;分别删除至上个单词的开头及行首,也可以用 &lt;C-v&gt; 或 &lt;C-k&gt; 来插入键盘上找不到的字符,还可以用 &lt;C-r&gt;{register} 命令把任意寄存器的内容插入到命令行。Ex 命令可以在任意位置执行</p><p><br /></p><p>:3d 等于 3G dd 一定程度上要比普通模式命令要快</p><p>. 代表当前行的地址，:.,$d 这样的命令可能很实用</p><p>% 代表当前文件中的所有行，:%s/Practical/Pragmatic/</p><p>可视模式加命令行模式，VG，输入 ：命令行上就会预先填充一个范围 :'&lt;,'&gt; 。代表高亮选区的范围</p><p>:6copy. 命令解读为“为第 6 行创建一份副本,并放到当前行下方”，:copy 简写:co 或是 :t</p><p>:t6 把当前行复制到第 6 行下方，:t$ 把当前行复制到文本结尾</p><p>快速跳回原先的位置( &lt;C-o&gt; )，在复制距离较远的行时, :t 命令通常更加高效。</p><p>: yyp 会使用寄存器，不想覆盖默认寄存器中的当前内容时，可以考虑使用 :t. 来复制行</p><p>:'&lt;,'&gt;m$ 等于 :'&lt;,'&gt;m$，重复上次的 Ex 命令 @:</p><p>'&lt;,'&gt;normal . 命令可以解读为“对高亮选区中的每一行,对其执行普通模式下的 . 命令”。</p><p>:%normal i// 把整个 JavaScript 文件注释掉</p><p>:normal 命令则让我们可以把具有强大表现力的 Vim 普通模式命令与具有大范围影响力的 Ex 命令结合在一起</p><p>遍历缓冲区列表的条目，:bn[ext] 可以在列表中逐项正向移动,而 :bp[revious] 命令则进行反向移动</p><p><br /></p><p>逐个查看每个缓冲区 :bnext，@: 命令和:bprevious 命令可能会出现反向遍历缓冲区列表，将人搞糊涂，更好用&lt;C-o&gt; 命令，该命令会回到跳转列表的上条记录。想往回跳,就用 &lt;C-o&gt; 命令。</p><p><br /></p><p>&lt;C-d&gt; 命令会让 Vim 显示可用的补全列表，按 &lt;Tab&gt; 键依次显示</p><p>&lt;C-r&gt;&lt;C-w&gt; 用于插入光标下的单词，插入光标下的字串&lt;C-r&gt;&lt;C-a&gt;，一般和 * 、:%s 一起使用，:%s//&lt;C-r&gt;&lt;C-w&gt;/g</p><p>命令行窗口就像是一个常规的 Vim 缓冲区,只不过它的每行内容都对应着命令历史中的一个条目。我们可以用 k 及 j 键在历史中向前或向后移动,也可以用 Vim 的查找功能查找某一行。在按下 &lt;CR&gt; 键时,将会把当前行的内容当成 Ex 命令加以执行。好处是强大的vim编辑能力可以派上用场。</p><p>q: 调出命令行窗口，J 命令合并下一行，命令行窗口处于打开状态时,它会始终拥有焦点。</p><p>&lt;Ctrl-f&gt; 从命令行模式切换到命令行窗口，已经输入到命令行上的内容仍然会得以保留</p><p>:!ls 执行 Shell 中的程序，在 Vim 的命令行中,符号 % 代表当前文件名(指调用了shell程序时)</p><p>执行几条命令:shell 命令来启动一个交互的 shell 会话,用 exit 命令可以退出此 shell 并返回 Vim</p><p>把 Vim 置于后台，看书 p 94 </p><p>命令会产生大量输出，用:read !{cmd} 命令，它让我们把命令的标准输出重定向到缓冲区。</p><p>:write !{cmd} 做相反的事。它把缓冲区内容作为指定 {cmd} 的标准输入</p><p>:write! sh 把缓冲区内容写到一个名为 sh 的文件，叹号放得位置不同,命令的作用]也大相径庭。</p><p>:write !sh 命 令 的 作 用 是 在 shell 中 执 行 当 前 缓 冲 区 中 的 每 行 内 容</p><p>Vim 把过滤器定义为“一个由标准输入读取文本,并对其进行某种形式的修改后输出到标准输出的程序”</p><p>:2,$!sort -t',' -k2，命令行结合 shell 来对文本进行处理。</p><p>Vim 提供了一种方便的快捷方式来设置 :[range]!{filter} 命令中的范围。我们可以用 !{motion} 操作符切换到命令行模式,并把指定 {motion} 所涵盖的范围预置在命令行上，如果我们把光标移到第 2 行,然后执行 !G ,Vim 就会打开命令行并把范围 :.,$! 预置在命令行上。虽然此后我们仍需输入剩下的 {filter} 命令,但这毕竟节省了部分工作。</p><p>:read !{cmd} 在 shell 中执行 {cmd} ,并把其标准输出插入到光标下方</p><p>:[range]write !{cmd} 在 shell 中执行 {cmd} ,以 [range] 作为其标准输入</p><p>:[range]!{filter} 使用外部程序 {filter} 过滤指定的 [range]</p><h1 id=\"b76203f4\">第二部分 文件</h1><p style=\"text-indent: 2em;\">在本书的这一部分，我们将学习如何使用文件及缓冲区。Vim 允许在一个编辑会话中编辑多个文件，我们既可以每次显示一个文件，也可以把工作区分成若干个分割窗口或标签页，每个窗口或标签页包含一个独立的缓冲区。另外，我们还会看到在 Vim 中打开文件的机种不同方式，并掌握一些方法来解决无法把缓冲区保存到文件的问题。</p><h2 id=\"d239b0a0\">第 6 章 管理多个文件</h2><p>我们编辑的只是内存中的映像，也就是 Vim 术语中的“缓冲区”。 </p><p><br /></p><p>:ls 命令会列出所有被载入到内存中的缓冲区的列表， :bnext 命令可以切换到列表中的下一个缓冲区，% 符号指明哪个缓冲区在当前窗口中可见，而 # 符号则代表轮换文件。按 &lt;C-^&gt; 可以在当前文件和轮换文件间快速切换。</p><p><br /></p><p>:bprev (bp) 和 :bnext (bn)在列表中反向或正向移动；而 :bfirst 和 :blast 则分别跳到列表的开头和结尾</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22%E3%80%8A%201%20%23%20%20%5C%22a.txt%5C%22%20%20%20line%201%5Cn%5Ct%202%20%25a%20%20%5C%22b.txt%5C%22%20%20%20line%201%20%22%7D\"></card><p><br /></p><p>:buffer N 命令直接凭编号跳转到一个缓冲区，:buffer {bufname} 格式实现同样的功能。{bufname} 只需包含文件路径中 足以唯一标识此缓冲区的字符即可</p><p><br /></p><p>删除缓冲区，可以用 :bdelete 命令, :5,10bd ,删除编号 5～10（包含 5 和 10）的缓冲区</p><p><br /></p><p>用 :argdo 命令可以在参数列表中的每个文件上执行一条 Ex 命令。 当不带参数运行 :args 命令时，它会打印当前参数列表的内容。 :args {arglist} {arglist} 可以包括文件名、通配符，甚至是一条 shell 命令的输出结果</p><p><br /></p><p>填充参数列表最简单的方式是逐一指定文件的名字：➾ :args index.html app.js  ** 通配符也匹配 0 个或多个字符，但它可以递归进入指定目录的子目录 :args **/*.js ,  :args **/*.js **/*.css  :args `cat .chapters`</p><p><br /></p><p>按 Go 在缓冲区的结尾增加一个空行,缓冲区 a.txt 前有一个 + 号，表示这个缓冲区被修改过了,被标记为 h，表示它是一个隐藏缓冲区（hidden）</p><p><br /></p><p>:w[rite] 把缓冲区内容写入磁盘 :e[dit]! 把磁盘文件内容读入缓冲区（即回滚所做修改） :qa[ll]! 关闭所有窗口，摒弃修改而无需警告 :wa[ll]! 把所有改变的缓冲区写入磁盘 </p><p><br /></p><p>启用‘hidden’选项,运行完 :argdo {cmd} 后,一切正常，可以运行 :argdo write （或 :wall）来保存所有的缓冲区。</p><p><br /></p><p>用 &lt;C-w&gt;s 命令可以水平切分此窗口，使之成 为两个高度相同的窗口；或者可以用 &lt;C-w&gt;v 命令对其进行垂直切分，这样会产生两 个宽度相同的窗口</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1550644590245-77a4763f-ed46-470e-9a1d-4512ea7167ac.png%22%2C%22originWidth%22%3A685%2C%22originHeight%22%3A503%2C%22name%22%3A%22image.png%22%2C%22size%22%3A34313%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A685%2C%22height%22%3A503%7D\"></card></p><p>编辑长文件时,可以滚动其中一个窗口，使之显示缓冲区的一部分，这样，在修改第二 个窗口中缓冲区的另外一部分时，就可以参考第一个窗口中的内容。</p><p><br /></p><p>:sp[lit] {file} 水平切分当前窗口，并在新窗口中载入{file} :vsp[lit] {file} 垂直切分当前窗口，并在新窗口中载入{file}</p><p>&lt;C-w&gt;w 在窗口间循环切换 &lt;C-w&gt;h 切换到左边的窗口 &lt;C-w&gt;j 切换到下边的窗口 &lt;C-w&gt;k 切换到上边的窗口 &lt;C-w&gt;l 切换到右边的窗口,按住 &lt;Ctrl&gt; 键，然后再输入 ww （或 wj ，或上表中的其他命令）来切换活动窗口。 </p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1550645102529-39f26124-6f39-4015-9320-753465134bd9.png%22%2C%22originWidth%22%3A842%2C%22originHeight%22%3A152%2C%22name%22%3A%22image.png%22%2C%22size%22%3A25654%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A842%2C%22height%22%3A152%7D\"></card></p><p><br /></p><p>&lt;C-w&gt;= 使所有窗口等宽、等高 &lt;C-w&gt;_ 最大化活动窗口的高度 &lt;C-w&gt;|  最大化活动窗口的宽度 [N]&lt;C-w&gt;_  把活动窗口的高度设为[N]行 [N]&lt;C-w&gt;| 把活动窗口的宽度设为[N]列,用鼠标做最好</p><p><br /></p><p>用 :edit 命令打开一个文件时，Vim 却不会自动创建一 个新标签页，而是会创建一个新缓冲区，并把该缓冲区显示到当前窗口。应该把标签页想成容纳一系 列窗口的容器</p><p><br /></p><p>:lcd {path} 命令让我们可以设置当前窗口的本地工作目录。如果我们创建了一 个新标签页，并用 :lcd 命令切换到另一个目录，那么就可以把每个标签页限制在不 同的工程范围内。用 :tabedit {filename} 命令可以打开一个新的标签页，如果省略了 {filename} 参数的话，那么 Vim 会创建一个新标签页，里面包含一个空缓冲区</p><p><br /></p><p>&lt;C-w&gt;T 命 令把当前窗口移到一个新标签页中 :tabc[lose] 关闭当前标签页及其中的所有窗口 :tabo[nly] 只保留活动标签页，关闭所有其他标签页</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1550645990944-5586df98-b275-4ac8-9663-185a464c59af.png%22%2C%22originWidth%22%3A896%2C%22originHeight%22%3A199%2C%22name%22%3A%22image.png%22%2C%22size%22%3A36002%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A896%2C%22height%22%3A199%7D\"></card></p><p><br /></p><p> :tabmove [N] 命令可以重新排列标签页。省略了 [N]，当前标签页会被移到结尾，如果支持鼠标，则用鼠标拖拽</p><p><br /></p><h2 id=\"a185fab5\">第 7 章 打开及保存文件</h2><p>:edit {file} 命令可以接受相对于工作目录的文件路径</p><p><br /></p><p>% 符号代表活动缓冲区的完整文件路径，:h 修饰符会去除文件名，但保留路径中的其他部分 :edit %:h&lt;Tab&gt;M&lt;Tab&gt; </p><p><br /></p><p> $ vim . 在按&lt;CR&gt; 键时，Vim 会打开光标下的条 目。如果光标位于目录上，那么此窗口的内容会更新为该目录的内容；如果光标位于文件上，那么该文件会被载入一个缓冲区里，并把它显示在当前窗口中。这将导致当 前窗口中的文件管理器被该缓冲区的内容所替代</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1550646730436-643f6d61-8093-40cb-a791-42b31a95f6a4.png%22%2C%22originWidth%22%3A807%2C%22originHeight%22%3A464%2C%22name%22%3A%22image.png%22%2C%22size%22%3A97939%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A807%2C%22height%22%3A464%7D\"></card></p><p><br /></p><p>:edit . :e. 打开文件管理器，并显示当前工作目录 :Explore :E 打开文件管理器，并显示活动缓冲区所在的目录 :E 及 :e. 命令表现得有些古怪，因为它们会用文件管理器替换掉当前窗口的内容，想象成一张纸牌，如果在调出文 件管理器后，又想切换回刚才正在编辑的那个文件，此时可以使用 &lt;C-^&gt; 命令。 </p><p><br /></p><p>杀手级功能，其名字正因为此功能而来，即 netrw 可 以通过网络读写文件。该插件可以利用多种协议读写网络文件，包括 scp、ftp、curl 及 wget，这取决于你的系统上可以用哪些协议。（<span style=\"color: #F5222D;\">手动流汗</span>）</p><p><br /></p><p>&lt;C-g&gt; 命令用于显示当前文件的文件名及状态，以超级用户执行，tee /etc/hosts &gt; /dev/null。这条命令会把缓冲区的内容当作标准输入，并用它来覆盖 /etc/hosts 文件的内容，下面文件与缓冲区的内容刚好是完全一致的。</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1550647263953-ba725e78-53c9-4888-a1c3-01bf77f715ab.png%22%2C%22originWidth%22%3A747%2C%22originHeight%22%3A233%2C%22name%22%3A%22image.png%22%2C%22size%22%3A32937%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A747%2C%22height%22%3A233%7D\"></card></p><h1 id=\"3852f4b5\">第三部分 更快地移动及跳转</h1><p style=\"text-indent: 2em;\">动作命令是进行 Vim 操作的最重要的一些命令。我们不仅可以用它们四处移动光标，还能够用它们与操作符待决模式配合使用，指定一段文本范围并在其上进行操作。在本书的这一部分，我们将结识一些最为有用的动作命令，另外，我们还会学习 Vim 的跳转命令，这些命令让我们可以在文件间快速地跳转。</p><h2 id=\"ec48adac\">第 8 章 用动作命令在文档中移动</h2><p>我们不用把手从本位行上移开，就可以上下左右移动，操作符待决模式中最出彩的明星是文本对象</p><p>如果你在一行中连续按了两次以上的 h 键，那就是在浪费时间（<span style=\"color: #F5222D;\">手动流汗</span>）。</p><p><br /></p><p>即 j、k、0和 $ 都用于操作实际行，而如果在这些 键前加上 g 前缀的话，就会让 Vim 对屏幕行进行操作</p><p><br /></p><p>w 正向移动到下一单词的开头   (for-)word</p><p>b 反向移动到当前单词/上一单词的开头  back-word</p><p>e 正向移动到当前单词/下一单词的结尾</p><p>ge 反向移动到上一单词的结尾</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1551021099056-92eee3a8-553a-4244-a911-5215fed7c090.png%22%2C%22originWidth%22%3A542%2C%22originHeight%22%3A301%2C%22name%22%3A%22image.png%22%2C%22size%22%3A46783%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A434%2C%22height%22%3A241%7D\"></card></p><p>ea 命令连在一起可被解读为“在当前单词结尾后添加”</p><p>gea 命令当成“在上一单词结尾后 添加”的命令</p><p><br /></p><p>我们之前遇到过的每个面向单词的动作命令，都有一个面向字串的命令与其对 应，这当中包括 W、B、E和 gE</p><p>一个单词由字母、数字、下划线，或其他非空白字符的序列组成，单词间以空白 字符分隔，字串的定义则更简单，它由非空白字符序列组成， 字串间以空白字符分隔</p><p><br /></p><p>Vim 会记录 上次执行过的 f{char} 命令，随后用 ; 命令就可以重复该命令了，用 , 命令就可以再跳回来</p><p>f{char} 正向移动到下一个 {char} 所在之处</p><p>F{char} 反向移动到上一个 {char} 所在之处</p><p>t{char} 正向移动到下一个 {char} 所在之处的前一个字符上</p><p>T{char} 反向移动到上一个 {char} 所在之处的后一个字符上</p><p>; 重复上次的字符查找命令</p><p>, 反转方向查找上次的字符查找命令</p><p> f,dt.训练成手指的下意识动作（删除 , 和 . 之间的内容）</p><p><br /></p><p>缺省的&lt;Leader&gt; 键是 \\</p><p><br /></p><p>查找命令不仅限于在普通模式下使用，我们也可以在可视模式及操作符待决模式 中使用它，用来完成实际的工作</p><p>删除工作会更方便，先高亮然后通过命令行模式进行大范围选择。</p><p>d/ge&lt;CR&gt; 用 /ge&lt;CR&gt; 查找动作告诉 d{motion} 命令删除什么。查找命令是 一个开动作，也就是说，虽然光标是在单词“gets”开头的“g”上的，但此字符却被 排除在删除操作之外，用 v 还需要 h 一下</p><p>把 d{motion} 操作符与查找动作结 合在一起使用，这是个很大的进步，你可以好好在朋友和同事们面前<span style=\"color: #F5222D;\">炫耀一番</span>了</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1551022390533-baf49e0f-bcdf-4264-bee3-76f4eb4e25f8.png%22%2C%22originWidth%22%3A578%2C%22originHeight%22%3A534%2C%22name%22%3A%22image.png%22%2C%22size%22%3A49815%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A462%2C%22height%22%3A427%7D\"></card></p><p><br /></p><p>可以把 i 想成“inside”，而把 a 想成 “around” 或“all”。</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1551022505589-cada3bcd-b055-427d-a850-31630f07c346.png%22%2C%22originWidth%22%3A484%2C%22originHeight%22%3A566%2C%22name%22%3A%22image.png%22%2C%22size%22%3A75169%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A387%2C%22height%22%3A453%7D\"></card></p><p><br /></p><p>文本对象自身并不是动作命令，我们不能用它们在文档中移动。但是我们却可以 在可视模式及操作符待决模式中使用文本对象 ：每当在命令语法里看到 {motion} 时，你也可以在这个地方使用文本对象，常见的例子包括 d{motion}、 c{motion}和 y{motion} </p><p>把 ci&quot; 命令解读为“修改双引号内部的内容”，把 cit 命令解读为“修 改标签内部的内容”。另外，我们也可以很容易地用 yit 命令拷贝标签内的文本，或 者是用 dit 删除这些文本。</p><p><br /></p><p>如果说 f{char} 和 /pattern&lt;CR&gt; 命令如同单足飞踹， 那么文本对象则像是一次攻击两个目标的剪刀腿</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1551022681107-241777fb-ce43-4d52-819c-c55c1b28e6c7.png%22%2C%22originWidth%22%3A685%2C%22originHeight%22%3A272%2C%22name%22%3A%22image.png%22%2C%22size%22%3A31159%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A548%2C%22height%22%3A218%7D\"></card></p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1551022790391-f03ad92b-de0b-4381-9ce9-7ac70b68ef19.png%22%2C%22originWidth%22%3A350%2C%22originHeight%22%3A349%2C%22name%22%3A%22image.png%22%2C%22size%22%3A28484%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A280%2C%22height%22%3A279%7D\"></card></p><p>iw 和 aw 之间的区别很微妙，为什么会需要这样两个文本对象呢？</p><p>ciw 命令只删除该单词，而不删除其前后的空白字符，随后它会进入插入模式， 这刚好是我们想要的效果。如果用的是 caw 的话，那最后两个单词就会连在一起</p><p>一般来说，d{motion} 命令和 aw、as 和 ap 配合起来使用比较好，而 c{motion} 命令和 iw 及类似的文本对象一起用效果会更好。</p><p><br /></p><p>m{a-zA-Z} 命令会用选定的字母标记当前光标所在位置,mm 和 `m 命令是一对便于使用的命令，它们分别设置位置标记 m，以及跳转到 该标记</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1551060576906-eb4d92e6-28f9-40f9-8c9c-4be5ccba3c49.png%22%2C%22originWidth%22%3A438%2C%22originHeight%22%3A262%2C%22name%22%3A%22image.png%22%2C%22size%22%3A34262%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A350%2C%22height%22%3A209%7D\"></card></p><p>% 命令允许我们在一组开、闭括号间跳转,在执行 % 命令时，Vim 会 自动为发生跳转的地方设置一个位置标记, % 命令只能用在配对的括号上,所以利用替换命令时最好利用位置标记，防止陷阱。</p><h2 id=\"08071332\">第 9 章 在文件间跳转</h2><p>:jumps 查看跳转列表的内容，如果我们运行 :edit 命令 打开了一个新文件，那么就可以用 &lt;C-o&gt; 和 &lt;C-i&gt; 命令在这个新文 件以及原本的文件之间来回跳转，会始终在 当前活动窗口的跳转列表范围内进行跳转， Vim 本来就把 &lt;C-i&gt; 和 &lt;Tab&gt; 当成同一个东西。映射需谨慎。</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1551063629792-edf970a6-eef3-440f-95bf-5eb3cff4325f.png%22%2C%22originWidth%22%3A593%2C%22originHeight%22%3A303%2C%22name%22%3A%22image.png%22%2C%22size%22%3A47322%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A474%2C%22height%22%3A242%7D\"></card></p><p>Vim 会在编辑会话期间维护一张表，里面记载我们对每个缓冲区所做的修改， 此表就是所谓的改变列表 :changes，用 g; 和 g, 命令反向或正向遍历改变列表。改变列表中则保存了多组位置。我们可以多次按 g; 命令，每次它都会把 我们带到改变列表中较早的一个位置，而 `. 则总是把我们带到改变列表的最后一项。</p><p><br /></p><p>执行 gf 命令“go to file”加上 .rb 扩展名，用 ‘suffixesadd’ 选项做到这一点 :set suffixesadd+=.rb</p><p>查看 'path' 选项的值</p><p>:set path?</p><p>《 path=.,/usr/include,,</p><p>&lt;C-]&gt; 命令的作用也类似。它也需要进行一些配置（在技巧 102 中讨论），然而 一旦正确配置好，它就允许我们从函数调用的地方直接跳到该函数定义的地方</p><p><br /></p><p>用两次按键就可以打开你的 vimrc 文件，先打开你的 vimrc 文件，按 mV 设置一个全局标记（助记词 V 代 表 vimrc），然后切换到另一个文件中按 `V</p><p><br /></p><p>缺省情况下，:vimgrep 会直接跳到它所找到的第一处匹配上，这或许会切换到 另外一个文件。</p><p>一般来说，要养成在使用与 quickfix 列表有关的命令前，如:grep、:vimgrep 及:make，设置全局标记的习惯。另外，在执行与缓冲区列表或参数列表有关的命令前， 如:args {arglist}和:argdo（参见技巧 37），也要设置全局标记。 你总共可以设置 26 个全局位置标记，可以迅速跳回。</p><p><br /></p><h1 id=\"2e0bcfbf\">第四部分 寄存器</h1><p style=\"text-indent: 2em;\">Vim 的寄存器是一组用于保存文件的简单容器。它们既可像剪贴板那样，剪切、复制和粘贴文本；也可以记录一系列按键操作，把它们录制成宏。通过本书的这一部分，我们将掌握这一核心功能。</p><h2 id=\"59b9a56d\">第 10 章 复制与粘贴</h2><p>xp，可被用于“调换光标之后的两个字符”ddp，可被用于“调换当前行和它的下一行” </p><p><br /></p><p>diw 命令不仅删除了单词，而且还将它拷贝到了无名寄存器，按 P时得到的是刚刚删除的单词，而不是之前复制的单词，给命令加 &quot;{register} 前缀的方式指定要用的寄存器，Vim 将缺省使用无 名寄存器。&quot;ayiw复制，用 &quot;bdd删除，&quot;ap粘贴，可以解决无名寄存器的问题，使用复制寄存器也可以解决，黑洞集训器从删除方面也可以解决</p><p><br /></p><p>Vim 的 delete 命令也与标准剪切操作的作用一致。也就是说，该命令会先把 指定文本复制到寄存器后再从文档中删掉，引用黑洞寄存器，&quot;_d{motion}会执行真正的删除操作。</p><p><br /></p><p>无名寄存器（&quot;&quot;）， &quot;&quot;p，它完全等同于 p命令，x 和 d{motion} 经常被当作“删除”命 令。这其实是用词不当，把它们理解为“剪切”命令会更合适</p><p><br /></p><p>复制专用寄存器（&quot;0）使用 y{motion} 命令时，要复制的文本不仅会被拷贝到无名寄存器中，而且也被拷贝到了复制专用寄存器中，因为专用，只有 y 能触发</p><p><br /></p><p>检查无名寄存器和复制专用寄存器的内容，:reg &quot;0 ，小问题用复制专用寄存器，如果碰到需要将一段或多段文本粘贴到多处的情况，有名寄存器就会大显神通。用小写字母引用有名寄存器，会覆盖该寄存器的原有内容，而换用大写字母的话，则会将新内容添加到该寄存器的原有内容之后</p><p><br /></p><p>如果我们在外部程序中用剪切或复制命令获取了文本，就可以通过 &quot;+p 命令（或 在插入模式下用 &lt;C-r&gt;+）将其粘贴到 Vim 内部。相反地，如果在 Vim 的复制或删除 命令之前加入 &quot;+ ，相应的文本将被捕获至系统剪贴板。</p><p>&quot;+ X11 剪贴板，用剪切、复制与粘贴命令操作 &quot;* X11 主剪贴板，用鼠标中键操作把它们粘贴出来，Windows与Mac OS X操作系统并没有主剪贴板的概念，因此 &quot;+ 寄存器与 &quot;* 寄 存器可以混用，它们都代表系统剪贴板。</p><p><br /></p><p>表达式寄存器（&quot;=）当我们从表达式寄存器获取内容时，Vim 将跳到命 令行模式，并显示提示符“=”。这时，我们可以输入一段 Vim 脚本表达式并按 &lt;CR&gt; 执行，如果返回的是字符串（或者可被强制转换成字符串的数据），Vim 将会使用它</p><p><br /></p><p>只读寄存器 &quot;% 当前文件名 &quot;# 轮换文件名 &quot;. 上次插入的文本 &quot;: 上次执行的Ex命令 &quot;/ 上次查找的模式 </p><p><br /></p><p>在可视模式下使用 p 命令时，Vim 将用我们指定的寄存器内容来替换高亮选区中的文本，可视再次解决了文本&quot;丢失&quot;现象，我们输入 u 撤销上次的修改。然后，按 gv重选上一次高亮选区的内容，再按一次 p键。发生了什么？显然什么也没发生，第一次使用 p时，之所以成功，是因为无名寄存器恰巧包含了我们想要的 文本。但在第二次使用 p时，无名寄存器包含的是被覆盖的内容，所以可是模式替换内容也会进入无名寄存器</p><p><br /></p><p>在 Vim 的可视模式下使用 p命令时。首先，从无名寄存器里取出内容，然后，把高亮选区中的内容存入无名寄存器。（<span style=\"color: #F5222D;\">花里胡哨</span>）</p><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1551176775970-4a023ff6-26fa-4f41-8fb3-ecab6fe9c7da.png%22%2C%22originWidth%22%3A364%2C%22originHeight%22%3A125%2C%22name%22%3A%22image.png%22%2C%22size%22%3A13396%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A364%2C%22height%22%3A125%7D\"></card></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1551176803751-7d556e52-aa61-4993-8056-4abf12f643c7.png%22%2C%22originWidth%22%3A363%2C%22originHeight%22%3A174%2C%22name%22%3A%22image.png%22%2C%22size%22%3A15099%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A363%2C%22height%22%3A174%7D\"></card></p><p>c3w命令删除“chips and fish”并重新输入“fish and chips”， 应该会更快地完成任务。但是，以上方法可被用于交换更长的短语</p><p><br /></p><p>p 命令旨在将寄存器中的文本粘贴到光标之后，P 命令用于将文本插入到光标之前，puP 和 Pup几乎成了下意识动作。当要粘贴的内容来自于面向行的寄存器时，p 和 P 命令会把它们粘贴至当前行的 上一行或下一行。这一点比面向字符的行为更直观</p><p><br /></p><p>在插入模式下，我们可以通过输入 &lt;C-r&gt;&quot; 来插入无名寄存器的内容，或者输入 &lt;C-r&gt;0来插入复制专用寄存器的内容</p><p>gp和 gP命令也值得关注，它们会把光标的位置移到被粘贴出来的文本结尾而不是开头。 当复制多行文本时，gP命令尤为管用，P 和 gP 命令区别</p><p><br /></p><p>如果你运行的 Vim 是已集成系统剪贴板的版本，就可以完全避免与'paste' 选项打交道了。普通模式下的 &quot;+p 命令用来粘贴加号寄存器中的内容，即系统剪 贴板的镜像。</p><h2 id=\"b51d83bf\">第 11章 宏</h2><p><br /><cursor /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-26T10:39:49.000Z",
    "deleted_at": null,
    "created_at": "2019-01-15T03:45:00.000Z",
    "updated_at": "2019-02-26T10:39:49.000Z",
    "published_at": "2019-02-26T10:39:49.000Z",
    "first_published_at": "2019-01-15T03:46:52.000Z",
    "word_count": 7499,
    "cover": "",
    "description": "categories: Vim&lt;blockquote class=&quot;blockquote-center&quot;&gt;**希望由厚至薄**&lt;/blockquote&gt;&lt;!-- more --&gt;概述 学习Vim，最难受的就是它对新手出名的不友好，网上一大...",
    "custom_description": "",
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1135993,
    "slug": "budong",
    "title": "首页",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 19,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-13T01:08:41.500Z",
      "updated_at": "2019-02-13T01:08:41.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": null,
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-11T06:11:31.000Z",
    "deleted_at": null,
    "created_at": "2019-01-11T06:11:31.000Z",
    "updated_at": "2019-01-11T06:20:28.000Z",
    "published_at": "2019-01-11T06:12:27.000Z",
    "first_published_at": "2019-01-11T06:12:27.000Z",
    "word_count": 0,
    "cover": "",
    "description": "",
    "custom_description": "",
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1133503,
    "slug": "linux_learning4",
    "title": "Linux学习4",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 19,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-13T01:08:41.500Z",
      "updated_at": "2019-02-13T01:08:41.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Linux\n\n---\n\n<blockquote class=\"blockquote-center\">**linux文件权限设置**</blockquote><br /><!-- more -->\n\n>       编译：peida     \n>       链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html\n\n# chmod命令\n## 概述\nchmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。<br />\nLinux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。<br />\n　　文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。<br />\n　　有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。<br />\n　　每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。\n> -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log\n\n第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。<br />\n确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。<br />\nchmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。\n## 命令格式\nchmod [-cfvR] [--help] [--version] mode file\n## 命令功能\n用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。\n## 命令参数\n### 必要参数\n```\n-c 当发生改变时，报告处理信息\n-f 错误信息不输出\n-R 处理指定目录以及其子目录下的所有文件\n-v 运行时显示详细处理信息\n```\n### 选择参数\n```\n--reference=<目录或者文件> 设置成具有指定目录或者文件具有相同的权限\n--version 显示版本信息\n<权限范围>+<权限设置> 使权限范围内的目录或者文件具有指定的权限\n<权限范围>-<权限设置> 删除权限范围的目录或者文件的指定权限\n<权限范围>=<权限设置> 设置权限范围内的目录或者文件的权限为指定的值\n```\n### 权限范围\n```\nu ：目录或者文件的当前的用户\ng ：目录或者文件的当前的群组\no ：除了目录或者文件的当前用户或群组之外的用户或者群组\na ：所有的用户及群组\n```\n### 权限代号\n```\nr ：读权限，用数字4表示\nw ：写权限，用数字2表示\nx ：执行权限，用数字1表示\n- ：删除权限，用数字0表示\ns ：特殊权限 \n该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。\n```\n### 文字设定法\n> chmod ［who］ ［+ | - | =］ ［mode］ 文件名\n\n### 数字设定法\n我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）\n> chmod ［mode］ 文件名\n\n## 常用命令\n实例：增加文件所有用户组可执行权限<br />\n命令：chmod a+x log2012.log<br />\n说明：即设定文件log2012.log的属性为：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限。<br />实例：同时修改不同用户权限<br />\n命令：chmod ug+w,o-x log2012.log<br />实例：删除文件权限<br />\n命令：chmod a-x log2012.log<br />实例：使用“=”设置权限<br />\n命令：chmod u=x log2012.log<br />\n说明：撤销原来所有的权限，然后使拥有者具有可读权限<br />实例：对一个目录及其子目录所有文件添加权限<br />\n命令：chmod -R u+x test4<br />\n说明：递归地给test4目录下所有文件和子目录的属主分配权限<br />命令：<br />\nchmod 751 file<br />\nchmod u=rwx,g=rx,o=x file<br />\n说明：给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限<br />命令:<br />\nchmod =r file<br />\nchmod 444 file<br />\nchmod a-wx,a+r   file<br />\n说明：所有用户分配读权限\n# chgrp命令\n## 概述\n在Linux系统里，文件或目录的权限掌控以拥有者及所诉群组来管理。可以使用chgrp指令去变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。chgrp命令就是change group的缩写！要被改变的组名必须要在/etc/group文件内才行。\n## 命令格式\nchgrp [选项] [组] [文件]\n## 命令功能\nchgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户。\n## 命令参数\n### 必要参数\n```\n-c 当发生改变时输出调试信息\n-f 不显示错误信息\n-R 处理指定目录以及其子目录下的所有文件\n-v 运行时显示详细的处理信息\n--dereference 作用于符号链接的指向，而不是符号链接本身\n--no-dereference 作用于符号链接本身\n```\n### 选择参数\n```\n--reference=<文件或者目录>\n--help 显示帮助信息\n--version 显示版本信息\n```\n## 常用命令\n实例：改变文件的群组属性<br />\n命令：chgrp -v bin log2012.log<br />\n说明：将log2012.log文件由root群组改为bin群组\n```\n[root@localhost test]# ll\n---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log\n[root@localhost test]# chgrp -v bin log2012.log\n“log2012.log” 的所属组已更改为 bin\n[root@localhost test]# ll\n---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log\n```\n实例：根据指定文件改变文件的群组属性<br />\n命令：chgrp --reference=log2012.log log2013.log<br />\n说明：改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同<br />实例：改变指定目录以及其子目录下的所有文件的群组属性<br />\n命令：chgrp -R bin test6<br />\n说明：改变指定目录以及其子目录下的所有文件的群组属性<br />实例4：通过群组识别码改变文件群组属性<br />\n命令：chgrp -R 100 test6<br />\n说明：通过群组识别码改变文件群组属性，100为users群组的识别码，具体群组和群组识别码可以去/etc/group文件中查看\n# chown命令\n## 概述\nchown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以使组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将问价拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。\n## 命令格式\nchown [选项]... [所有者][:[组]] 文件...\n## 命令功能\n通过chown改变文件的拥有组和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者，其操作权限一般为管理员。\n## 命令参数\n### 必要参数\n\n```\n-c 显示更改的部分的信息\n-f 忽略错误信息\n-h 修复符号链接\n-R 处理指定目录以及其子目录下的所有文件\n-v 显示详细的处理信息\n-deference 作用于符号链接的指向，而不是链接文件本身\n```\n### 选择参数\n\n```\n--reference=<目录或文件> 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组\n--from=<当前用户：当前群组> 只有当前用户和群组跟指定的用户和群组相同时才进行改变\n--help 显示帮助信息\n--version 显示版本信息\n```\n## 常用命令\n**实例：改变拥有者和群组**<br />**命令：**chown mail:mail log2012.log\n\n实例：改变文件拥有者和群组<br />命令：chown root: log2012.log\n\n实例：改变文件群组<br />命令：chown :mail log2012.log\n\n实例：改变指定目录以及其子目录下的所有文件的拥有者和群组<br />命令：chown -R -v root:mail test6\n\n# /etc/group文件详解\n## 概述\nLinux /etc/group文件与/etc/passwd和/etc/shadow文件都是有关于系统管理员对用户和用户组管理时相关的文件。linux /etc/group文件是有关于系统管理员对用户和用户组管理的文件,linux用户组的所有信息都存放在/etc/group文件中。具有某种共同特征的用户集合起来就是用户组（Group）。用户组（Group）配置文件主要有 /etc/group和/etc/gshadow，其中/etc/gshadow是/etc/group的加密信息文件。<br />将用户分组是LInux系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。\n## 格式\n用户组的所有信息都存放在/etc/group文件中。此文件的格式是由冒号(:)隔开若干个字段，这些字段具体如下\n```\n组名:口令:组标识号:组内用户列表\n```\n组名：组名是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。<br />口令：口令字段存放的是用户加密后的口令字。一般LInux系统的用户组都没有口令，即这个字段一般为空，或者是*。<br />组标识号：组标识号与用户表示号类似，也是一个整数，被系统内部用来标识组，别称GID<br />组内用户列表：是属于这个组的所有用户的列表，不同的用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。\n## 使用实例\n[root@localhost test6]# cat /etc/group\n<br />root:x:0:root,linuxsir\n<br />bin:x:1:root,bin,daemon<br />\ndaemon:x:2:root,bin,daemon\n<br />sys:x:3:root,bin<br />说明：我们以root:x:0:root,linuxsir 为例： 用户组root，x是密码段，表示没有设置密码，GID是0,root用户组下包括root、linuxsir以及GID为0的其它用户。\n>       编译：peida\n>       链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html\n\n",
    "body_draft": "",
    "body_html": "<p>categories: Linux</p><p><br /></p><hr /><p><br /></p><p>&lt;blockquote class=&quot;blockquote-center&quot;&gt;**linux文件权限设置**&lt;/blockquote&gt;</p><p>&lt;!-- more --&gt;</p><p><br /></p><blockquote><p>      编译：peida     </p><p>      链接：https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html</p></blockquote><h1 id=\"7058608c\">chmod命令</h1><h2 id=\"a4d3b02a\">概述</h2><p>chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。<br />\nLinux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。<br />\n　　文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。<br />\n　　有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。<br />\n　　每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。</p><blockquote><p>-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</p></blockquote><p>第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。<br />\n确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。<br />\nchmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。</p><h2 id=\"7a2b6560\">命令格式</h2><p>chmod [-cfvR] [--help] [--version] mode file</p><h2 id=\"3b76d0fc\">命令功能</h2><p>用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。</p><h2 id=\"abba4775\">命令参数</h2><h3 id=\"2e355f9f\">必要参数</h3><pre><code>-c 当发生改变时，报告处理信息\n-f 错误信息不输出\n-R 处理指定目录以及其子目录下的所有文件\n-v 运行时显示详细处理信息</code></pre><h3 id=\"4e59ad1a\">选择参数</h3><pre><code>--reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限\n--version 显示版本信息\n&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限\n&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限\n&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值</code></pre><h3 id=\"23dc722b\">权限范围</h3><pre><code>u ：目录或者文件的当前的用户\ng ：目录或者文件的当前的群组\no ：除了目录或者文件的当前用户或群组之外的用户或者群组\na ：所有的用户及群组</code></pre><h3 id=\"78e7c696\">权限代号</h3><pre><code>r ：读权限，用数字4表示\nw ：写权限，用数字2表示\nx ：执行权限，用数字1表示\n- ：删除权限，用数字0表示\ns ：特殊权限 \n该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</code></pre><h3 id=\"9bbcd103\">文字设定法</h3><blockquote><p>chmod ［who］ ［+ | - | =］ ［mode］ 文件名</p></blockquote><h3 id=\"6b78d67c\">数字设定法</h3><p>我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）</p><blockquote><p>chmod ［mode］ 文件名</p></blockquote><h2 id=\"0dfbe902\">常用命令</h2><p>实例：增加文件所有用户组可执行权限<br />\n命令：chmod a+x log2012.log<br />\n说明：即设定文件log2012.log的属性为：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限。</p><p>实例：同时修改不同用户权限<br />\n命令：chmod ug+w,o-x log2012.log</p><p>实例：删除文件权限<br />\n命令：chmod a-x log2012.log</p><p>实例：使用“=”设置权限<br />\n命令：chmod u=x log2012.log<br />\n说明：撤销原来所有的权限，然后使拥有者具有可读权限</p><p>实例：对一个目录及其子目录所有文件添加权限<br />\n命令：chmod -R u+x test4<br />\n说明：递归地给test4目录下所有文件和子目录的属主分配权限</p><p>命令：<br />\nchmod 751 file<br />\nchmod u=rwx,g=rx,o=x file<br />\n说明：给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</p><p>命令:<br />\nchmod =r file<br />\nchmod 444 file<br />\nchmod a-wx,a+r   file<br />\n说明：所有用户分配读权限</p><h1 id=\"3e2f0954\">chgrp命令</h1><h2 id=\"a4d3b02a\">概述</h2><p>在Linux系统里，文件或目录的权限掌控以拥有者及所诉群组来管理。可以使用chgrp指令去变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。chgrp命令就是change group的缩写！要被改变的组名必须要在/etc/group文件内才行。</p><h2 id=\"7a2b6560\">命令格式</h2><p>chgrp [选项] [组] [文件]</p><h2 id=\"3b76d0fc\">命令功能</h2><p>chgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户。</p><h2 id=\"abba4775\">命令参数</h2><h3 id=\"2e355f9f\">必要参数</h3><pre><code>-c 当发生改变时输出调试信息\n-f 不显示错误信息\n-R 处理指定目录以及其子目录下的所有文件\n-v 运行时显示详细的处理信息\n--dereference 作用于符号链接的指向，而不是符号链接本身\n--no-dereference 作用于符号链接本身</code></pre><h3 id=\"4e59ad1a\">选择参数</h3><pre><code>--reference=&lt;文件或者目录&gt;\n--help 显示帮助信息\n--version 显示版本信息</code></pre><h2 id=\"0dfbe902\">常用命令</h2><p>实例：改变文件的群组属性<br />\n命令：chgrp -v bin log2012.log<br />\n说明：将log2012.log文件由root群组改为bin群组</p><pre><code>[root@localhost test]# ll\n---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log\n[root@localhost test]# chgrp -v bin log2012.log\n“log2012.log” 的所属组已更改为 bin\n[root@localhost test]# ll\n---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log</code></pre><p>实例：根据指定文件改变文件的群组属性<br />\n命令：chgrp --reference=log2012.log log2013.log<br />\n说明：改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同</p><p>实例：改变指定目录以及其子目录下的所有文件的群组属性<br />\n命令：chgrp -R bin test6<br />\n说明：改变指定目录以及其子目录下的所有文件的群组属性</p><p>实例4：通过群组识别码改变文件群组属性<br />\n命令：chgrp -R 100 test6<br />\n说明：通过群组识别码改变文件群组属性，100为users群组的识别码，具体群组和群组识别码可以去/etc/group文件中查看</p><h1 id=\"fe65b2cf\">chown命令</h1><h2 id=\"a4d3b02a\">概述</h2><p>chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以使组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将问价拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。</p><h2 id=\"7a2b6560\">命令格式</h2><p><span class=\"lake-fontsize-10\" style=\"color: #333333;\">chown [选项]... [所有者][:[组]] 文件...</span></p><h2 id=\"3b76d0fc\"><span class=\"lake-fontsize-10\" style=\"color: #333333;\"></span>命令功能</h2><p>通过chown改变文件的拥有组和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者，其操作权限一般为管理员。</p><h2 id=\"abba4775\">命令参数</h2><h3 id=\"2e355f9f\">必要参数</h3><p><br /></p><pre><code>-c 显示更改的部分的信息\n-f 忽略错误信息\n-h 修复符号链接\n-R 处理指定目录以及其子目录下的所有文件\n-v 显示详细的处理信息\n-deference 作用于符号链接的指向，而不是链接文件本身</code></pre><h3 id=\"4e59ad1a\">选择参数</h3><p><br /></p><pre><code>--reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组\n--from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变\n--help 显示帮助信息\n--version 显示版本信息</code></pre><h2 id=\"0dfbe902\">常用命令</h2><p><strong>实例：改变拥有者和群组</strong></p><p><strong>命令：</strong>chown mail:mail log2012.log</p><p><br /></p><p>实例：改变文件拥有者和群组</p><p>命令：chown root: log2012.log</p><p><br /></p><p>实例：改变文件群组</p><p>命令：chown :mail log2012.log</p><p><br /></p><p>实例：改变指定目录以及其子目录下的所有文件的拥有者和群组</p><p>命令：chown -R -v root:mail test6</p><p><br /></p><h1 id=\"5c67538b\">/etc/group文件详解</h1><h2 id=\"a4d3b02a\">概述</h2><p><span class=\"lake-fontsize-10\" style=\"color: #333333;\">Linux /etc/group文件与/etc/passwd和/etc/shadow文件都是有关于系统管理员对用户和用户组管理时相关的文件。linux /etc/group文件是有关于系统管理员对用户和用户组管理的文件,linux用户组的所有信息都存放在/etc/group文件中。具有某种共同特征的用户集合起来就是用户组（Group）。用户组（Group）配置文件主要有 /etc/group和/etc/gshadow，其中/etc/gshadow是/etc/group的加密信息文件。</span></p><p><span class=\"lake-fontsize-10\" style=\"color: #333333;\">将用户分组是LInux系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中成员时，在<span class=\"lake-fontsize-10\" style=\"color: #333333;\">/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</span></span></p><h2 id=\"e3127cc1\"><span class=\"lake-fontsize-10\" style=\"color: #333333;\"><span class=\"lake-fontsize-10\" style=\"color: #333333;\"></span></span>格式</h2><p>用户组的所有信息都存放在/etc/group文件中。此文件的格式是由冒号(:)隔开若干个字段，这些字段具体如下</p><pre><code>组名:口令:组标识号:组内用户列表</code></pre><p>组名：组名是用户组的名称，由字母或数字构成。与<span class=\"lake-fontsize-10\" style=\"color: #333333;\">/etc/passwd</span>中的登录名一样，组名不应重复。</p><p>口令：口令字段存放的是用户加密后的口令字。一般LInux系统的用户组都没有口令<span class=\"lake-fontsize-10\" style=\"color: #333333;\">，即这个字段一般为空，或者是*。</span></p><p>组标识号：组标识号与用户表示号类似，也是一个整数，被系统内部用来标识组，别称GID</p><p>组内用户列表：是属于这个组的所有用户的列表，不同的用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</p><h2 id=\"83a25e35\">使用实例</h2><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">[root@localhost test6]# cat /etc/group\n</span></p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">root:x:0:root,linuxsir\n</span></p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">bin:x:1:root,bin,daemon</span></p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">\ndaemon:x:2:root,bin,daemon\n</span></p><p><span class=\"lake-fontsize-9\" style=\"color: #000000; background-color: #F5F5F5;\">sys:x:3:root,bin</span></p><p>说明：<span class=\"lake-fontsize-10\" style=\"color: #333333;\">我们以root:x:0:root,linuxsir 为例： 用户组root，x是密码段，表示没有设置密码，GID是0,root用户组下包括root、linuxsir以及GID为0的其它用户。</span></p><blockquote><p>      编译：peida</p><p>      链接<span style=\"color: #262626;\">：</span>https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html</p></blockquote>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-01-15T06:03:14.000Z",
    "deleted_at": null,
    "created_at": "2019-01-10T11:23:45.000Z",
    "updated_at": "2019-01-15T06:03:14.000Z",
    "published_at": "2019-01-15T06:03:14.000Z",
    "first_published_at": "2019-01-10T12:13:34.000Z",
    "word_count": 3181,
    "cover": "",
    "description": "categories: Linux&lt;blockquote class=&quot;blockquote-center&quot;&gt;**linux文件权限设置**&lt;/blockquote&gt;&lt;!-- more --&gt;      编译：peida         ...",
    "custom_description": "&lt;blockquote class=&quot;blockquote-center&quot;&gt;**linux文件权限设置**&lt;/blockquote&gt;&lt;!-- more --&gt;      编译：peida      链接：https://www.cnblo...",
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1253660,
    "slug": "num_5",
    "title": "5. Longest Palindromic Substring",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-15T15:33:45.028Z",
      "updated_at": "2019-02-15T15:33:45.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n![5.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1550243072369-11377f07-8e83-417e-ac9a-dbac75c3b585.png#align=left&display=inline&height=673&linkTarget=_blank&name=5.png&originHeight=673&originWidth=740&size=99189&width=740)<br /><!-- more -->\n## 题目描述\nGiven a string **s**, find the longest palindromic substring in **s**. You may assume that the maximum length of **s** is 1000.<br />**Example 1:**\n**Input:** \"babad\"\n**Output:** \"bab\"\n**Note:** \"aba\" is also a valid answer.**Example 2:**\n**Input:** \"cbbd\"\n**Output:** \"bb\"<br />## 参考代码\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() < 1) return \"\";\n        int start = 0, end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int len1 = expandAroundCenter(s, i, i);//奇数\n            int len2 = expandAroundCenter(s, i, i + 1);//偶数\n            int len = Math.max(len1, len2);\n            if (len > end - start) {\n                start = i - (len - 1) / 2;//确使奇偶行得通\n                end = i + len / 2;\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n    \n    private int expandAroundCenter(String s, int left, int right) {\n        int L = left, R = right;\n        while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R))\n        {\n            L--;\n            R++;\n        }\n        return R - L - 1;//因为循环结束时，长度各边减一\n    }\n    \n}\n```\n\n## 思路及总结\n偶数减一除以二(0.5-1.0)和奇数减一除以二(0.0-0.5)两者可以保持除法上的一致。<br />官方首先提醒了最长公共子串的误区，然后列举了暴力法，动态规划，和本题的中心扩展法。详细内容直接参考官方题解。\n## 参考\n[https://leetcode-cn.com/problems/longest-palindromic-substring/solution/](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/)<br />[https://leetcode.com/problems/longest-palindromic-substring/solution/](https://leetcode.com/problems/longest-palindromic-substring/solution/)<br />Manacher 算法<br />[https://segmentfault.com/a/1190000008484167](https://segmentfault.com/a/1190000008484167)\n",
    "body_draft": "categories: leetcode\n\n---\n![215.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548506060055-118e8488-7b24-4981-8a99-75880675fde5.png#align=left&display=inline&height=411&linkTarget=_blank&name=215.png&originHeight=806&originWidth=1464&size=153252&width=746)<br /><!-- more -->\n## 题目描述\n在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br />**示例 1:**\n**输入:** ```\n[3,2,1,5,6,4] 和\n```\n k = 2\n**输出:** 5**示例 2:**\n**输入:** ```\n[3,2,3,1,2,4,5,5,6] 和\n```\n k = 4\n**输出:** 4**说明:**<br />你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n## 参考代码\n\n```java\nclass Solution {\n   public static int findKthLargest(int[] nums, int k) {\n\t\tPriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n       for(int num :nums) {\n           priorityQueue.add(num);\n           if(priorityQueue.size() > k) {\n               priorityQueue.poll();\n           }\n       }\n       return priorityQueue.peek();\n   }\n}\n```\n\n## 思路及总结\n主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。\n## 参考\n[https://www.kancloud.cn/maliming/leetcode/844880](https://www.kancloud.cn/maliming/leetcode/844880)\n",
    "body_html": "<p>categories: leetcode</p><p><br /></p><hr /><p><img alt=\"5.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1550243072369-11377f07-8e83-417e-ac9a-dbac75c3b585.png#align=left&amp;display=inline&amp;height=673&amp;linkTarget=_blank&amp;name=5.png&amp;originHeight=673&amp;originWidth=740&amp;size=99189&amp;width=740\" style=\"max-width: 600px; width: 740px;\" /></p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> &quot;babad&quot;\n<strong>Output:</strong> &quot;bab&quot;\n<strong>Note:</strong> &quot;aba&quot; is also a valid answer.</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> &quot;cbbd&quot;\n<strong>Output:</strong> &quot;bb&quot;</pre><pre><br /></pre><h2 id=\"36967e2c\">参考代码</h2><pre data-lang=\"java\"><code>class Solution {\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() &lt; 1) return &quot;&quot;;\n        int start = 0, end = 0;\n        for (int i = 0; i &lt; s.length(); i++) {\n            int len1 = expandAroundCenter(s, i, i);//奇数\n            int len2 = expandAroundCenter(s, i, i + 1);//偶数\n            int len = Math.max(len1, len2);\n            if (len &gt; end - start) {\n                start = i - (len - 1) / 2;//确使奇偶行得通\n                end = i + len / 2;\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n    \n    private int expandAroundCenter(String s, int left, int right) {\n        int L = left, R = right;\n        while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R))\n        {\n            L--;\n            R++;\n        }\n        return R - L - 1;//因为循环结束时，长度各边减一\n    }\n    \n}</code></pre><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p style=\"text-indent: 2em;\">偶数减一除以二(0.5-1.0)和奇数减一除以二(0.0-0.5)两者可以保持除法上的一致。</p><p style=\"text-indent: 2em;\">官方首先提醒了最长公共子串的误区，然后列举了暴力法，动态规划，和本题的中心扩展法。详细内容直接参考官方题解。</p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/solution/\" target=\"_blank\">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/</a></p><p><a href=\"https://leetcode.com/problems/longest-palindromic-substring/solution/\" target=\"_blank\">https://leetcode.com/problems/longest-palindromic-substring/solution/</a></p><p>Manacher 算法</p><p><a href=\"https://segmentfault.com/a/1190000008484167\" target=\"_blank\">https://segmentfault.com/a/1190000008484167</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-15T15:33:45.000Z",
    "deleted_at": null,
    "created_at": "2019-02-15T10:01:56.000Z",
    "updated_at": "2019-02-15T15:33:45.000Z",
    "published_at": "2019-02-15T15:33:45.000Z",
    "first_published_at": "2019-02-15T10:03:54.000Z",
    "word_count": 328,
    "cover": null,
    "description": "categories: leetcode&lt;!-- more --&gt;题目描述Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1253654,
    "slug": "rvho4p",
    "title": "无标题",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-15T15:29:26.933Z",
      "updated_at": "2019-02-15T15:29:26.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": null,
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-15T10:01:11.000Z",
    "deleted_at": null,
    "created_at": "2019-02-15T10:01:11.000Z",
    "updated_at": "2019-02-15T10:01:11.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1257983,
    "slug": "num_10",
    "title": "10. Regular Expression Matching",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 20,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-24T14:55:40.237Z",
      "updated_at": "2019-02-24T14:55:40.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n![10.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1550394708947-b2e326a7-efb4-4624-96c8-8c9a9fd008a5.png#align=left&display=inline&height=305&linkTarget=_blank&name=10.png&originHeight=403&originWidth=985&size=75736&status=done&width=746)<br /><!-- more --><br />摘要里面放的是递归的方法，下面的是动态规划(Dynamic Programming)的方法。<br />![10_2.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1550396242107-90e5eb98-055a-45c0-8664-aaceef9e1e18.png#align=left&display=inline&height=385&linkTarget=_blank&name=10_2.png&originHeight=529&originWidth=1024&size=90834&status=done&width=746)\n<a name=\"273a27cc\"></a>\n## 题目描述\nGiven an input string (`s`) and a pattern (`p`), implement regular expression matching with support for `'.'` and `'*'`.<br />'.' Matches any single character.<br />'*' Matches zero or more of the preceding element.<br />The matching should cover the **entire** input string (not partial).<br />**Note:**\n* `s` could be empty and contains only lowercase letters `a-z`.\n* `p` could be empty and contains only lowercase letters `a-z`, and characters like `.` or `*`.\n\n**Example 1:**\n**Input:**\ns = \"aa\"\np = \"a\"\n**Output:** false\n**Explanation:** \"a\" does not match the entire string \"aa\".**Example 2:**\n**Input:**\ns = \"aa\"\np = \"a*\"\n**Output:** true\n**Explanation:** '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".**Example 3:**\n**Input:**\ns = \"ab\"\np = \".*\"\n**Output:** true\n**Explanation:** \".*\" means \"zero or more (*) of any character (.)\".**Example 4:**\n**Input:**\ns = \"aab\"\np = \"c*a*b\"\n**Output:** true\n**Explanation:** c can be repeated 0 times, a can be repeated 1 time.Therefore it matches \"aab\".**Example 5:**\n**Input:**\ns = \"mississippi\"\np = \"mis*is*p*.\"\n**Output:** false\n<a name=\"36967e2c\"></a>\n## 参考代码\n```java\n//递归\nclass Solution {\n    public boolean isMatch(String s, String p) {\n        if (p.isEmpty()) return s.isEmpty();\n        boolean first_match = (!s.isEmpty() &&\n                               (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.'));\n\n        if (p.length() >= 2 && p.charAt(1) == '*'){\n          //(isMatch(s, p.substring(2))使第 p 中第三个字符进行匹配，\n          //(first_match && isMatch(s.substring(1), p))使 p 中 * 之前的字符进行匹配\n            return (isMatch(s, p.substring(2)) ||\n                    (first_match && isMatch(s.substring(1), p)));\n        } else {\n            return first_match && isMatch(s.substring(1), p.substring(1));\n        }\n    }\n}\n//DP\n\n\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\n        dp[s.length()][p.length()] = true;\n        \n        for (int i = s.length(); i >= 0; i--){\n            for (int j = p.length() - 1; j >= 0; j--){\n                boolean first_match = (i < s.length() && (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.'));\n                if (j + 1 < p.length() && p.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];//\n                  \n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}\n```\n\n<a name=\"d7d37168\"></a>\n## 思路及总结\n递归的思路： 大致是以 p 字段划分，两两进行递归。0,1,2个字符、纯字母和含有 . 的都较好理解。下面考虑含有 * 符号的。例如 aaacce 和 a*c*e，(first_match && isMatch(s.substring(1), p)) 递归到 cce 和 a*c*e 的情况，然后 (isMatch(s, p.substring(2)) 收拾最后一步，则 p 中 a*c 的匹配结束，但是删除的字符是 a*，第三个字符可能在接下来的一组进行使用。<br />到了这一步，大致理解 If a star is present in the pattern, it will be in the second position \\text{pattern[1]}pattern[1]. Then, we may ignore this part of the pattern, or delete a matching character in the text. If we have a match on the remaining strings after any of these operations, then the initial inputs matched. 是什么含义。但是看懂和写何止十万八千里，我还不知到要学习多少次，才能有这样的算法功底。复杂度有些复杂，大致应当是指空间复杂度为O(2^n)，空间复杂度是O(n^2)；<br />DP的思路：<br />了解一下DP：[https://blog.csdn.net/zjkc050818/article/details/74532023](https://blog.csdn.net/zjkc050818/article/details/74532023)<br />可能更适合看是视频：[https://www.bilibili.com/video/av16544031/?spm_id_from=333.788.videocard.0](https://www.bilibili.com/video/av16544031/?spm_id_from=333.788.videocard.0)<br />这里面提到了表格的DP：[https://www.bilibili.com/video/av18512769?from=search&seid=1441380389563731271](https://www.bilibili.com/video/av18512769?from=search&seid=1441380389563731271)<br />这个 DP 的选与不选都不明显，而且很难判断出口，等做多了，想必能更好理解。<br />啥都不会是我最大的觉悟。。。。。别人是兔派，我是兔看派，第一次遇见dp，都说dp和博弈论是神仙题，我感受到了。\n<a name=\"d17a0f0b\"></a>\n## 参考\n[https://leetcode.com/problems/regular-expression-matching/solution/](https://leetcode.com/problems/regular-expression-matching/solution/)\n",
    "body_draft": "",
    "body_html": "<p>categories: leetcode</p><p><br /></p><hr /><p><img alt=\"10.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1550394708947-b2e326a7-efb4-4624-96c8-8c9a9fd008a5.png#align=left&amp;display=inline&amp;height=305&amp;linkTarget=_blank&amp;name=10.png&amp;originHeight=403&amp;originWidth=985&amp;size=75736&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p>&lt;!-- more --&gt;</p><p>摘要里面放的是递归的方法，下面的是动态规划(Dynamic Programming)的方法。</p><p><img alt=\"10_2.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1550396242107-90e5eb98-055a-45c0-8664-aaceef9e1e18.png#align=left&amp;display=inline&amp;height=385&amp;linkTarget=_blank&amp;name=10_2.png&amp;originHeight=529&amp;originWidth=1024&amp;size=90834&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><h2 id=\"273a27cc\">题目描述</h2><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>'.'</code> and <code>'*'</code>.</p><p>'.' Matches any single character.</p><p>'*' Matches zero or more of the preceding element.</p><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Note:</strong></p><ul><li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li><li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li></ul><p><strong>Example 1:</strong></p><pre><strong>Input:</strong>\ns = &quot;aa&quot;\np = &quot;a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong>\ns = &quot;aa&quot;\np = &quot;a*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;.</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong>\ns = &quot;ab&quot;\np = &quot;.*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</pre><p><strong>Example 4:</strong></p><pre><strong>Input:</strong>\ns = &quot;aab&quot;\np = &quot;c*a*b&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> c can be repeated 0 times, a can be repeated 1 time.</pre><pre>Therefore it matches &quot;aab&quot;.</pre><p><strong>Example 5:</strong></p><pre><strong>Input:</strong>\ns = &quot;mississippi&quot;\np = &quot;mis*is*p*.&quot;\n<strong>Output:</strong> false</pre><p><br /></p><h2 id=\"36967e2c\">参考代码</h2><pre data-lang=\"java\"><code>//递归\nclass Solution {\n    public boolean isMatch(String s, String p) {\n        if (p.isEmpty()) return s.isEmpty();\n        boolean first_match = (!s.isEmpty() &amp;&amp;\n                               (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.'));\n\n        if (p.length() &gt;= 2 &amp;&amp; p.charAt(1) == '*'){\n          //(isMatch(s, p.substring(2))使第 p 中第三个字符进行匹配，\n          //(first_match &amp;&amp; isMatch(s.substring(1), p))使 p 中 * 之前的字符进行匹配\n            return (isMatch(s, p.substring(2)) ||\n                    (first_match &amp;&amp; isMatch(s.substring(1), p)));\n        } else {\n            return first_match &amp;&amp; isMatch(s.substring(1), p.substring(1));\n        }\n    }\n}\n//DP\n\n\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\n        dp[s.length()][p.length()] = true;\n        \n        for (int i = s.length(); i &gt;= 0; i--){\n            for (int j = p.length() - 1; j &gt;= 0; j--){\n                boolean first_match = (i &lt; s.length() &amp;&amp; (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.'));\n                if (j + 1 &lt; p.length() &amp;&amp; p.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j];//\n                  \n                } else {\n                    dp[i][j] = first_match &amp;&amp; dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}</code></pre><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p style=\"text-indent: 2em;\">递归的思路： 大致是以 p 字段划分，两两进行递归。0,1,2个字符、纯字母和含有 . 的都较好理解。下面考虑含有 * 符号的。例如 aaacce 和 a*c*e，(first_match &amp;&amp; isMatch(s.substring(1), p)) 递归到 cce 和 a*c*e 的情况，然后 (isMatch(s, p.substring(2)) 收拾最后一步，则 p 中 a*c 的匹配结束，但是删除的字符是 a*，第三个字符可能在接下来的一组进行使用。</p><p style=\"text-indent: 2em;\">到了这一步，大致理解 <span>If a star is present in the pattern, it will be in the second position </span><span><span>\\text{pattern[1]}</span><span>pattern[1]</span></span><span>. Then, we may ignore this part of the pattern, or delete a matching character in the text. If we have a match on the remaining strings after any of these operations, then the initial inputs matched. 是什么含义。但是看懂和写何止十万八千里，我还不知到要学习多少次，才能有这样的算法功底。复杂度有些复杂，大致应当是指空间复杂度为O(2^n)，空间复杂度是O(n^2)；</span></p><p style=\"text-indent: 2em;\"><span>DP的思路：</span></p><p>了解一下DP：<a href=\"https://blog.csdn.net/zjkc050818/article/details/74532023\" target=\"_blank\">https://blog.csdn.net/zjkc050818/article/details/74532023</a></p><p>可能更适合看是视频：<a href=\"https://www.bilibili.com/video/av16544031/?spm_id_from=333.788.videocard.0\" target=\"_blank\">https://www.bilibili.com/video/av16544031/?spm_id_from=333.788.videocard.0</a></p><p>这里面提到了表格的DP：<a href=\"https://www.bilibili.com/video/av18512769?from=search&amp;seid=1441380389563731271\" target=\"_blank\">https://www.bilibili.com/video/av18512769?from=search&amp;seid=1441380389563731271</a></p><p>这个 DP 的选与不选都不明显，而且很难判断出口，等做多了，想必能更好理解。</p><p><span>啥都不会是我最大的觉悟。。。。。别人是兔派，我是兔看派，第一次遇见dp，都说dp和博弈论是神仙题，我感受到了。</span></p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://leetcode.com/problems/regular-expression-matching/solution/\" target=\"_blank\">https://leetcode.com/problems/regular-expression-matching/solution/</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-24T14:55:40.000Z",
    "deleted_at": null,
    "created_at": "2019-02-17T08:19:15.000Z",
    "updated_at": "2019-02-24T14:55:40.000Z",
    "published_at": "2019-02-24T14:55:40.000Z",
    "first_published_at": "2019-02-17T09:39:36.000Z",
    "word_count": 881,
    "cover": null,
    "description": "categories: leetcode&lt;!-- more --&gt;摘要里面放的是递归的方法，下面的是动态规划(Dynamic Programming)的方法。题目描述Given an input string (s) and a pattern (p), implement reg...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1268941,
    "slug": "try_test1",
    "title": "小的尝试",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 20,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-24T14:55:40.237Z",
      "updated_at": "2019-02-24T14:55:40.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Life\n\n---\n\n<blockquote class=\"blockquote-center\">**一些相关的计算机资料，侵删**</blockquote><br /><!-- more -->\n# 获取\n下载链接：<br />https://www.fageka.com/i/T8PXVDj0040\n# 目录树\n   ├─Algorithm<br />   │      Algorihms 4th Edition by Robert Sedgewick, Kevin Wayne.pdf<br />   │      剑指 Offer.pdf<br />   │      挑战程序设计竞赛(第2版).巫泽俊.扫描版.pdf<br />   │      程序员代码面试指南 IT 名企算法与数据结构题目最优解 左程云著.pdf<br />   │      算法 第四版.pdf<br />   │      编程之美.pdf<br />   │      <br />   ├─Architecture<br />   │      NoSQL 精粹.pdf<br />   │      从 PAXOS 到 ZOOKEEPER 分布式一致性原理与实践.pdf<br />   │      大型网站技术架构：核心原理与案例分析+李智慧.pdf<br />   │      大规模分布式存储系统：原理解析与架构实战.pdf<br />   │      实现领域驱动设计.pdf<br />   │      微服务设计.epub<br />   │      淘宝技术这十年.pdf<br />   │      <br />   ├─C++<br />   │      C 和指针.pdf<br />   │      C++ Primer 第五版.pdf<br />   │      Linux 多线程服务端编程：使用 muduo C++网络库.pdf<br />   │      <br />   ├─Computer Network<br />   │      HTTP 权威指南.pdf<br />   │      图解 HTTP.pdf<br />   │      图解 TCP IP 第五版.pdf<br />   │      计算机网络 第七版.pdf<br />   │      <br />   ├─Database<br />   │      MySQL 必知必会.pdf<br />   │      MySQL 技术内幕 InnoDB 存储引擎 第 2 版.pdf<br />   │      O'Reilly.High.Performance.MySQL.3rd.Edition.M.pdf<br />   │      Redis 实战.pdf<br />   │      Redis 设计与实现.pdf<br />   │      数据库系统概论.pdf<br />   │      高性能 MySQL 第三版.pdf<br />   │      <br />   ├─Interview<br />   │  │  王道程序员面试宝典.pdf<br />   │  │  <br />   │  └─Java 校招面试 Google 面试官亲授<br />   │      │  project.zip<br />   │      │  <br />   │      ├─第10章谷歌在线笔试题解<br />   │      │      10-1 解小数据集.wmv<br />   │      │      10-2 估算算法时间.wmv<br />   │      │      10-3 解大数据集（上）.wmv<br />   │      │      10-4 解大数据集（下）.wmv<br />   │      │      10-5 运气和异常.wmv<br />   │      │      <br />   │      ├─第11章面试的软技巧和总结<br />   │      │      11-1 面试过程和注意点.wmv<br />   │      │      11-2 总结.wmv<br />   │      │      <br />   │      ├─第1章课程引言<br />   │      │      1-1 _导学.wmv<br />   │      │      1-2 校招录取率和在线笔试.wmv<br />   │      │      1-3 从一道谷歌在线笔试开始.wmv<br />   │      │      <br />   │      ├─第2章操作系统<br />   │      │      2-1 操作系统_概述.wmv<br />   │      │      2-2 进程和线程.wmv<br />   │      │      2-3 存储和寻址.wmv<br />   │      │      2-4 操作系统_例题.wmv<br />   │      │      <br />   │      ├─第3章网络<br />   │      │      3-1 网络基础.wmv<br />   │      │      3-2 滑动窗口问题.wmv<br />   │      │      3-3 网络抓包演示.wmv<br />   │      │      3-4 网络例题.wmv<br />   │      │      <br />   │      ├─第4章数据库<br />   │      │      4-1 数据库_概述.wmv<br />   │      │      4-2 JOIN和GROUP BY.wmv<br />   │      │      4-3 事务和乐观锁.wmv<br />   │      │      4-4 数据库例题.wmv<br />   │      │      <br />   │      ├─第5章程序设计语言基础<br />   │      │      5-1 程序设计语言基础_归类.wmv<br />   │      │      5-2 数据类型、整数和补码.wmv<br />   │      │      5-3 浮点数和定点数简述.wmv<br />   │      │      5-4 Java数据类型、拆箱和装箱.wmv<br />   │      │      <br />   │      ├─第7章面向对象<br />   │      │      7-1 面向对象_概述.wmv<br />   │      │      7-10 面向对象_不可变性.wmv<br />   │      │      7-11 泛型（上）.wmv<br />   │      │      7-12 泛型（下）.wmv<br />   │      │      7-13 虚函数表.wmv<br />   │      │      7-14 面向对象_小结.wmv<br />   │      │      7-2 面向对象_类与对象.wmv<br />   │      │      7-3 对象的特殊函数（上）.wmv<br />   │      │      7-4 对象的特殊函数（下）.wmv<br />   │      │      7-5 接口与抽象类.wmv<br />   │      │      7-6 实现Iterable接口.wmv<br />   │      │      7-7 继承.wmv<br />   │      │      7-8 封装.wmv<br />   │      │      7-9 面向对象_例题.wmv<br />   │      │      <br />   │      ├─第8章设计模式<br />   │      │      8-1 设计模式简介.wmv<br />   │      │      8-2 State模式.wmv<br />   │      │      8-3 Decorator模式.wmv<br />   │      │      8-4 创建对象.wmv<br />   │      │      <br />   │      └─第9章高级知识点<br />   │              9-1 高级知识点.wmv<br />   │              9-2 外部排序分析.wmv<br />   │              9-3 死锁分析.wmv<br />   │              9-4 线程池介绍.wmv<br />   │              9-5 线程池_Java Excutor Framework演示（上）.wmv<br />   │              9-6 线程池_Java Excutor Framework演示（下）.wmv<br />   │              9-7 资源管理.wmv<br />   │              <br />   ├─Java<br />   │      Java Concurrency in Practice.pdf<br />   │      Java 编程思想 第四版.pdf<br />   │      Thinking in Java 4th Edition.pdf<br />   │      分布式 Java 应用基础与实践.pdf<br />   │      深入理解 Java 虚拟机 2.pdf<br />   │      精通Spring 4.x 企业应用开发实战.pdf<br />   │      <br />   ├─Middleware<br />   │      Kafka权威指南.epub<br />   │      RabbitMQ 实战指南.pdf<br />   │      <br />   ├─OOP<br />   │      head first design patterns.pdf<br />   │      Head First 设计模式.pdf<br />   │      深入浅出面向对象分析与设计.扫描版.pdf<br />   │      <br />   ├─Operating System<br />   │      Modern Operating Systems.pdf<br />   │      深入理解计算机系统 第三版.pdf<br />   │      <br />   ├─Popularization<br />   │      编码：隐匿在计算机软硬件背后的语言.pdf<br />   │      计算机程序的构造和解释.pdf<br />   │      <br />   ├─Python<br />   │      Flask Web开发：基于Python的Web应用开发实战.pdf<br />   │      Python 编程：从入门到实践.pdf<br />   │      <br />   ├─Software Construction<br />   │      人月神话.mobi<br />   │      代码大全.epub<br />   │      代码大全.pdf<br />   │      代码整洁之道.mobi<br />   │      程序员的职业素养.pdf<br />   │      编写可读代码的艺术.pdf<br />   │      重构 改善既有代码的设计.pdf<br />   │      <br />   ├─Tools<br />   │      git-cheat-sheet.pdf<br />   │      Pro Git.pdf<br />   │      正则表达式必知必会.pdf<br />   │      <br />   └─Unix-Linux<br />           The Linux Command Line.pdf<br />           UNIX 环境高级编程.pdf<br />           UNIX 网络编程.pdf<br />           Unix-Linux 编程实践教程.pdf<br />           鸟哥的 Linux 私房菜 基础篇 第四版.pdf\n",
    "body_draft": "",
    "body_html": "<p>categories: Life</p><p><br /></p><hr /><p><br /></p><p>&lt;blockquote class=&quot;blockquote-center&quot;&gt;**<span>一些相关的计算机资料，侵删</span>**&lt;/blockquote&gt;</p><p>&lt;!-- more --&gt;</p><h1 id=\"8dc09ebe\">获取</h1><p>下载链接：</p><p><span class=\"lake-fontsize-9\" style=\"color: #C00000;\">https://www.fageka.com/i/T8PXVDj0040</span></p><h1 id=\"3ec00a54\">目录树</h1><p>   ├─Algorithm</p><p>   │      Algorihms 4th Edition by Robert Sedgewick, Kevin Wayne.pdf</p><p>   │      剑指 Offer.pdf</p><p>   │      挑战程序设计竞赛(第2版).巫泽俊.扫描版.pdf</p><p>   │      程序员代码面试指南 IT 名企算法与数据结构题目最优解 左程云著.pdf</p><p>   │      算法 第四版.pdf</p><p>   │      编程之美.pdf</p><p>   │      </p><p>   ├─Architecture</p><p>   │      NoSQL 精粹.pdf</p><p>   │      从 PAXOS 到 ZOOKEEPER 分布式一致性原理与实践.pdf</p><p>   │      大型网站技术架构：核心原理与案例分析+李智慧.pdf</p><p>   │      大规模分布式存储系统：原理解析与架构实战.pdf</p><p>   │      实现领域驱动设计.pdf</p><p>   │      微服务设计.epub</p><p>   │      淘宝技术这十年.pdf</p><p>   │      </p><p>   ├─C++</p><p>   │      C 和指针.pdf</p><p>   │      C++ Primer 第五版.pdf</p><p>   │      Linux 多线程服务端编程：使用 muduo C++网络库.pdf</p><p>   │      </p><p>   ├─Computer Network</p><p>   │      HTTP 权威指南.pdf</p><p>   │      图解 HTTP.pdf</p><p>   │      图解 TCP IP 第五版.pdf</p><p>   │      计算机网络 第七版.pdf</p><p>   │      </p><p>   ├─Database</p><p>   │      MySQL 必知必会.pdf</p><p>   │      MySQL 技术内幕 InnoDB 存储引擎 第 2 版.pdf</p><p>   │      O'Reilly.High.Performance.MySQL.3rd.Edition.M.pdf</p><p>   │      Redis 实战.pdf</p><p>   │      Redis 设计与实现.pdf</p><p>   │      数据库系统概论.pdf</p><p>   │      高性能 MySQL 第三版.pdf</p><p>   │      </p><p>   ├─Interview</p><p>   │  │  王道程序员面试宝典.pdf</p><p>   │  │  </p><p>   │  └─Java 校招面试 Google 面试官亲授</p><p>   │      │  project.zip</p><p>   │      │  </p><p>   │      ├─第10章谷歌在线笔试题解</p><p>   │      │      10-1 解小数据集.wmv</p><p>   │      │      10-2 估算算法时间.wmv</p><p>   │      │      10-3 解大数据集（上）.wmv</p><p>   │      │      10-4 解大数据集（下）.wmv</p><p>   │      │      10-5 运气和异常.wmv</p><p>   │      │      </p><p>   │      ├─第11章面试的软技巧和总结</p><p>   │      │      11-1 面试过程和注意点.wmv</p><p>   │      │      11-2 总结.wmv</p><p>   │      │      </p><p>   │      ├─第1章课程引言</p><p>   │      │      1-1 _导学.wmv</p><p>   │      │      1-2 校招录取率和在线笔试.wmv</p><p>   │      │      1-3 从一道谷歌在线笔试开始.wmv</p><p>   │      │      </p><p>   │      ├─第2章操作系统</p><p>   │      │      2-1 操作系统_概述.wmv</p><p>   │      │      2-2 进程和线程.wmv</p><p>   │      │      2-3 存储和寻址.wmv</p><p>   │      │      2-4 操作系统_例题.wmv</p><p>   │      │      </p><p>   │      ├─第3章网络</p><p>   │      │      3-1 网络基础.wmv</p><p>   │      │      3-2 滑动窗口问题.wmv</p><p>   │      │      3-3 网络抓包演示.wmv</p><p>   │      │      3-4 网络例题.wmv</p><p>   │      │      </p><p>   │      ├─第4章数据库</p><p>   │      │      4-1 数据库_概述.wmv</p><p>   │      │      4-2 JOIN和GROUP BY.wmv</p><p>   │      │      4-3 事务和乐观锁.wmv</p><p>   │      │      4-4 数据库例题.wmv</p><p>   │      │      </p><p>   │      ├─第5章程序设计语言基础</p><p>   │      │      5-1 程序设计语言基础_归类.wmv</p><p>   │      │      5-2 数据类型、整数和补码.wmv</p><p>   │      │      5-3 浮点数和定点数简述.wmv</p><p>   │      │      5-4 Java数据类型、拆箱和装箱.wmv</p><p>   │      │      </p><p>   │      ├─第7章面向对象</p><p>   │      │      7-1 面向对象_概述.wmv</p><p>   │      │      7-10 面向对象_不可变性.wmv</p><p>   │      │      7-11 泛型（上）.wmv</p><p>   │      │      7-12 泛型（下）.wmv</p><p>   │      │      7-13 虚函数表.wmv</p><p>   │      │      7-14 面向对象_小结.wmv</p><p>   │      │      7-2 面向对象_类与对象.wmv</p><p>   │      │      7-3 对象的特殊函数（上）.wmv</p><p>   │      │      7-4 对象的特殊函数（下）.wmv</p><p>   │      │      7-5 接口与抽象类.wmv</p><p>   │      │      7-6 实现Iterable接口.wmv</p><p>   │      │      7-7 继承.wmv</p><p>   │      │      7-8 封装.wmv</p><p>   │      │      7-9 面向对象_例题.wmv</p><p>   │      │      </p><p>   │      ├─第8章设计模式</p><p>   │      │      8-1 设计模式简介.wmv</p><p>   │      │      8-2 State模式.wmv</p><p>   │      │      8-3 Decorator模式.wmv</p><p>   │      │      8-4 创建对象.wmv</p><p>   │      │      </p><p>   │      └─第9章高级知识点</p><p>   │              9-1 高级知识点.wmv</p><p>   │              9-2 外部排序分析.wmv</p><p>   │              9-3 死锁分析.wmv</p><p>   │              9-4 线程池介绍.wmv</p><p>   │              9-5 线程池_Java Excutor Framework演示（上）.wmv</p><p>   │              9-6 线程池_Java Excutor Framework演示（下）.wmv</p><p>   │              9-7 资源管理.wmv</p><p>   │              </p><p>   ├─Java</p><p>   │      Java Concurrency in Practice.pdf</p><p>   │      Java 编程思想 第四版.pdf</p><p>   │      Thinking in Java 4th Edition.pdf</p><p>   │      分布式 Java 应用基础与实践.pdf</p><p>   │      深入理解 Java 虚拟机 2.pdf</p><p>   │      精通Spring 4.x 企业应用开发实战.pdf</p><p>   │      </p><p>   ├─Middleware</p><p>   │      Kafka权威指南.epub</p><p>   │      RabbitMQ 实战指南.pdf</p><p>   │      </p><p>   ├─OOP</p><p>   │      head first design patterns.pdf</p><p>   │      Head First 设计模式.pdf</p><p>   │      深入浅出面向对象分析与设计.扫描版.pdf</p><p>   │      </p><p>   ├─Operating System</p><p>   │      Modern Operating Systems.pdf</p><p>   │      深入理解计算机系统 第三版.pdf</p><p>   │      </p><p>   ├─Popularization</p><p>   │      编码：隐匿在计算机软硬件背后的语言.pdf</p><p>   │      计算机程序的构造和解释.pdf</p><p>   │      </p><p>   ├─Python</p><p>   │      Flask Web开发：基于Python的Web应用开发实战.pdf</p><p>   │      Python 编程：从入门到实践.pdf</p><p>   │      </p><p>   ├─Software Construction</p><p>   │      人月神话.mobi</p><p>   │      代码大全.epub</p><p>   │      代码大全.pdf</p><p>   │      代码整洁之道.mobi</p><p>   │      程序员的职业素养.pdf</p><p>   │      编写可读代码的艺术.pdf</p><p>   │      重构 改善既有代码的设计.pdf</p><p>   │      </p><p>   ├─Tools</p><p>   │      git-cheat-sheet.pdf</p><p>   │      Pro Git.pdf</p><p>   │      正则表达式必知必会.pdf</p><p>   │      </p><p>   └─Unix-Linux</p><p>           The Linux Command Line.pdf</p><p>           UNIX 环境高级编程.pdf</p><p>           UNIX 网络编程.pdf</p><p>           Unix-Linux 编程实践教程.pdf</p><p>           鸟哥的 Linux 私房菜 基础篇 第四版.pdf</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-24T07:55:29.000Z",
    "deleted_at": null,
    "created_at": "2019-02-19T09:06:15.000Z",
    "updated_at": "2019-02-24T07:55:29.000Z",
    "published_at": "2019-02-24T07:55:29.000Z",
    "first_published_at": "2019-02-19T09:06:45.000Z",
    "word_count": 1371,
    "cover": null,
    "description": "categories: Life&lt;blockquote class=&quot;blockquote-center&quot;&gt;**一些相关的计算机资料，侵删**&lt;/blockquote&gt;&lt;!-- more --&gt;获取下载链接：https://www.fag...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1279918,
    "slug": "num_17",
    "title": "17. Letter Combinations of a Phone Number",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 20,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-21T14:42:32.191Z",
      "updated_at": "2019-02-21T14:42:32.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n初步了解回溯算法<br /><!-- more -->\n## 题目描述\nGiven a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent.<br />A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br />![](https://cdn.nlark.com/yuque/0/2019/png/203310/1550741786400-43de21e8-649b-48d7-afb1-4411d21ae211.png#align=left&display=inline&height=162&linkTarget=_blank&originHeight=162&originWidth=200&size=0&width=200)<br />**Example:**\n**Input: **\"23\"\n**Output:** [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].**Note:**<br />Although the above answer is in lexicographical order, your answer could be in any order you want.\n## 参考代码\n\n```java\nclass Solution {\n    public List<String> letterCombinations(String digits) {\n        if (digits.length() != 0) backtrack(\"\",digits);\n        return output;\n        \n    }\n    Map<String, String> phone = new HashMap<String, String>() {{\n            put(\"2\", \"abc\");\n            put(\"3\", \"def\");\n            put(\"4\", \"ghi\");\n            put(\"5\", \"jkl\");\n            put(\"6\", \"mno\");\n            put(\"7\", \"pqrs\");\n            put(\"8\", \"tuv\");\n            put(\"9\", \"wxyz\");\n        }};\n        \n    List<String> output = new ArrayList<String>();\n    \n    public void backtrack(String combination, String next_digits) {\n        if (next_digits.length() == 0) {\n          //意味着一条分支走到底，譬如 adg\n      output.add(combination);\n    }else {\n      String digit = next_digits.substring(0, 1);\n      String letters = phone.get(digit);\n      for (int i = 0; i < letters.length(); i++) {\n        //分割回溯\n        String letter = phone.get(digit).substring(i, i + 1);\n        backtrack(combination + letter, next_digits.substring(1));\n      }\n    }\n    }\n}\n```\n\n## 思路及总结\n首先题目描述最好还是加上不允许重复，还有就是几个数字对应几个字母组合。。。。<br />回溯是一种通过探索所有潜在候选者来查找所有解决方案的算法。如果候选解决方案变为不是解决方案（或者至少不是最后一个解决方案），则回溯算法通过在前一步骤上进行一些更改（即回溯然后再次尝试）来丢弃它。<br />我怎么感觉更像 DFS 呢。。。。就是递归然后进行组合，回溯可能考虑的是得到 adg，还要回去得到 adh\n## 参考\n[https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution/](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution/)\n",
    "body_draft": "categories: leetcode\n\n---\n![215.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548506060055-118e8488-7b24-4981-8a99-75880675fde5.png#align=left&display=inline&height=411&linkTarget=_blank&name=215.png&originHeight=806&originWidth=1464&size=153252&width=746)<br /><!-- more -->\n## 题目描述\n在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br />**示例 1:**\n**输入:** ```\n[3,2,1,5,6,4] 和\n```\n k = 2\n**输出:** 5**示例 2:**\n**输入:** ```\n[3,2,3,1,2,4,5,5,6] 和\n```\n k = 4\n**输出:** 4**说明:**<br />你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n## 参考代码\n\n```java\nclass Solution {\n   public static int findKthLargest(int[] nums, int k) {\n\t\tPriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n       for(int num :nums) {\n           priorityQueue.add(num);\n           if(priorityQueue.size() > k) {\n               priorityQueue.poll();\n           }\n       }\n       return priorityQueue.peek();\n   }\n}\n```\n\n## 思路及总结\n主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。\n## 参考\n[https://www.kancloud.cn/maliming/leetcode/844880](https://www.kancloud.cn/maliming/leetcode/844880)\n",
    "body_html": "<p>categories: leetcode</p><p><br /></p><hr /><p>初步了解回溯算法</p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img alt=\"\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1550741786400-43de21e8-649b-48d7-afb1-4411d21ae211.png#align=left&amp;display=inline&amp;height=162&amp;linkTarget=_blank&amp;originHeight=162&amp;originWidth=200&amp;size=0&amp;width=200\" style=\"max-width: 600px; width: 200px;\" /></p><p><strong>Example:</strong></p><pre><strong>Input: </strong>&quot;23&quot;\n<strong>Output:</strong> [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</pre><p><strong>Note:</strong></p><p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p><h2 id=\"36967e2c\">参考代码</h2><p><br /></p><pre data-lang=\"java\"><code>class Solution {\n    public List&lt;String&gt; letterCombinations(String digits) {\n        if (digits.length() != 0) backtrack(&quot;&quot;,digits);\n        return output;\n        \n    }\n    Map&lt;String, String&gt; phone = new HashMap&lt;String, String&gt;() {{\n            put(&quot;2&quot;, &quot;abc&quot;);\n            put(&quot;3&quot;, &quot;def&quot;);\n            put(&quot;4&quot;, &quot;ghi&quot;);\n            put(&quot;5&quot;, &quot;jkl&quot;);\n            put(&quot;6&quot;, &quot;mno&quot;);\n            put(&quot;7&quot;, &quot;pqrs&quot;);\n            put(&quot;8&quot;, &quot;tuv&quot;);\n            put(&quot;9&quot;, &quot;wxyz&quot;);\n        }};\n        \n    List&lt;String&gt; output = new ArrayList&lt;String&gt;();\n    \n    public void backtrack(String combination, String next_digits) {\n        if (next_digits.length() == 0) {\n          //意味着一条分支走到底，譬如 adg\n      output.add(combination);\n    }else {\n      String digit = next_digits.substring(0, 1);\n      String letters = phone.get(digit);\n      for (int i = 0; i &lt; letters.length(); i++) {\n        //分割回溯\n        String letter = phone.get(digit).substring(i, i + 1);\n        backtrack(combination + letter, next_digits.substring(1));\n      }\n    }\n    }\n}</code></pre><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p style=\"text-indent: 2em;\">首先题目描述最好还是加上不允许重复，还有就是几个数字对应几个字母组合。。。。</p><p style=\"text-indent: 2em;\">回溯是一种通过探索所有潜在候选者来查找所有解决方案的算法。如果候选解决方案变为不是解决方案（或者至少不是最后一个解决方案），则回溯算法通过在前一步骤上进行一些更改（即回溯然后再次尝试）来丢弃它。</p><p><span class=\"lake-fontsize-11\" style=\"color: #222222;\">我怎么感觉更像 DFS 呢。。。。就是递归然后进行组合，回溯可能考虑的是得到 adg，还要回去得到 adh</span></p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution/\" target=\"_blank\">https://leetcode.com/problems/letter-combinations-of-a-phone-number/solution/</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-21T14:42:32.000Z",
    "deleted_at": null,
    "created_at": "2019-02-21T09:35:44.000Z",
    "updated_at": "2019-02-21T14:42:32.000Z",
    "published_at": "2019-02-21T14:42:32.000Z",
    "first_published_at": "2019-02-21T10:45:29.000Z",
    "word_count": 472,
    "cover": null,
    "description": "categories: leetcode初步了解回溯算法&lt;!-- more --&gt;题目描述Given a string containing digits from 2-9 inclusive, return all possible letter combinations tha...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1279915,
    "slug": "go0s2r",
    "title": "无标题",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 20,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-21T13:24:03.753Z",
      "updated_at": "2019-02-21T13:24:03.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 3,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-12T15:17:14.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 3,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-12T15:17:14.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": null,
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-21T09:34:58.000Z",
    "deleted_at": null,
    "created_at": "2019-02-21T09:34:58.000Z",
    "updated_at": "2019-02-21T09:34:58.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1308363,
    "slug": "kxgzpq",
    "title": "19.Remove Nth Node From End of List",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 21,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-02-28T09:10:32.221Z",
      "updated_at": "2019-02-28T09:10:32.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 3,
        "public_books_count": 1,
        "followers_count": 4,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-02-26T11:15:43.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 3,
      "public_books_count": 1,
      "followers_count": 4,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-02-26T11:15:43.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: leetcode\n\n---\n链表<br /><!-- more -->\n<a name=\"273a27cc\"></a>\n## 题目描述\nGiven a linked list, remove the _n_-th node from the end of list and return its head.<br />**Example:**<br />Given linked list: **1->2->3->4->5**, and **_n_ = 2**.\n\nAfter removing the second node from the end, the linked list becomes **1->2->3->5**.<br />**Note:**<br />Given _n_ will always be valid.<br />**Follow up:**<br />Could you do this in one pass?\n<a name=\"36967e2c\"></a>\n## 参考代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n//Two pass algorithm\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        int length = 0;\n        ListNode first = head;\n        while (first != null) {\n            length++;\n            first = first.next;\n        }\n        length -= n;\n        first = dummy;\n        while (length > 0) {\n            length--;\n            first = first.next;\n        }\n        first.next = first.next.next;\n        return dummy.next;\n    }\n}\n\n//One pass algorithm\npublic ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode first = dummy;\n    ListNode second = dummy;\n    // Advances first pointer so that the gap between first and second is n nodes apart\n    for (int i = 1; i <= n + 1; i++) {\n        first = first.next;\n    }\n    // Move first to the end, maintaining the gap\n    while (first != null) {\n        first = first.next;\n        second = second.next;\n    }\n    second.next = second.next.next;\n    return dummy.next;\n}\n```\n\n<a name=\"d7d37168\"></a>\n## 思路及总结\n不论是两遍算法，还是一遍算法，都用了一个额外空间 dummy，然后返回的是 dummy.next，一遍的算法很灵巧的避过了二遍算法的 n 的定位，\n<a name=\"d17a0f0b\"></a>\n## 参考\n[https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution/](https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution/)\n",
    "body_draft": "categories: leetcode\n\n---\n![215.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1548506060055-118e8488-7b24-4981-8a99-75880675fde5.png#align=left&display=inline&height=411&linkTarget=_blank&name=215.png&originHeight=806&originWidth=1464&size=153252&width=746)<br /><!-- more -->\n## 题目描述\n在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br />**示例 1:**\n**输入:** ```\n[3,2,1,5,6,4] 和\n```\n k = 2\n**输出:** 5**示例 2:**\n**输入:** ```\n[3,2,3,1,2,4,5,5,6] 和\n```\n k = 4\n**输出:** 4**说明:**<br />你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n## 参考代码\n\n```java\nclass Solution {\n   public static int findKthLargest(int[] nums, int k) {\n\t\tPriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n       for(int num :nums) {\n           priorityQueue.add(num);\n           if(priorityQueue.size() > k) {\n               priorityQueue.poll();\n           }\n       }\n       return priorityQueue.peek();\n   }\n}\n```\n\n## 思路及总结\n主要思路就是通过各种方式将数组从大到小有序化（各种排序算法，由大到小更容易判断k的位置），利用优先队列PriorityQueue从大到小排列，想象一个二叉树，在第k个之后的内容没有意义，在添加进去的同时便可以删去，减少了调用add()函数的时间，将所有数添加完毕，处于peek的数既是数组中第k个最大元素。\n## 参考\n[https://www.kancloud.cn/maliming/leetcode/844880](https://www.kancloud.cn/maliming/leetcode/844880)\n",
    "body_html": "<p>categories: leetcode</p><p><br /></p><hr /><p>链表</p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p><p><strong>Example:</strong></p><p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong><em>n</em> = 2</strong>.</p><p><br /></p><p>After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p><p><strong>Note:</strong></p><p>Given <em>n</em> will always be valid.</p><p><strong>Follow up:</strong></p><p>Could you do this in one pass?</p><h2 id=\"36967e2c\">参考代码</h2><pre data-lang=\"java\"><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n//Two pass algorithm\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        int length = 0;\n        ListNode first = head;\n        while (first != null) {\n            length++;\n            first = first.next;\n        }\n        length -= n;\n        first = dummy;\n        while (length &gt; 0) {\n            length--;\n            first = first.next;\n        }\n        first.next = first.next.next;\n        return dummy.next;\n    }\n}\n\n//One pass algorithm\npublic ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode first = dummy;\n    ListNode second = dummy;\n    // Advances first pointer so that the gap between first and second is n nodes apart\n    for (int i = 1; i &lt;= n + 1; i++) {\n        first = first.next;\n    }\n    // Move first to the end, maintaining the gap\n    while (first != null) {\n        first = first.next;\n        second = second.next;\n    }\n    second.next = second.next.next;\n    return dummy.next;\n}</code></pre><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p style=\"text-indent: 2em;\">不论是两遍算法，还是一遍算法，都用了一个额外空间 dummy，然后返回的是 dummy.next，一遍的算法很灵巧的避过了二遍算法的 n 的定位，</p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution/\" target=\"_blank\">https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution/</a></p>",
    "body_lake": "<!doctype lake><p>categories: leetcode</p><p><br /></p><card type=\"block\" name=\"hr\"></card><p>链表<cursor /></p><p>&lt;!-- more --&gt;</p><h2 id=\"273a27cc\">题目描述</h2><p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p><p><strong>Example:</strong></p><p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong><em>n</em> = 2</strong>.</p><p><br /></p><p>After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p><p><strong>Note:</strong></p><p>Given <em>n</em> will always be valid.</p><p><strong>Follow up:</strong></p><p>Could you do this in one pass?</p><h2 id=\"36967e2c\">参考代码</h2><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22java%22%2C%22code%22%3A%22%2F**%5Cn%20*%20Definition%20for%20singly-linked%20list.%5Cn%20*%20public%20class%20ListNode%20%7B%5Cn%20*%20%20%20%20%20int%20val%3B%5Cn%20*%20%20%20%20%20ListNode%20next%3B%5Cn%20*%20%20%20%20%20ListNode(int%20x)%20%7B%20val%20%3D%20x%3B%20%7D%5Cn%20*%20%7D%5Cn%20*%2F%5Cn%2F%2FTwo%20pass%20algorithm%5Cnclass%20Solution%20%7B%5Cn%20%20%20%20public%20ListNode%20removeNthFromEnd(ListNode%20head%2C%20int%20n)%20%7B%5Cn%20%20%20%20%20%20%20%20ListNode%20dummy%20%3D%20new%20ListNode(0)%3B%5Cn%20%20%20%20%20%20%20%20dummy.next%20%3D%20head%3B%5Cn%20%20%20%20%20%20%20%20int%20length%20%3D%200%3B%5Cn%20%20%20%20%20%20%20%20ListNode%20first%20%3D%20head%3B%5Cn%20%20%20%20%20%20%20%20while%20(first%20!%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20length%2B%2B%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20first%20%3D%20first.next%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20length%20-%3D%20n%3B%5Cn%20%20%20%20%20%20%20%20first%20%3D%20dummy%3B%5Cn%20%20%20%20%20%20%20%20while%20(length%20%3E%200)%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20length--%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20first%20%3D%20first.next%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20first.next%20%3D%20first.next.next%3B%5Cn%20%20%20%20%20%20%20%20return%20dummy.next%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2FOne%20pass%20algorithm%5Cnpublic%20ListNode%20removeNthFromEnd(ListNode%20head%2C%20int%20n)%20%7B%5Cn%20%20%20%20ListNode%20dummy%20%3D%20new%20ListNode(0)%3B%5Cn%20%20%20%20dummy.next%20%3D%20head%3B%5Cn%20%20%20%20ListNode%20first%20%3D%20dummy%3B%5Cn%20%20%20%20ListNode%20second%20%3D%20dummy%3B%5Cn%20%20%20%20%2F%2F%20Advances%20first%20pointer%20so%20that%20the%20gap%20between%20first%20and%20second%20is%20n%20nodes%20apart%5Cn%20%20%20%20for%20(int%20i%20%3D%201%3B%20i%20%3C%3D%20n%20%2B%201%3B%20i%2B%2B)%20%7B%5Cn%20%20%20%20%20%20%20%20first%20%3D%20first.next%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%2F%2F%20Move%20first%20to%20the%20end%2C%20maintaining%20the%20gap%5Cn%20%20%20%20while%20(first%20!%3D%20null)%20%7B%5Cn%20%20%20%20%20%20%20%20first%20%3D%20first.next%3B%5Cn%20%20%20%20%20%20%20%20second%20%3D%20second.next%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20second.next%20%3D%20second.next.next%3B%5Cn%20%20%20%20return%20dummy.next%3B%5Cn%7D%22%7D\"></card><p><br /></p><h2 id=\"d7d37168\">思路及总结</h2><p style=\"text-indent: 2em;\">不论是两遍算法，还是一遍算法，都用了一个额外空间 dummy，然后返回的是 dummy.next，一遍的算法很灵巧的避过了二遍算法的 n 的定位，</p><h2 id=\"d17a0f0b\">参考</h2><p><a href=\"https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution/\" target=\"_blank\">https://leetcode.com/problems/remove-nth-node-from-end-of-list/solution/</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-28T09:10:32.000Z",
    "deleted_at": null,
    "created_at": "2019-02-28T06:43:58.000Z",
    "updated_at": "2019-02-28T09:10:32.000Z",
    "published_at": "2019-02-28T09:10:32.000Z",
    "first_published_at": "2019-02-28T06:44:58.000Z",
    "word_count": 325,
    "cover": null,
    "description": "categories: leetcode链表&lt;!-- more --&gt;题目描述Given a linked list, remove the n-th node from the end of list and return its head.Example:Given linke...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1367011,
    "slug": "pq6p97",
    "title": "Vim的资源与使用",
    "book_id": 202371,
    "book": {
      "id": 202371,
      "type": "Book",
      "slug": "boke",
      "name": "博客",
      "user_id": 203310,
      "description": "https://weicc.tk/",
      "creator_id": 203310,
      "public": 1,
      "items_count": 22,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-03-14T07:48:47.392Z",
      "updated_at": "2019-03-14T07:48:47.000Z",
      "created_at": "2019-01-10T10:52:26.000Z",
      "namespace": "tfrain/boke",
      "user": {
        "id": 203310,
        "type": "User",
        "login": "tfrain",
        "name": "Tfrain",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 4,
        "public_books_count": 1,
        "followers_count": 4,
        "following_count": 9,
        "created_at": "2018-11-05T13:52:11.000Z",
        "updated_at": "2019-03-12T12:23:21.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 203310,
    "creator": {
      "id": 203310,
      "type": "User",
      "login": "tfrain",
      "name": "Tfrain",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/203310/1541426100060-5f73f5e0-827f-4cbb-ad92-7f712fd38478.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 4,
      "public_books_count": 1,
      "followers_count": 4,
      "following_count": 9,
      "created_at": "2018-11-05T13:52:11.000Z",
      "updated_at": "2019-03-12T12:23:21.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "categories: Vim\n\n---\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/203310/1552527773485-1da446f7-b006-417b-a4cf-17e9d2d4cfd1.png#align=left&display=inline&height=400&name=image.png&originHeight=400&originWidth=600&size=77022&status=done&width=600)<br /><br /><!-- more -->\n<a name=\"a4d3b02a\"></a>\n## 概述\n毫无疑问，Vim对新手很不友好。但是友好的编辑器通常跟不上程序员进步的速度，谁又不想一劳永逸，一直使用同一种编辑器呢？这显然是一种辩证选择。而选择 Vim 绝对是一个明智的长期投资。Vim 又被称为神的编辑器，前身 vi 是由 BIll Joy 于 1976 年开发，其改进版 Vim 最早于 1991 年由 Bram Moolenaar 开发。关于 Vim 的其他故事，可以参考[编辑器之神 & 神的编辑器](https://upclinux.github.io/intro/07/vim-and-emacs/)1。\n<a name=\"a90ef60c\"></a>\n## Vim 学习资源\n网上有很多乱七八糟的资源，但我感觉写得都不尽如人意。主要还是靠自己去搜索资源，找到最适合自己的学习方式，显然现在我还只是入门，仍旧处于不断学习的状态中。我的学习过程大致如下:\n1. vimtutor\n1. Vim 实用技巧\n1. 笨方法学 Vimscript\n\n关于 Vim 实用技巧，推荐自己看一遍，里面针对问题来提出 Vim 的解决方案，是一个很好的参考资料，可以参考我的写得一篇  [Vim 实用技巧](https://www.yuque.com/tfrain/boke/vim_skill)2，至于[笨方法学Vim](http://learnvimscriptthehardway.onefloweroneworld.com/)[script](http://learnvimscriptthehardway.onefloweroneworld.com/)，目前还没有深入下去，仍旧在学习当中。\n<a name=\"2c0b0f2f\"></a>\n## Vim 应用场景\nVim 作为神的编辑器，自然少不了应用的地方。据我目前认知，大部分需要编辑器的地方，都能发现 Vim的身影，各种主流的 IDE 中 Vim 插件已经有大牛帮你写好了，只需要搜索进行下载就行了，我目前在这几个场景中应用 Vim：\n1. SpaceVim ----模块化的 Vim IDE\n1. Vimium ----Chrome浏览器的扩展程序\n1. IdeaVim ----Idea中内置的插件\n\n[SpaceVim](https://spacevim.org/cn/) 三大主流平台都支持，是我自己轻量级写作和文件管理的工具，一开始用的不舒服，现在也还是不断学习的阶段。[Vimium ](https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb)是程序员的福利，Chrome 和Firefox 浏览器均有其插件，开箱即食。虽然有些按键设计不合理，但总的来说还是有所联系，毕竟这是社区推动、集思广益的。IdeaVim 则需要在 IDEA 中进行下载。我的初步使用，感觉还是有些不够灵活，其中还有一个扩展的 Vim 插件，有机会会去试试。\n<a name=\"601ca1e5\"></a>\n## Vim 熟练使用\n熟练使用 Vim ，首先要学会盲打，[SpeedCoder](www.speedcoder.net) 是个不错的练习网站，学习了部分的 Vim 的知识，就可以通过做大量的练习来锻炼自己了，这显然是个煎熬过程，鉴于自己的学习也比价缓慢，就不过多分析。但是我还是喜欢在日常中去练习使用，而不是根据文档去刻意练习，找到自己需要编辑的地方，一律用 Vim 来编辑。比如写博客，敲代码，做记录等等。<br />虽然我现在还是很水，但是也初步感受到了 Vim 的好处，刚开始的时候时间学习成本非常高，但回报也是巨大的。不知道是真正的效率，还是克服困难、努力得到肯定，使人感到无比强大和酣畅淋漓，反正正如大牛所说，它们会带给你渐渐强烈的快感，但你也向它们献出了自己的灵魂。这时，你只能称它们为神器。\n<a name=\"138a6766\"></a>\n## 注意\n以上内容，都是我个人的观点，欢迎访客提出自己的建议。另外自己显然有很多东西不懂，欢迎大佬给我些指导意见。这篇博客对于初学者来说，内容可能有些繁多，最好每个方向都入门，然后慢慢进步吧(我是如此，所以如是建议)，在学习过程中可能还要记一些与 Vim 无关的快捷键，比如在浏览器和 IDEA 中， 但我觉得这是早晚要适应的，克服一下，最终会感谢自己的选择。\n<a name=\"3b61c966\"></a>\n## 引用\n1.[http://os.51cto.com/art/201101/242518.htm](http://os.51cto.com/art/201101/242518.htm)<br />2.[https://www.yuque.com/tfrain/boke/vim_skill](https://www.yuque.com/tfrain/boke/vim_skill)<br />3.[http://learnvimscriptthehardway.onefloweroneworld.com/](http://learnvimscriptthehardway.onefloweroneworld.com/)<br />4.[https://spacevim.org/cn/](https://spacevim.org/cn/)<br />5.[https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb](https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb)<br />6.www.speedcoder.net\n\n",
    "body_draft": "",
    "body_html": "<p>categories: Vim</p><p><br /></p><hr /><p><img alt=\"image.png\" title=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/203310/1552527773485-1da446f7-b006-417b-a4cf-17e9d2d4cfd1.png#align=left&amp;display=inline&amp;height=400&amp;name=image.png&amp;originHeight=400&amp;originWidth=600&amp;size=77022&amp;status=done&amp;width=600\" style=\"max-width: 600px; width: 600px;\" /><br /></p><p>&lt;!-- more --&gt;</p><h2 id=\"a4d3b02a\">概述</h2><p style=\"text-indent: 2em;\">毫无疑问，Vim对新手很不友好。但是友好的编辑器通常跟不上程序员进步的速度，谁又不想一劳永逸，一直使用同一种编辑器呢？这显然是一种辩证选择。而选择 Vim 绝对是一个明智的长期投资。Vim 又被称为神的编辑器，前身 vi 是由 BIll Joy 于 1976 年开发，其改进版 Vim 最早于 1991 年由 Bram Moolenaar 开发。关于 Vim 的其他故事，可以参考<a href=\"https://upclinux.github.io/intro/07/vim-and-emacs/\" target=\"_blank\">编辑器之神 &amp; 神的编辑器</a>1。</p><h2 id=\"a90ef60c\">Vim 学习资源</h2><p style=\"text-indent: 2em;\">网上有很多乱七八糟的资源，但我感觉写得都不尽如人意。主要还是靠自己去搜索资源，找到最适合自己的学习方式，显然现在我还只是入门，仍旧处于不断学习的状态中。我的学习过程大致如下:</p><ol start=\"1\"><li>vimtutor</li><li>Vim 实用技巧</li><li>笨方法学 Vimscript</li></ol><p style=\"text-indent: 2em;\">关于 Vim 实用技巧，推荐自己看一遍，里面针对问题来提出 Vim 的解决方案，是一个很好的参考资料，可以参考我的写得一篇  <a href=\"https://www.yuque.com/tfrain/boke/vim_skill\" target=\"_blank\">Vim 实用技巧</a>2，至于<a href=\"http://learnvimscriptthehardway.onefloweroneworld.com/\" target=\"_blank\">笨方法学Vim</a><a href=\"http://learnvimscriptthehardway.onefloweroneworld.com/\" target=\"_blank\"><span>script</span></a>，目前还没有深入下去，仍旧在学习当中。</p><h2 id=\"2c0b0f2f\">Vim 应用场景</h2><p style=\"text-indent: 2em;\">Vim 作为神的编辑器，自然少不了应用的地方。据我目前认知，大部分需要编辑器的地方，都能发现 Vim的身影，各种主流的 IDE 中 Vim 插件已经有大牛帮你写好了，只需要搜索进行下载就行了，我目前在这几个场景中应用 Vim：</p><ol start=\"1\"><li>SpaceVim ----模块化的 Vim IDE</li><li>Vimium ----Chrome浏览器的扩展程序</li><li>IdeaVim ----Idea中内置的插件</li></ol><p style=\"text-indent: 2em;\"><a href=\"https://spacevim.org/cn/\" target=\"_blank\"><span><span>SpaceVim</span></span></a><span><span> </span>三大主流平台都支持，是我自己轻量级写作和文件管理的工具，一开始用的不舒服，现在也还是不断学习的阶段。<span><a href=\"https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb\" target=\"_blank\">Vimium </a>是程序员的福利，Chrome 和Firefox 浏览器均有其插件，开箱即食。虽然有些按键设计不合理，但总的来说还是有所联系，毕竟这是社区推动、集思广益的。<span>IdeaVim 则需要在 IDEA 中进行下载。我的初步使用，感觉还是有些不够灵活，其中还有一个扩展的 Vim 插件，有机会会去试试。</span></span></span></p><h2 id=\"601ca1e5\">Vim 熟练使用</h2><p style=\"text-indent: 2em;\">熟练使用 Vim ，首先要学会盲打，<a href=\"www.speedcoder.net\" target=\"_blank\">SpeedCoder</a> 是个不错的练习网站，学习了部分的 Vim 的知识，就可以通过做大量的练习来锻炼自己了，这显然是个煎熬过程，鉴于自己的学习也比价缓慢，就不过多分析。但是我还是喜欢在日常中去练习使用，而不是根据文档去刻意练习，找到自己需要编辑的地方，一律用 Vim 来编辑。比如写博客，敲代码，做记录等等。</p><p style=\"text-indent: 2em;\">虽然<span>我现在</span>还是很水，但是也初步感受到了 Vim 的好处，刚开始的时候时间学习成本非常高，但回报也是巨大的。不知道是真正的效率，<span>还是克服困难、努力得到肯定，</span>使人感到无比强大和酣畅淋漓，反正正如大牛所说，它们会带给你渐渐强烈的快感，但你也向它们献出了自己的灵魂。这时，你只能称它们为神器。</p><h2 id=\"138a6766\">注意</h2><p style=\"text-indent: 2em;\">以上内容，都是我个人的观点，欢迎访客提出自己的建议。另外自己<span>显然</span>有很多东西不懂，欢迎大佬给我些指导意见。这篇博客对于初学者来说，内容可能有些繁多，最好每个方向都入门，然后慢慢进步吧(我是如此，所以如是建议)，在学习过程中<span>可能</span>还要记一些与 Vim 无关的快捷键，比如在浏览器和 IDEA 中， 但我觉得这是早晚要适应的，克服一下，最终会感谢自己的选择。</p><h2 id=\"3b61c966\">引用</h2><p>1.<a href=\"http://os.51cto.com/art/201101/242518.htm\" target=\"_blank\">http://os.51cto.com/art/201101/242518.htm</a></p><p>2.<a href=\"https://www.yuque.com/tfrain/boke/vim_skill\" target=\"_blank\">https://www.yuque.com/tfrain/boke/vim_skill</a></p><p>3.<a href=\"http://learnvimscriptthehardway.onefloweroneworld.com/\" target=\"_blank\">http://learnvimscriptthehardway.onefloweroneworld.com/</a></p><p>4.<a href=\"https://spacevim.org/cn/\" target=\"_blank\">https://spacevim.org/cn/</a></p><p>5.<a href=\"https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb\" target=\"_blank\">https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb</a></p><p>6.www.speedcoder.net</p><p><br /></p>",
    "body_lake": "<!doctype lake><p>categories: Vim</p><p><br /></p><card type=\"block\" name=\"hr\"></card><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F203310%2F1552527773485-1da446f7-b006-417b-a4cf-17e9d2d4cfd1.png%22%2C%22originWidth%22%3A600%2C%22originHeight%22%3A400%2C%22name%22%3A%22image.png%22%2C%22size%22%3A77022%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A600%2C%22height%22%3A400%7D\"></card><br /></p><p>&lt;!-- more --&gt;</p><h2 id=\"a4d3b02a\">概述</h2><p style=\"text-indent: 2em;\">毫无疑问，Vim对新手很不友好。但是友好的编辑器通常跟不上程序员进步的速度，谁又不想一劳永逸，一直使用同一种编辑器呢？这显然是一种辩证选择。而选择 Vim 绝对是一个明智的长期投资。Vim 又被称为神的编辑器，前身 vi 是由 BIll Joy 于 1976 年开发，其改进版 Vim 最早于 1991 年由 Bram Moolenaar 开发。关于 Vim 的其他故事，可以参考<a href=\"https://upclinux.github.io/intro/07/vim-and-emacs/\" target=\"_blank\">编辑器之神 &amp; 神的编辑器</a>1。</p><h2 id=\"a90ef60c\">Vim 学习资源</h2><p style=\"text-indent: 2em;\">网上有很多乱七八糟的资源，但我感觉写得都不尽如人意。主要还是靠自己去搜索资源，找到最适合自己的学习方式，显然现在我还只是入门，仍旧处于不断学习的状态中。我的学习过程大致如下:</p><ol start=\"1\"><li>vimtutor</li><li>Vim 实用技巧</li><li>笨方法学 Vimscript</li></ol><p style=\"text-indent: 2em;\">关于 Vim 实用技巧，推荐自己看一遍，里面针对问题来提出 Vim 的解决方案，是一个很好的参考资料，可以参考我的写得一篇  <a href=\"https://www.yuque.com/tfrain/boke/vim_skill\" target=\"_blank\">Vim 实用技巧</a>2，至于<a href=\"http://learnvimscriptthehardway.onefloweroneworld.com/\" target=\"_blank\">笨方法学Vim</a><a href=\"http://learnvimscriptthehardway.onefloweroneworld.com/\" target=\"_blank\"><span>script</span></a>，目前还没有深入下去，仍旧在学习当中。</p><h2 id=\"2c0b0f2f\">Vim 应用场景</h2><p style=\"text-indent: 2em;\">Vim 作为神的编辑器，自然少不了应用的地方。据我目前认知，大部分需要编辑器的地方，都能发现 Vim的身影，各种主流的 IDE 中 Vim 插件已经有大牛帮你写好了，只需要搜索进行下载就行了，我目前在这几个场景中应用 Vim：</p><ol start=\"1\"><li>SpaceVim ----模块化的 Vim IDE</li><li>Vimium ----Chrome浏览器的扩展程序</li><li>IdeaVim ----Idea中内置的插件</li></ol><p style=\"text-indent: 2em;\"><a href=\"https://spacevim.org/cn/\" target=\"_blank\"><span><span>SpaceVim</span></span></a><span><span> </span>三大主流平台都支持，是我自己轻量级写作和文件管理的工具，一开始用的不舒服，现在也还是不断学习的阶段。<span><a href=\"https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb\" target=\"_blank\">Vimium </a>是程序员的福利，Chrome 和Firefox 浏览器均有其插件，开箱即食。虽然有些按键设计不合理，但总的来说还是有所联系，毕竟这是社区推动、集思广益的。<span>IdeaVim 则需要在 IDEA 中进行下载。我的初步使用，感觉还是有些不够灵活，其中还有一个扩展的 Vim 插件，有机会会去试试。</span></span></span></p><h2 id=\"601ca1e5\">Vim 熟练使用</h2><p style=\"text-indent: 2em;\">熟练使用 Vim ，首先要学会盲打，<a href=\"www.speedcoder.net\" target=\"_blank\">SpeedCoder</a> 是个不错的练习网站，学习了部分的 Vim 的知识，就可以通过做大量的练习来锻炼自己了，这显然是个煎熬过程，鉴于自己的学习也比价缓慢，就不过多分析。但是我还是喜欢在日常中去练习使用，而不是根据文档去刻意练习，找到自己需要编辑的地方，一律用 Vim 来编辑。比如写博客，敲代码，做记录等等。</p><p style=\"text-indent: 2em;\">虽然<span>我现在</span>还是很水，但是也初步感受到了 Vim 的好处，刚开始的时候时间学习成本非常高，但回报也是巨大的。不知道是真正的效率，<span>还是克服困难、努力得到肯定，</span>使人感到无比强大和酣畅淋漓，反正正如大牛所说，它们会带给你渐渐强烈的快感，但你也向它们献出了自己的灵魂。这时，你只能称它们为神器。</p><h2 id=\"138a6766\">注意</h2><p style=\"text-indent: 2em;\">以上内容，都是我个人的观点，欢迎访客提出自己的建议。另外自己<span>显然</span>有很多东西不懂，欢迎大佬给我些指导意见。这篇博客对于初学者来说，内容可能有些繁多，最好每个方向都入门，然后慢慢进步吧(我是如此，所以如是建议)，在学习过程中<span>可能</span>还要记一些与 Vim 无关的快捷键，比如在浏览器和 IDEA 中， 但我觉得这是早晚要适应的，克服一下，最终会感谢自己的选择。</p><h2 id=\"3b61c966\">引用</h2><p>1.<a href=\"http://os.51cto.com/art/201101/242518.htm\" target=\"_blank\">http://os.51cto.com/art/201101/242518.htm</a></p><p>2.<a href=\"https://www.yuque.com/tfrain/boke/vim_skill\" target=\"_blank\">https://www.yuque.com/tfrain/boke/vim_skill</a></p><p>3.<a href=\"http://learnvimscriptthehardway.onefloweroneworld.com/\" target=\"_blank\">http://learnvimscriptthehardway.onefloweroneworld.com/</a></p><p>4.<a href=\"https://spacevim.org/cn/\" target=\"_blank\">https://spacevim.org/cn/</a></p><p>5.<a href=\"https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb\" target=\"_blank\">https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb</a></p><p>6.www.speedcoder.net<cursor /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-03-14T07:48:47.000Z",
    "deleted_at": null,
    "created_at": "2019-03-13T15:17:19.000Z",
    "updated_at": "2019-03-14T07:48:47.000Z",
    "published_at": "2019-03-14T07:48:47.000Z",
    "first_published_at": "2019-03-13T15:18:22.000Z",
    "word_count": 1048,
    "cover": null,
    "description": "categories: Vim&lt;!-- more --&gt;概述毫无疑问，Vim对新手很不友好。但是友好的编辑器通常跟不上程序员进步的速度，谁又不想一劳永逸，一直使用同一种编辑器呢？这显然是一种辩证选择。而选择 Vim 绝对是一个明智的长期投资。Vim 又被称为神的编辑器，前身 vi ...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  }
]