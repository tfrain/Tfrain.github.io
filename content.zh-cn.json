{"pages":[{"title":"关于","text":"支持我Buy Programmers Career a Coffee. ko-fi.com/programmerscareer - Ko-fi ❤️ Where creators get support from fans through donations, memberships, shop sales and more! The original ‘Buy Me a Coffee’ Page. 一些信息 Backend: Golang Writing: Programmer’s Career – Medium Github、X and so on: WesleyWei","link":"/zh-cn/about/"},{"title":"归档","text":"","link":"/zh-cn/archives/"},{"title":"分类","text":"","link":"/zh-cn/categories/"},{"title":"标签","text":"","link":"/zh-cn/tags/"}],"posts":[{"title":"Kafka 面试：Kafka 发送消息是如何保证可靠性的？","text":"你曾被提过类似的问题在面试中问过吗？或者将来会遇到，让我们一起探索和掌握它！ 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题: 1.1 如何理解 Kafka 工作原理？Apache Kafka 是 LinkedIn 开源并后来捐赠给 Apache Software Foundation 的实时数据处理软件平台。其目标是为处理实时数据流提供一个统一、高吞吐量、低延迟的平台。它使用 Scala 和 Java 编写。 Kafka 生态系统包括生产者、消费者、主题、Brokers 和 ZooKeeper： 生产者：生产者是将原始消息推送到 Kafka Brokers 的组件。生产者可以将消息发送到特定主题或者让 Kafka 进行路由和负载平衡。 Brokers：Kafka Brokers 是系统的核心部分；它们接收生产者发来的消息，分配偏移量并提交消息到磁盘上的存储。 消费者：消费者从Brokers读取。然而，与传统的消息系统不同，消费者从Brokers拉取消息。 主题和分区：主题是特定类别的消息流。Kafka 主题分割成多个分区，其中包含记录的顺序不可更改的列表。分区允许并行化主题，并将数据分割到多个节点上。 ZooKeeper：ZooKeeper 管理和协调 Kafka 集群。ZooKeeper 服务用于维护名称和配置数据，并提供灵活和可靠的同步功能。 Kafka 的工作原理类似于传递系统。例如，想象一下邮递员（生产者）向特定邮件盒（主题）投递信件（消息）。邮件局（Kafka）排序和维护这些信件，最后，居民（消费者）从邮件盒中提取他们的邮件。 主题： 1.2 Kafka 生产者Kafka 生产者是负责向 Kafka 主题发布数据（称为记录）的组件。生产者是为了向 Kafka Brokers提供数据的关键组件。 下面是 Kafka 生产者的工作原理： 创建生产者：生产者使用特定的属性创建，例如Brokers的地址、键序列化器和值序列化器。Brokers使用这些属性来识别正确的主题并了解如何解析消息。 写数据：创建生产者后，它可以开始发送记录到指定主题。Kafka 记录包含一个键和一个值。这些是字节数组。键是可选的，用于确定特定分区的主题，其中消息将被写入。如果键不存在，Kafka 使用轮询方法写入分区。 分区：生产者发布数据到不同的分区，可以采用轮询方法或者语义上的有意义方法。当键为 null 时，数据将按轮询方式写入分区。如果键存在，所有具有该键的消息都将写入同一分区（如果分区数量不变）。 序列化：Kafka 消息是字节数组。因此，无论数据格式如何，您必须将其转换为字节，以发送到 Kafka。我们称这个过程为序列化。因此，每次发送记录时，生产者必须将对象转换为字节。 确认和重试：在分布式系统中，机器会失败。Kafka 提供了确认和重试的机制。Kafka 可以设置为在写入领导者（ack=1）、所有追随者（ack=all）或者不确认（ack=0）时进行确认。 从生产者配置中可以看出，我们可以通过调整可靠性和持久性保证来利用有效地事件驱动的系统的深入理解。 主题: 1.3 可靠消息传递 — 基本原理可靠消息传递是任何消息中间件的关键部分。 Kafka 提供了强大的持久性保证和容错性来确保可靠消息传递。 可靠消息传递的基本原理在 Kafka 中主要围绕以下主要概念： 生产者和消息确认：我们已经了解过，生产者向 Kafka Brokers发送消息。这些消息可以以不同的方式进行确认，控制生产者的 acks 属性。该确认级别影响消息的持久性。一个 ack 的值为 ‘1’ 表示已成功写入主题的领导者日志。一个 ack 的值为 ‘all’ 表示已成功写入所有同步复制的日志。 复制和同步复制：复制是确保消息持久性的关键特性。每个 Kafka 分区都有多个复制，其中一个被选为领导者。所有的写入和读取都通过领导者进行。其他是追随者，其主要任务是复制领导者。只有在所有的同步复制中写入消息时，消息才被认为已提交并成功写入。 消费者偏移量和传递语义：消费者从 Kafka 主题中读取消息并在其偏移量上进行跟踪，以存储消息的偏移量。Kafka 提供三种传递语义：至多一次、至少一次和精确一次。通过正确地存储和管理偏移量，Kafka 确保消息至少被传递一次。 提交和未提交的消息：在 Kafka 中，消息被认为已提交，当它们成功地写入所有同步复制的日志时。消息可以写入日志，但是消费者不能消费它们，直到它们被提交，保护数据一致性和部分数据在故障发生时。 中文翻译: 主题: 1.4 Kafka Brokers和主题复制Kafka Brokers是系统的核心部分，处理生产者发送的消息，分配偏移量并将消息持久化到磁盘上。现在，让我们深入了解。 Kafka 集群由多个Brokers组成。每个Brokers可以处理来自多个客户端的数据和请求，因为主题分区并分布在多个Brokers实例上。 主题复制: Kafka 的复制是可靠性和容错性的关键特性。每个主题可以有多个复制，允许在多个Brokers上存储。这意味着即使Brokers出现故障，主题数据仍然可以从其他Brokers处获取。 复制的主题分区被分布到集群中的多个Brokers上。具有复制的主题提供了 Kafka 的容错性。 Leader 和 Follower: 对于分区，一个复制会成为 Leader，其他的会成为 Follower。领导者处理分区的读取和写入请求，而追随者以被动的方式复制领导者。如果领导者出现故障，其中一个追随者将自动成为新的领导者。 同步复制(ISR): 如果追随者超出领导者的范围（配置可变），领导者将从 ISR（同步复制）列表中删除追随者。只有 ISR 列表中的成员才能被选为领导者。 复制和可靠性: Brokers在主题复制的角色和功能是关键的，为 Kafka 提供的数据传递语义。读取和写入Brokers确保记录的持久性，并且Brokers的故障不会影响数据的完整性。 主题: 1.5 Kafka 消费者的进入和出口Kafka 消费者是读取和处理数据的应用程序。消费者的角色和功能是关键的，为 Kafka 提供了可靠性和容错性。 下面是 Kafka 消费者的一些关键方面： 消费者组: 多个消费者可以组成一个“消费者组”。作为组的一部分，他们共享消费负载，每个消费者读取主题的分区。这为 Kafka 提供了负载平衡和容错性的特性。 消费消息: 消费者读取主题并处理它们。他们维护下一条消息的偏移量。 偏移量和消费者位置: 每个消费者组维护其偏移量或位置——记录哪些消息已被消费。如果消费者成功处理了一条消息，则偏移量将进一步。因此，即使消费者崩溃，它也可以从其离开的地方继续，增加了系统的容错性和坚持性。 重平衡: 当消费者停止或新消费者加入 Kafka 消费者组时，重平衡协议被初始化。该协议确保消费者优雅地离开，而新消费者加入平滑地，不会影响消费者组内的消息消费过程。 传递语义: 根据消费者如何管理偏移量和提交，Kafka 提供三种传递语义——至多一次、至少一次和精确一次。正确地设计消费者应用程序是关键的，以确保它们能够正确地处理这些语义。 在 Kafka 数据流中，消费者起着重要的角色，驱动实时处理系统。深入了解 Kafka 消费者是关键的，以利用 Kafka 的全部潜力来构建健壮和可扩展的数据处理系统。 主题: 1.6 Kafka 如何可靠传递消息Kafka 的主要责任是可靠地传递生产者（写数据）发送的记录到消费者（读数据）。下面是 Kafka 如何确保可靠消息传递的细节： 复制和冗余性: Kafka 通过主题复制功能确保消息持久性。Kafka 主题被分割成分区，并且每个分区可以在多个节点上复制，称为伺服器。这意味着同一条消息可以存在多个地方，提供了高级冗余性。 Leader 和 Follower: 对于每个 Kafka 分区，伺服器可以在两种角色中选择：领导者和追随者。所有的读取和写入都由领导者处理，而追随者以被动的方式复制领导者。如果领导者出现故障，则追随者可以替代并为消费者提供业务持续性。 确认(ACKs): ACKs 起着重要的作用。当生产者发送消息时，它可以选择在写入领导者的日志中收到确认（acks=1），或者在写入所有同步复制中收到确认（acks=all）。这种选择会贡献到性能和坚持性的权衡。 同步复制(ISRs): Kafka 强制要求只有处于同步状态的复制才能被选为领导者。ISR 是一个复制，它已经完全抓住了分区领导者，并且没有超过指定时间内领导者日志的延迟。确保领导者总是来自 ISR 给 Kafka 提供了强一致性，因为它保证了写入到领导者并确认的消息不会丢失，只要故障数量在复制因子内。 消费者偏移量: Kafka 消费者维护其偏移量（读取位置）。即使消费者出现故障，它也可以从它保存的偏移量中恢复读取消息，从而最小化数据丢失。 总结一下，Kafka 确保可靠地传递消息通过分割数据并复制到多个节点以提供冗余性，确认，维护 ISR 列表以提供一致性，并利用偏移量进行有效的消费。 主题：1.7 Kafka 可靠性最佳实践Kafka 集群的可靠性主要取决于管理和相关的传递实践。下面是 Kafka 的可靠性最佳实践： 监控你的集群：保持关注你的 Kafka 集群。这包括追踪各种指标，例如未提交的消息数量、进入和从每个节点传出的数据率、主题和分区数量，以及未复制的分区数量。监控可帮助您识别潜在的问题并在严重程度上进行预防。 合理的保留期：请记，增加保留期会增加存储和堆使用量。根据需要进行平衡，以避免资源限制。 合理的分区数量：在选择分区数量时，请谨慎考虑。虽然更多的分区允许更好的并行性，但它也意味着更多的打开的服务器连接和更高的 ZooKeeper 负载。 合理的复制因子：高复制因子提高了冗余性和可靠性，但它也会增加存储要求。根据所需的冗余程度进行配置。 合理的确认策略：根据应用程序要求使用正确的确认策略（‘acks’）。对于关键数据，请考虑使用 ‘acks=all’，以确保数据在所有同步复制中都被确认。 **有效的 In-Sync Replicas (ISRs)**：配置 ISR 设置以确保您有正确的平衡，以便保持适当的延迟和持久性保证。请确保 min.insync.replicas 根据需要进行设置，以避免在故障期间丢失数据。 消费者偏移管理：请确保消费者定期提交其偏移量。这可帮助避免在故障期间重新广播大量数据。但请勿提交过于频繁，因为每次提交都是对 ZooKeeper 的调用。 总之，在 Kafka 中实现可靠的传递需要一个平衡，其中包括操作要求、资源使用和应用程序特定要求。 主题：1.8 Kafka 的消息传递语义在 Kafka 中，消息传递语义决定了生产者如何将消息传递给消费者。Kafka 提供三种消息传递语义： 1. At Most Once：在这种情况下，消息被传递至多一次给消费者。这意味着消息可能会丢失，但它们不会被重新传递或重复。这是最快的，因为它涉及最少的生产者和 Kafka 之间的协调。然而，它不是最可靠的方法，因为任何在 Kafka 发送消息和消费者读取它之间的故障都会导致消息的丢失。 2. At Least Once：消息被传递至少一次给消费者。但是，在某些情况下，消息可能会重复，这可能会导致问题。这种方法更可靠，因为它确保消息不会丢失。然而，它有重复消息的风险，因为可能会重新传递。对于幂等处理，这可能是完全可以的。 3. Exactly Once：这确保每个消息被传递恰好一次——无损失，无重复。然而，它是最慢和最资源密集的选择，因为需要事务来跟踪进度。这通常用于关键系统，其中消息的丢失或重复可能会导致重大问题。 这些传递语义决定了你的 Kafka 基于应用程序的系统的坚持和可靠性。选择速度、一致性和可靠性取决于应用程序的使用情况。 主题：1.9 回顾和评估我们已经详细介绍了 Kafka 课程的许多方面，让我们来做一个简短的回顾： Kafka 是如何工作的：我们学习了各种 Kafka 组件如何相互作用以提供一个可靠、可伸缩和容错的消息系统。 Kafka 生产者：我们深入探讨了 Kafka 生产者如何发送消息并了解了其关键配置。 可靠消息传递的基本概念：我们了解了确保消息持久性和可靠性在 Kafka 中的基本概念。 Kafka 节点和主题复制：我们深入探讨了 Kafka 节点的工作原理并了解了主题复制如何增加可靠性。 Kafka 消费者：我们探索了 Kafka 消费者和消费者组的复杂性并确定了其角色在保持可靠性方面的重要性。 Kafka 如何可靠地发送消息：我们剖析了 Kafka 内部机制，用于确保可靠的消息传递。 Kafka 的可靠消息传递最佳实践：我们讨论了优化 Kafka 的消息传递以增加可靠性的具体方法。 Kafka 的消息传递语义：最后，我们看了三种类型的传递语义，它们的重要性和使用场景。 现在，是时候评估你的了解和应用了。我们可以进行一些练习问题和分析真实世界中广泛使用的 Kafka 场景，以帮助固定你所学的知识并帮助你更好地将 Kafka 集成到你的系统中。 例题：列出并解释 Kafka 中的三种不同的传递语义？ 解决方案： At Most Once：在这种情况下，消息被传递至多一次，这意味着消息可能会丢失，但它们不会被重新传递或重复。这是最快的，但是，它不是最可靠的方法，因为任何在 Kafka 发送消息和消费者读取它之间的故障都会导致消息的丢失。 At Least Once：消息被传递至少一次，这意味着消息是确保传递的，但是，在某些情况下，消息可能会重复，这可能会导致问题。这种方法更可靠，但是，重复可能会成为问题。 Exactly Once：在这种情况下，消息被传递恰好一次——无损失，无重复。然而，它是最慢和最资源密集的选择，因为需要事务来跟踪进度。这通常用于关键系统，其中消息的丢失或重复可能会导致重大问题。 问题1Kafka 集群中 Kafka 生产者的角色是什么？ 问题2请解释 Kafka 中主题复制的概念。为什么它是重要的？ 问题3请介绍 Kafka 中的 In-Sync Replicas (ISRs)。 问题4请提供可靠消息传递在 Kafka 中的一些最佳实践。 问题5请说明 Kafka 是如何保证可靠消息传递的？ 答案1Kafka 集群中的 Kafka 生产者的角色是发布数据或消息到一个或多个 Kafka 主题。生产者发送的消息会被追加到提交日志的末尾并分配一个唯一的偏移号码。 答案2Kafka 主题复制是 Kafka 中的一个特性，用于确保集群中的消息在某些 Kafka 节点（由于故或维护而不可用）不可用时仍然可用。每个主题可以在配置的节点数量上复制。这有助于确保没有消息丢失并提供高数据可用性。 答案3In-Sync Replicas (ISRs) 是与领导者同步的复制集。任何超过某个配置时间未向领导者发送获取请求的复制集成 ISR 集合。如果复制集未能从领导者获取，它将从 ISR 集合中删除并不会被认为是为客户端生产数据的候选者。 答案 4在 Kafka 中可靠消息传递的一些最佳实践包括根据使用场景选择正确的消息传递语义，遵循最小权限原则进行权限管理，为长期主题使用压缩，监控并设置警报关键指标，保持 Kafka 集群和客户端库的更新，等等。 答案 5Kafka 保证可靠消息传递通过多种机制来实现，例如复制、In-Sync Replicas (ISRs)、确认和配置可靠性语义。生产者会等待来自全部 In-Sync Replicas 的确认，直到消息被写入。如果消息写入失败，生产者会自动重试。消费者会维护一个偏移量来跟进每个主题的进度。 English post: https://programmerscareer.com/kafka-interview1/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/kafka-interview1/"},{"title":"MySQL面试:简要介绍MySQL的主从同步机制","text":"让我们构建MySQL的主/从同步机制课程，并了解如果同步失败会发生什么 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题:1.1 数据库同步简介 数据库同步是数据库世界中的一个关键概念。跨多个平台、数据库或系统维护准确、一致的数据的复杂性一直是一个挑战。这就是数据库同步的亮点所在。 当我们谈论数据库同步时，我们指的是确保两个或多个数据库中的数据是一致的过程。这通常意味着所有数据库中的数据应该是相同的，以反映任何数据库中的所有更新。例如，在银行系统中，客户的账户余额应该是相同的，无论是在网上、在自动取款机上还是在分行检查。如果客户在分行取款，这应该立即反映在网上和自动取款机上看到的余额上。这种实时准确性是通过所涉及的各种数据库的同步来实现的。 同步的一些主要好处包括: 数据一致性:数据库同步确保数据在所有平台上保持一致。这在金融和医疗保健等许多行业至关重要，因为这些行业的数据准确性至关重要。 效率:通过确保一个数据库中的变化反映在所有其他数据库中，同步有助于使系统更高效，数据更可靠。冗余减少了，用户总是可以访问最新的数据，无论他们从哪里访问数据。 可扩展性:随着系统规模的增长，其数据也在增长。数据库同步允许随着数据输入的增加而轻松扩展数据库。可以同步多个服务器来处理更多数据，从而提高系统的整体性能。 备份:同步可以作为数据备份的一种形式。如果一台服务器宕机，数据不会丢失，因为它镜像在另一台服务器上。这提高了数据可靠性和系统耐久性。在课程的下一部分中，我们将仔细研究数据库系统中的主要和次要体系结构模型，包括MySQL。请继续关注! 主题:1.2理解主/次体系结构 在许多数据库系统中，特别是在MySQL中，一种流行的结构是主/从体系结构，也称为主/从体系结构。 在深入研究体系结构细节之前，让我们简要讨论一下每个组件代表什么。 Primary Database (Master Database):原始数据库或主数据库。此处所做的任何更改或更新也会反映在辅助数据库中。主数据库通常处于读写模式，并且通常是大多数应用程序操作发生的地方。 Secondary Database (Slave Database):这些是主数据库的副本。辅助数据库的存在通常是为了增强可靠性、数据恢复和负载平衡。它们复制主数据库中的数据，虽然有些应用程序允许双向同步(其中一个数据库上的更新反映在另一个数据库上)，但许多辅助数据库是只读的。 在MySQL环境中，主数据库以二进制日志(binlog)记录对其执行的更新。该日志作为所有更改的书面历史记录，可用于将这些更改复制到辅助数据库。很酷，对吧? 在主服务器上执行事件或事务时，辅助服务器上不会立即发生任何事情。相反，事件首先被写入主服务器上的二进制日志。 辅助服务器有一个名为I/O Thread的组件，它连接到主服务器，并几乎立即将二进制日志事件复制到中继日志中。 另一个名为SQL线程的组件从中继日志中读取事件，并将其应用到辅助服务器。这样，在辅助服务器上以相同的顺序执行相同的事件，因此，两个服务器上的数据是一致的。 该模型提供了备份供应、分析性能、读取可伸缩性和高可用性等优点。但是，它需要仔细管理以确保数据一致性并避免冲突。 在接下来的课程模块中，我们将深入研究此同步机制的其他细节以及如何有效地处理潜在问题。 主题: 1.3 MySQL的同步机制 MySQL有一套丰富的机制来确保数据在不同数据库之间保持一致。以下是MySQL同步的关键要素: 1.二进制日志:二进制日志记录对MySQL数据的所有更改。这包括数据更改，如表创建操作或对表数据的更改，以及导致更改的每个语句所花费的时间。这在同步数据方面起着关键作用。 2.复制:复制是MySQL中最流行的功能之一。它允许从一个MySQL数据库服务器(主服务器)复制数据到一个或多个MySQL数据库服务器(辅助服务器)。默认情况下，复制是异步的，这带来了很大的灵活性。但是您也可以选择设置半同步复制。 3.全局事务标识符(gtid): gtid使跟踪事务更容易。当事务发生时，将为其提供一个GTID，该GTID在所有服务器上都是唯一的。gtid的主要好处是支持更简单的自动故障转移和更高的可靠性。 4.组复制:组复制增强MySQL的复制。它提供了对崩溃或无法访问的服务器的内置检测，并可以重新配置组、主要选举和从其他组成员自动分布式恢复，因此业务操作不必停止。 5.InnoDB ReplicaSet:对于不需要高可用性系统的小规模设置，可以部署一种称为InnoDB ReplicaSet的轻量级故障转移管理方法。它提供了易于使用的命令行工具来设置和管理较小规模的复制集。 6.半同步复制:半同步复制提供了一个选项，只有当要复制的数据被发送到另一个副本时，提交才能成功返回到客户端。半同步复制可用于阻止事务，直到副本确认已将事件写入其副本日志，从而防止由于主节点丢失或崩溃而导致的数据丢失。因此，我们可以说半同步复制是同步复制的高持久性和异步复制的低延迟之间的折衷。 MySQL通过这些同步机制实现数据一致性。这些机制确保副本接收主数据库上的更新，从而实现跨预期数据处理管道的数据协调。 接下来，我们将深入研究同步失败的后果以及如何检测和减轻这些事件。 主题: 1.4 同步失败的后果 在任何同步至关重要的系统中，例如MySQL中的主/从设置，同步失败可能导致各种问题。以下是同步失败的一些潜在后果: 1.数据不一致:这是同步失败最直接和最明显的影响之一。例如，在银行应用程序中，您可能在不同的数据库中得到不同的帐户余额值，这可能导致重大的财务影响。 2. 服务中断:如果服务器没有正确同步，依赖于数据库的服务可能面临性能问题甚至完全失败。这可能会破坏应用程序的可用性，并导致糟糕的用户体验。 3. 数据损坏:在最坏的情况下，同步失败甚至可能导致数据损坏。例如，如果两个用户同时修改相同的数据，但这些修改没有正确同步，就会发生这种情况。 了解同步失败的症状与了解同步失败的后果同样重要。症状可能包括日志中的错误或异常数量增加、性能突然下降，或者在比较主数据库和辅助数据库时数据不一致。 缓解策略通常首先通过定期检查数据库运行状况或配置与复制失败相关的特定错误代码警报来检测故障。一旦检测到，需要快速响应以诊断问题的原因并采取纠正措施。 这些纠正操作的性质将取决于特定的问题和数据库的配置，可以是简单的数据库重启，也可以是更剧烈的完全数据重新同步，甚至可以是故障转移到不同的服务器。 现在，我们知道预防问题比解决问题更好。这就引出了我们的下一个主题，即首先防止同步故障发生的最佳实践。 主题:1.5 防止同步失败 防止MySQL数据库同步失败需要仔细规划、监控和应用最佳实践，以确保数据的一致性。以下是实现这一目标的一些重要步骤: 1.定期监视:定期监视数据库的运行状况和性能。这包括监视复制的状态、检查状态和错误日志，以及为各种复制事件设置警报。 2.使用可靠的网络:网络故障可能导致重大的同步问题。因此，请确保主服务器和辅助服务器通过可靠的网络连接。考虑使用冗余网络路径来提高可用性。 3.应用程序中彻底的错误处理:您的应用程序还应该配备良好的设备来处理错误，包括来自数据库的错误。彻底的错误处理可以防止由于应用程序错误而导致同步失败的实例。 4.使用gtid:正如我们前面所讨论的，全局事务标识符(Global Transaction Identifiers, gtid)在防止同步失败方面非常方便，因为它们提供了一种一致的方式来跟踪所有服务器上的每个复制事件。 5.定期备份:定期备份您的数据库。备份是在发生灾难性故障时的最后一道防线。此外，通过在单独的环境中恢复备份来验证备份，以确保它们是好的。 6.测试故障转移场景:在受控条件下定期测试故障转移场景，以了解在实际故障转移场景中可能出现的潜在问题。这有助于在实际中断发生时最小化RTO(恢复时间目标)。 7.使用半同步复制:正如我们在前几课中所讨论的，半同步复制还可以帮助防止“提交成功不一致”。在这种方法中，主服务器等待，直到至少一个辅助服务器接收到更改并将其记录到其中继日志中。 8.保留Binlogs直到所有副本都处理完它们:这可以防止主系统崩溃，然后在复制流的较早点提升备份主系统的问题。 通过应用这些策略，您可以大大减少在MySQL环境中遇到同步失败的机会。 在我们的下一个主题中，我们将继续讨论现实世界的场景，以弥合理论与实践之间的差距。 主题:1.6 同步失败案例分析 为了更好地理解同步失败在现实场景中是如何发生的，让我们使用一个反映实践中可能面临的问题的假设案例: 假设我们有一家科技初创公司，它的移动应用拥有快速增长的用户基础。该公司使用主-从MySQL设置来管理其用户数据。有一天，他们发布了一个新特性，由于用户操作的增加，导致数据库写入量激增。 尽管考虑到应用的成功，这是一个令人高兴的问题，但它导致了一个意想不到的问题:辅助服务器开始落后于主服务器。随着用户操作的增加，辅助服务器处理来自主服务器的二进制日志的延迟导致了这种延迟。这被称为复制延迟。 这是同步MySQL设置中的一个常见问题。在这种情况下，故障不是突然崩溃，而是不断增长的延迟，这通常很难立即检测到。用户开始注意到应用程序体验中的不一致。例如，用户可能删除了一个帖子，但仍然在他们的提要中看到它，因为指向延迟的辅助服务器的读取操作仍然在那里找到了该帖子。 该公司最终通过监控系统发现了这个问题，注意到复制延迟不断增加，并立即采取了行动。他们的答复包括: 扩展他们的数据库设置:他们增加了更多的辅助服务器，并优化了这些服务器之间的读操作分布，以更好地处理负载。 缓冲写:他们为非关键的写操作实现了队列系统，从而减少了数据库的即时负载。 优化他们的应用程序操作:他们发现许多并发读写操作是不必要的，并重新设计了他们的应用程序逻辑来减少这些。 通过这种情况，该公司认识到积极监控数据库设置的健康状况、预测扩展需求和优化应用程序操作以减少不必要的数据库负载的重要性。 在此场景中面临的问题以及为纠正这些问题所采取的步骤是许多实际应用程序的典型问题。从这个案例研究中，我们看到了我们在前几课中谈到的预防和缓解措施的重要性。 在下一节课中，我们将重温和复习我们在课堂上学到的关键概念，通过一些实际作业来加强它们，并通过一些评估来评估你的理解。 主题:1.7 审查和评估 审查让我们回顾一下我们在整个课程中涵盖的关键概念: 数据库同步:我们首先了解数据库同步的需求、它的好处和潜在的挑战。这个概念对于维护跨多个数据库实例的数据一致性至关重要。 主/辅助架构:我们探讨了MySQL中常用的主/辅助架构。此设置允许将数据从主服务器复制到一个或多个辅助服务器。 MySQL中的同步机制:我们深入研究了MySQL用于实现同步的机制，包括二进制日志记录和复制。 同步失败的后果:我们讨论了同步失败的潜在影响，从数据不一致到服务中断，甚至数据损坏。 防止同步故障:我们了解了防止这些故障的各种策略和最佳实践，例如定期监视、gtid和可靠的网络连接。 同步故障案例研究:我们研究了一个真实的场景，以了解此类故障是如何发生的，以及处理它们的步骤。 评估现在，让我们用一些问题来测试你的理解: 为什么在数据库系统中需要同步?具体来说，在小学/中学的设置中? MySQL实现同步的关键机制是什么? 同步失败的潜在后果是什么? 描述一些防止MySQL数据库同步失败的策略。 在我们讨论的案例研究中，公司是如何发现这个问题的?他们是如何应对这种情况的? 请慢慢回答这些问题。你对这些概念的理解比速度更重要。 答案 **1. 为什么在数据库系统中需要同步?具体来说，在主/备的设置中?**。 在数据库系统中，同步对于确保跨多个数据库实例的数据一致性至关重要。在主/辅助设置中，它允许将数据从主服务器复制到一个或多个辅助服务器，以提高性能并提供可靠的冗余数据存储。 **2. MySQL实现同步的关键机制是什么?**。 MySQL通过二进制日志记录和相关的复制技术实现同步。主服务器生成所有数据更改的二进制日志。辅助服务器获取此日志并应用更改，从而实现与主服务器的同步。 **3. 同步失败的潜在后果是什么?**。 其后果可能包括跨服务器的数据不一致、服务中断，在严重的情况下还可能导致数据损坏。这可能导致系统不可靠，并对用户体验产生负面影响。 **4. 描述一些防止MySQL数据库同步失败的策略 预防性策略包括定期监视数据库运行状况和性能、使用可靠的网络连接、在应用程序中进行彻底的错误处理、使用全局事务标识符(Global Transaction Identifiers, gtid)、执行定期备份、测试故障转移场景、半同步复制，以及确保保留二进制日志，直到所有副本都处理完它们。 5. 在我们讨论的案例研究中，公司是如何发现这个问题的?他们是如何应对这种情况的? 该公司通过监控系统发现了这个问题，注意到复制延迟的增加。他们的回应包括通过增加更多的辅助服务器来扩展数据库设置，实现一个队列系统来缓冲写并减少数据库上的即时负载，以及优化他们的应用程序操作以减少不必要的数据库负载。 English post: https://programmerscareer.com/mysql-interview1/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview1/"},{"title":"MySQL 面试：简述 MySQL 的间隙锁","text":"你曾在面试中被要求类似的问题吗？或者将来会遇到，让我们一起探索和掌握它。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：深入探讨 MySQLMySQL 是一个广泛使用的、开源的关系数据库管理系统 (RDBMS)。它使用关系数据库和结构化查询语言 (SQL) 来管理其数据。“My” 在 MySQL 中是 Michael Widenius 的女儿 My 的名字的缩写。 MySQL 数据库是一个稳定、可靠和强大的解决方案，具有高级特性，例如： 坚实事务支持 复制和故障转移集群支持 工作流控制和计划任务 查询缓存 高级复制技术 这使 MySQL 成为应用要求完整数据保护和实时分析的优秀选择，例如财务、银行、电子商务、CRM、ERP 应用等等。 接下来，让我们开始从理论上了解数据库。为了简单起见，让我们想象数据库是一个大的数字文件柜，满载的文件夹。文件夹代表表。在每个表中，包含真实数据，表示记录。每条记录包含有关单个实体的信息。 例如，如果你是一个商业主人，你可能有一个数据库，其中包含一个客户表和一个订单表等等。每行在客户表中代表一个单独的客户，每行在订单表中代表一个单独的订单。 主题：探讨 MySQL 事务事务是数据库系统的基本概念。在 MySQL 中，事务是一组 SQL 语句的执行单元。事务遵循 ACID 模型，即原子性、一致性、隔离性和持久性。这个模型确保了数据库事务的可靠性。 例如，如果你在转账时从一个银行账户转移资金，这需要多个操作，例如从一个账户扣除资金并将其转移到另一个账户。在这种情况下，事务确保这些操作（信用和贷方）全部发生或不发生，确保数据一致性。 我们的下一步是学习 MySQL 中的锁定机制，这与事务密切相关。在数据库的上下文中，锁是与记录相关的标志。这个标志可以控制记录是否可以被读取或写入。 它是锁定使多名用户同时访问数据库时不发生冲突的关键。当记录或表被锁定时，这意味着某个事务正在访问数据，并且不应中断。 中文翻译: 主题：MySQL中锁定的介绍在数据库领域，“锁定”是一个重要的特性，它确保并发数据访问的一致性和顺序。在 MySQL 中，InnoDB 存储引擎支持多种类型的锁定在不同的级别上，以确保事务不会相互干扰。 锁定特别重要在多个事务试图访问和操作同一块数据时。当一个事务锁定某块数据时，它阻止其他事务进行冲突的更改，直到锁定被释放。 MySQL 中有两种主要类型的锁定： **共享锁 (S)**：这是一个只读锁定。多个共享锁可以同时保持对同一块数据，只要没有排他锁。 **排他锁 (X)**：排他锁是一个写锁定。当一个事务持有排他锁时，其他事务不能读取或写入该数据，直到锁定被释放。 在 MySQL 中，锁定可以发生在三个级别上： 行级锁定：这些锁定被放在数据行上。这是锁定的最细粒度，并允许最高的并发性。 页级锁定：这些锁定被放在数据页上。页级锁定比行级锁定更粗糙，并提供中等的并发性。 表级锁定：这些锁定被放在整个表上。这是锁定的最粗糙的，并提供最低的并发性。通常，在高并发环境中，我们希望避免表级锁定，因为它们可能会成为瓶。 了解这些基本锁定的概念后，我们可以深入研究 MySQL 中的更复杂的锁定类型，例如间隙锁。 主题：行锁和表锁在 MySQL 中为了保证数据一致性并允许最高的并发性，MySQL 使用两种类型的锁定：行级锁定和表级锁定。每种类型都有自己的地方和目的。 行级锁定 行级锁定更细粒度，在更新特定行的表时使用。这意味着只锁定涉及操作的行，并不锁定整个表。这允许更高的并发性，其中多个事务可以同时访问不同行的同一表。 InnoDB 支持行级锁定。它会自动设置锁定在读和写操作时，但它不会锁定整个表。 例子：如果您正在更新特定记录的员工表，例如，如果使用这种锁定机制，则只会阻止试图修改该特定员工记录的事务。其他员工记录的任务可以继续进行。 表级锁定 表级锁定更粗糙。它锁定整个表在特定数据库操作时。通常，MySQL 在写操作时应用这种锁定。 虽然这种锁定允许简单的管理和更少的内存使用，但在高并发使用情况下，其并发性较低，因为多个事务需要同时访问同一表。 通过了解这两种类型的锁定，您已经一步 closer 了解了数据库操作的内部工作原理，并且在深入研究更复杂的锁定类型，例如间隙锁，时间戳锁定等方面有所帮助。 中文翻译: 主题：讨论 MySQL 中的间隙锁间隙锁是 MySQL 中一个重要的机制，用于防止幻行。幻行是一种行，它满足 WHERE 子句的条件，但是在事务中未被初始查看或更新。 让我们考虑一种情况，其中我们有一个事务，它选择了特定范围内的行，并且后面要更新这些行。在这个操作期间，另一个事务插入了新行到该范围，创造了我们所称为的“幻行”。如果没有间隙锁，第一个事务不会意识到新行被第二个事务添加，并可能导致数据不一致。 这就是间隙锁的作用！ 间隙锁是锁定索引记录之间的间隙。更具体地说，它是锁定索引记录的范围。在 MySQL 中，间隙锁防止其他事务在间隙被锁定的事务提供可重复读时插入新行。 例如，假设您有一个索引列，并且运行了以下语句在 REPEATABLE READ 隔离级别下： 1SELECT * FROM table_name WHERE index_column &gt; 100 FOR UPDATE; MySQL 会为所有索引记录上锁，其中 index_column 的值大于 100，并为其后的间隙上锁。 请记，然而，间隙锁是双刃剑！虽然它可以确保一致性，但它也可能会引入锁等待或甚至死锁，如果不正确地管理。 主题：间隙锁的例子场景要更好地理解间隙锁，让我们考虑一个例子场景。假设我们有一个表 orders，它有许多行。 场景 1:例如，考虑以下 SQL 语句， 1SELECT * FROM orders WHERE id &gt; 3 FOR UPDATE; 在这个查询中的事务中，MySQL 会为所有记录上锁，其中 id 的值大于 3。这意味着另一事务不能在 orders 表中插入任何新记录，其中 id 的值大于 3，直到第一事务完成。 场景 2:现在考虑另一个 SQL 语句， 1INSERT INTO orders (id, item) VALUES (102, 'New_Item'); 如果我们试图在先前事务（带有 SELECT … FOR UPDATE 语句）仍然处于活动状态时执行此语句，它将被阻止，直到第一事务完成。这是由第一事务所应用的间隙锁所导致的，它不允许任何新记录的插入，其中 id 的值大于 3。 这些例子场景说明了间隙锁如何控制并发事务，确保数据状态的一致性并消除幻读在某些事务隔离级别，例如 REPEATABLE READ 或 SERIALIZABLE 中。 现在，我们可以深入研究 MySQL 中锁定的更复杂的细节。 主题：通过锁的迷宫在 MySQL 中，锁形成了一个复杂的迷宫，每个锁都有重要的作用，但如果不处理正确，可能会导致延迟或死锁。 下面是锁之间的简单交互方式： 共享锁和排他锁： 共享锁允许其他事务读取（共享锁）锁定的对象，但不允许写入（排他锁）。 排他锁阻止其他事务读取/写入锁定的对象。 可以应用额外的共享锁到已锁定的对象上，但请求排他锁将等待。 表锁和行锁： 表锁简单明了，但提供了更低的并发性，可能会导致事务延迟。 行锁提供更高的并发性，因为它们只锁定特定行在表中。 Gap 锁和 Next-Key 锁： Gap 锁阻止插入到特定范围内的索引记录。它们与行锁（或 Next-Key 锁）配合起来防止 REPEATABLE READ 或 SERIALIZABLE 隔离级别中的幻读。 意向锁： 意向锁表明事务计划要获取的锁（共享或排他）之前就已经获取了它。它们是通知机制，不是控制机制。 自增锁： 自增锁用于维护自增值的序列。它们避免了多个事务同时尝试插入到自增列中的冲突。 成功地通过这个迷宫需要对每种锁类型和事务之间的影响有清晰的理解。 主题：复习和评估在过去的课程中，我们深入探讨了 MySQL 和其锁机制。让我们回顾一下这些主题，以确保良好的理解： 深入了解 MySQL：我们开始时，了解了 MySQL 的界面、命令和与其他 SQL 实现的差异，为学习过程奠定了坚实的基础。 探索 MySQL 事务：我们深入探讨了 MySQL 事务的核心概念，讨论了其一致性和隔离级别，确保数据的准确性和并发性。 了解 MySQL 锁：我们介绍了 MySQL 锁的概念，这是维护数据完整性和并发控制的关键。 行锁和表锁：我们探讨了行级锁和表级锁，并讨论了它们在 MySQL 中的重要性。 讨论 MySQL 的Gap 锁：我们深入探讨了 gap 锁，包括它是什么、它是如何工作的和它在 REPEATABLE READ 或 SERIALIZABLE 隔离级别中的重要性。 Gap 锁的示例场景：我们步行了常见的场景，以了解 gap 锁的实际应用。 通过锁的迷宫：我们讨论了 MySQL 中锁之间的交互和影响，这是一个复杂但有趣的主题。 例子问题：考虑一种高流量数据库，您经常遇到死锁。您的任务是识别一个可能的解决方案来最小化这些发生的可能性。 解决方案：可能的解决方案包括缩短事务时间、确保事务访问表的相同顺序或者增加 innodb_lock_wait_timeout 值。还可以确保使用最具体的锁来帮助减少死锁的可能性。 中文翻译： 简单问题：考虑一个事务，它读取和写入表中的多条记录。要确保高流量数据库中的最小阻塞，应该使用哪种锁（行级锁、表级锁或Gap锁），并且避免幻读？ 进阶问题：在票务预订系统中，可能会有多个并发事务试图同时预订同一座位。如何使用 MySQL 的锁机制来确保公平的系统？ 专家问题：在 MySQL 的上下文中，如何处理银行应用中的死锁场景，其中两个事务同时尝试转移两个账户之间的资金？ 简单问题解决方案：对于这种场景，使用行级锁机制将是最有效的。它会提供所需的锁定来确保数据完整性，同时避免高流量情况下不相关行的不必要阻塞。此外，包含“FOR UPDATE”子句在 SELECT 语句中可能会避免幻读。 进阶问题解决方案：在票务预订系统中，要确保公平的系统，我们可以使用 SELECT FOR UPDATE 命令。这会为所遇到的所有索引记录放置排他的 Next-Key 锁，从而防止其他事务在覆盖的记录锁下插入新行。它还会选择座位的当前状态，并如果它可用，则更新其为已预订，确保座位不会被双预订。 专家问题解决方案：在银行应用中，如果两个事务同时尝试转移两个账户之间的资金，我们可能会遇到死锁场景。要处理这种情况，我们可以使用访问帐户的固定顺序。例如，事务可能会先访问具有较低 ID 的帐户。这将防止死锁，因为两个事务不会无限期地等待对方，消除了死锁的循环等待条件。 English post: https://programmerscareer.com/mysql-interview10/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview10/"},{"title":"MySQL 面试：唯一索引与普通索引的区别是什么？使用索引会有哪些优缺点？","text":"让我们深入探讨 MySQL 中的“唯一索引”和 “普通索引”的评论和评估。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：了解 MySQL 中的索引在任何关系数据库管理系统中，如 MySQL，数据的高效访问是关键方面之一，特别是在处理大量数据时。我们所关心的效率是系统如何快速地定位并检索所需的数据。这就是 索引 发挥作用的地方。 你可以将索引比作书的索引。假设你想找到某个特定主题。你有两种选择： 你可以逐页扫描，直到找到主题。 你可以去索引，找到主题的页码，然后直接翻到那一页。 后者更快，是不是？在数据库世界中，逐页扫描被称为 全表扫描。如果你有 millions 行，这可能会花费很长时间。但是如果你有一个索引，MySQL 可以使用它来更快地定位数据——就像你使用书的索引来找到主题一样。 索引创建一个条目，并因此可以更快地检索数据。请记，然而，虽然索引加快了查询，但它们可能会慢下来写操作（INSERT、UPDATE、DELETE）的速度，因为每次写操作都要更新索引。因此，我们需要维持平衡并只在经常搜索的列上使用索引。 主题：MySQL 中的普通索引现在我们对索引有了良好的理解并了解了它在 MySQL 中的角色，让我们来深入探讨一种特定的索引类型，即 普通索引（也称为 非唯一索引）。 普通索引（Non-unique Index）允许你通过数据库表的一个或多个列来加速查询过程。与唯一索引不同，普通索引不会对值的唯一性进行约束。换句话说，普通索引允许在索引列上重复的值。 例如，假设我们有一个 Students 表，其中包含列 ID、Name、Age 和 Address。当我们正在查询数据时，我们通常使用 WHERE 子句来过滤数据。例如： 1`SELECT * FROM Students WHERE Age = 20` 在没有索引的情况下，MySQL 将需要浏览 Students 表的每一行，以找到 Age 等于 20 的行。这可能会耗时且不高效。如果我们为 Age 列创建一个普通索引，MySQL 可以使用这个索引来快速定位相关的行。 在 MySQL 中创建一个普通索引非常简单，你可以使用 CREATE INDEX 命令，然后提供索引的名称、表和列。 下面是如何在 Students 表上为 Age 列创建一个普通索引的例子： 1CREATE INDEX age_index ON Students (Age); 请记，虽然普通索引可能会加快读操作，但它们也会占用存储空间并可能会慢下来写操作（INSERT、UPDATE、DELETE），因为它们需要更新每次写操作时。因此，它们应该被谨慎和策略地使用。 主题：MySQL中的唯一索引我们已经有了关于正常索引的深入了解，现在是时候讨论MySQL中的唯一索引了。 唯一索引是一种索引，它强制约束，要求所有值在索引中都不相同。这意味着，唯一索引不允许在索引所在的列（或列组合）上出现重复值，使它们非常有用，当你想要防止某些字段的重复时。 例如，考虑一个名为Users 的表，其中每个用户都有一个唯一的电子邮件地址。在这种情况下，在电子邮件列上创建一个唯一索引将确保两个用户不能具有相同的电子邮件地址。 创建唯一索引的语法与创建正常索引的语法略有差异： 1CREATE UNIQUE INDEX index_name ON table_name (column_name); 请替换 index_name 为您希望为索引命名的名称，table_name 为要在其上创建索引的表的名称，并将 column_name 替换为要在其上创建索引的列的名称。 例如，要在 Users 表上创建一个唯一索引，您可以使用以下语法： 1CREATE UNIQUE INDEX email_index ON Users (Email); 每次在 Users 表中插入或更新一个电子邮件时，MySQL都会检查唯一索引，并如果发现另一行具有相同的电子邮件值，就不会允许更改。 请记住，唯一索引不仅可以帮助保持数据完整性，还可以帮助提高数据检索操作的性能。 主题：正常索引与唯一索引的差异我们已经详细讨论了数据库中的索引，并讨论了两种特定类型的索引：正常索引（或非唯一索引）和唯一索引。 两者都有不同的角色，了解差异是至关重要的。 唯一性：根据名称本身就可以看出差异——正常索引在列或列组合上允许重复值。 相反，唯一索引不允许插入具有重复索引列值的新行。 用途：正常索引主要用于提高MySQL的操作效率。 唯一索引，然而，具有双重目的。 它们可以同时提高操作效率并维护数据一致性，因为它们会拒绝具有重复值的新行。 约束：当您在具有唯一索引的表中插入一行时，MySQL先检查是否会违反唯一性约束。 如果是这样，MySQL就会拒绝更改并发出错误。 与正常索引相比，MySQL不会执行这些检查。 了解何时使用哪种类型的索引是至关重要的。 当您想要加速大型数据集上的查询时，正常索引就足够了。 但是，如果您需要确保列中的每个值都是唯一的，则应使用唯一索引，尽管它会消耗更多的资源来强制唯一性约束。 主题：优化 SQL 查询使用索引使用索引来提高数据库的性能并组织数据是使用 MySQL 索引的主要目标之一。 当正确使用时，索引可以显著加快数据检索操作的速度。 下面是一些提示，可帮助您优化 SQL 查询使用索引： 索引搜索字段：这似乎很简单，但值得重复。 如果您经常在表中搜索特定字段，请考虑索引该字段。 这可能会大大提高数据库的性能。 考虑索引大小：索引的数据量越小，速度越快。 因此，具有较小数据类型的索引列通常会更快。 例如，INT 比 VARCHAR 更快，VARCHAR 比 TEXT 更快。 限制写操作上的索引：索引可能会慢下写操作（例如 INSERT、UPDATE 和 DELETE 语句），因为每次修改数据时，索引也需要更新。 如果表经常更新，请考虑减少索引的数量。 复合索引：它们由多个列组成，并可以加速在 WHERE 子句中过滤多列时的数据检索。 注意，它们按左侧前缀的顺序工作。 这意味着索引列的顺序很重要。 使用 EXPLAIN 计划：MySQL 的 EXPLAIN 语句可以显示 MySQL 优化器如何执行您的查询，帮助您了解数据库是否能使用索引，并允许您进一步优化您的查询。 这就完成了关于如何优化 SQL 查询使用索引的课程。 主题：索引的常见陷阱MySQL 中的索引是强大的工具，可以显著加快查询的速度。 然而，您应该注意以下几点，在使用它们时要小心。 过多的索引：有过多的索引可能会反效果。 每个索引都会增加 MySQL 更新和管理这些索引所花费的时间。 这可能会慢下写操作。 因此，要确保只有必要的索引。 不了解卡尔数：卡尔数是索引中的唯一值数量。 如果卡尔数低（意味着有许多重复值），索引可能不会非常有效。 您应该关注索引的卡尔数并考虑是否应该使用另一列作为索引。 索引错误的列：索引应该基于经常搜索或排序的列。 索引错误的列可能会导致不高效的查询。 忽略查询执行计划：MySQL 的 EXPLAIN 语句可以提供有价值的信息，帮助您了解如何执行您的查询并识别使用的索引。 忽略这些信息可能会导致不高效的索引或优化的机会被错过。 使用大 VARCHAR 或 TEXT 索引：大 VARCHAR 或 TEXT 列的索引可能会消耗大量内存并慢下查询。 在这种情况下，索引前缀（INDEX(column(10)))可能会有用。 记住，有效的索引的秘诀在于了解数据并了解应用如何查询它。 有适当数量的良好选择的索引可以使数据库的性能显著提高。 主题：回顾和评估我们已经学习了 MySQL 索引的许多内容，包括它们是什么、它们的类型（普通和唯一索引）、它们是如何用于查询优化的、以及一些常见的误解和陷阱。 现在是时候进行快速评估了。这将帮助强化你的学习并帮助突出任何我们可能需要重新访问的地方。 例题： 为了测试你的理解，让我们通过一个例题来进行。 我们有一个名为 students 的 MySQL 数据库表，其结构如下： 1| id (INT) | name (VARCHAR) | class (VARCHAR) | age (INT) | 你经常需要查找来自特定 class 的学生。如何优化这个查询？ 解决方案： 为了优化这个查询，我们可以为 class 列添加一个索引。由于我们经常搜索这个字段，为其添加索引可以显著增加查询的性能。 下面是创建索引的 SQL 语句： 1CREATE INDEX idx_students_class ON students (class); 现在，让我们测试你的理解： 简单问题（难度：3/10）：要为 age 列添加索引，你将使用哪个 SQL 语句？ 1CREATE INDEX idx_students_age ON students(age); 复杂熟问题（难度：6/10）：在添加索引之前，你应该考虑哪些因素？ 列的卡尔伴：高卡尔伴列（具有许多独特值的列）最适合索引化。 应用程序的读写比率：如果应用程序执行更多的读操作，索引化是有益的。但是，如果应用程序执行更多的写操作（插入、更新、删除），索引的维护成本可能会超过好处。 列的数据类型：索引小数据类型列的速度更快。 复杂未知问题（难度：9/10）：数据库表 students 还有一个名为 registration_date 的列（日期类型），并且你正在运行查询来找到注册于特定年份的学生。你可以使用哪种索引来优化这个查询，并且怎样创建它？ 在这种情况下，你可以创建一个函数或表达式的索引，在 MySQL 8.0 或更高版本中称为函数索引。 要在 MySQL 8.0 或更高版本中创建函数索引，可以使用以下语句： 1CREATE INDEX idx_students_registration_year ON students((YEAR(registration_date)); 这样，MySQL 就可以直接将年份映射到索引中的行，从而加快查询的速度。 请注意，在 MySQL 8.0 或更高版本中创建函数或表达式索引是受支持的。如果你使用的是早期版本的 MySQL，你将需要添加一个单独的列来存储年份，然后索引该列。 English post: https://programmerscareer.com/mysql-interview11/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview11/"},{"title":"MySQL 面试：简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？","text":"你曾被要求类似问题在面试中吗？或者将来会遇到，让我们一起探索和掌握它。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：1.1 数据库事务中的问题介绍在深入数据库事务的复杂性时，需要承认这些操作不总是简单的。它们的主要目的是执行一系列操作，使数据库从一个一致的状态变化到另一个一致的状态。然而，同时进行事务时，我们遇到了许多问题，需要解决以维持一致性和完整性。 其中一个挑战是并发事务的问题。为了维持事务的 ACID 属性（原子性、一致性、隔离性和持久性），数据库系统必须正确地处理并发事务的执行。如果未能确保正确管理，可能会导致以下问题： 脏读：这种问题发生在一个事务读取另一个事务还未提交的变更时。如果后者事务被回滚，则前者事务读取了一个无效的值。 不可重复的读取：这是当一个事务多次读取同一行时，每次读取都会得到不同的数据，因为其他事务正在更新该行同时进行。 幻读：这是当一个事务执行两次相同的查询时，第二次结果集包含未在第一次结果集中的行，由另一个事务添加。 这些事务控制问题会破坏数据库事务的顺畅功能并影响数据完整性。在以下课程中，我们将深入探讨脏读和幻读的场景，并了解解决方案，包括 MySQL InnoDB 引擎提供的解决方案。 主题：1.2 理解脏读在数据库的上下文中，“脏读”是指一个事务读取另一个事务还未提交的脏数据。例如，事务 1 修改了某行，但尚未提交。现在，在事务 1 提交之前，事务 2 读取了未提交的变更。这就是脏读。 为什么这是一个问题？ 假设事务 1 最终回滚。在这种情况下，变更被撤销，但事务 2 已经读取了脏数据，导致不一致性并可能导致无效的结果在数据库中。 下面是一个简单的例子： 步骤 1： 事务 1 在 orders 表中修改了 order_status 字段，将其从 ‘Pending’ 更新为 ‘Shipped’。 步骤 2： 在事务 1 提交之前，事务 2 读取了 order_status 并发现它是 ‘Shipped’。 步骤 3： 事务 1 遇到错误并执行 ROLLBACK 操作，将 order_status 更改回 ‘Pending’。 步骤 4： 然而，事务 2 继续进行，并读取 ‘Shipped’ 状态，尽管这从未存在过。 脏读可能会导致严重的错误，特别是在数据分析或报告过程中，准确性是至关重要的。 中文翻译: 主题：1.3 理解幻读像脏读一样，幻读也是数据库事务中的并发问题。幻读通常发生在事务重新查询它已经查询过的数据，但发现新行，这些行在初始读取之后被其他事务插入或更新。 这些“幻”行是由另一个事务在我们的初始事务开始之后并在其结束之前插入或更新所导致的。 为了更清楚地理解这一点，让我们考虑一个简单的例子： 步骤 1： 事务 1 从 orders 表中检索所有 order_status 为 ‘Pending’ 的行。 步骤 2： 在这之间，事务 2 在 orders 表中插入了一个新行，其 order_status 为 ‘Pending’，并提交。 步骤 3： 现在，事务 1 再次运行相同的检索查询。这次，它发现事务 2 插入的行——这是一个幻行。 幻读问题主要发生在较低的隔离级别中，例如“读已提交”，但不是较高的隔离级别，例如“序列化”。这是由于使用排他范围锁来阻止在读范围内插入新行所导致的。 然而，这些较高的隔离级别也会遇到问题，例如较低的并发和较高的争用。因此，事务隔离级别的选择通常需要权衡性能和一致性之间的交换。但是，不要担心，InnoDB 提供了处理这些情况的方法。 主题：1.4 InnoDB 在处理幻读方面的作用InnoDB 存储引擎在 MySQL 中起着关键的作用，处理数据库事务问题，包括幻读。它通过使用 多版本并发控制 (MVCC) 来允许多个事务同时访问同一行，而不会影响彼此的工作。 每个事务看到数据库在其工作开始时的一个快照，使并发事务相互隔离。这对 MySQL InnoDB 中的 “I” (一致性) 部分起着重要作用。 此外，您还可以在 MySQL 中设置不同的隔离级别来自定衡读一致性、并发和性能之间的平衡。这些隔离级别包括 READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。 重复读级别是 InnoDB 的默认级别，它保证了所有在同一事务中的读取都会看到数据库在事务开始时的一个快照。这个特性有效地防止了幻读。 然而，在某些业务场景中，序列化级别可能是必需的，提供最高的数据一致性，但是以代价较低的并发和性能。 在本课程的后期，我们将详细讨论 InnoDB 如何实现 ACID 属性并自定化这些事务属性，根据用户需求进行调整。 主题：1.5事务隔离级别事务隔离级别在数据库管理系统中如何管理并保护事务免受潜在问题（脏读、不可重复读和幻读）的中心角色。 在 MySQL 中，有四种预设的隔离级别，每种级别具有性能和保护之间的不同权衡： 读未提交：这是隔离级别的最低水平，它允许事务看到其他事务未提交的更改。这意味着事务可能会看到“脏”数据，其他事务可能会后悔。 读已提交：这个级别保证了任何读取的数据都已提交。因此，它防止脏读。然而，如果事务多次读取同一行，它可能会看到不同的值，如果另一事务修改了该行之间，这可能会导致不可重复读。 可重复读：这是 InnoDB 的默认隔离级别。它防止脏读和不可重复读，并确保所有读取的相同行在同一事务内返回相同的结果，除非该行自身被该事务修改。 序列化：这是隔离级别的最高水平。它锁定读取的行，防止其他事务（读或写）访问它们，直到第一事务完成。虽然这种级别可以防止脏读、不可重复读和幻读，但它显著降低了并发性。 了解这些隔离级别是管理并发事务有效的关键。在下一主题中，我们将讨论一些实现并发控制的技术和实践。 主题：1.6并发控制的策略数据库中的并发控制的目的是允许多个事务同时访问数据库，而不会发生冲突或错误。为了有效地实现并发控制，我们可以利用以下策略： 锁定基于的协议：这是一种常见的方法，其中给定事务在需要时为数据项锁定访问。有两种锁：排他锁和共享锁。前者不允许其他事务访问数据项，后者允许，但仅限于读取目的。 时间戳基于的协议：这种方法涉及为每个事务分配一个时间戳，确保早期事务具有优先权，特别是在冲突时。 有效性基于的协议：也称为乐观并发控制，这种方法允许事务执行无限制并在提交时进行有效性检查。 **多版本并发控制 (MVCC)**：主要用于 InnoDB，MVCC允许每个与数据库连接的用户从事务开始时看到一致的快照集。 数据项的粒度：这决定了锁定的数据项的大小——从单行到整个数据库。 每种策略都有其优势和劣势。例如，锁定基于的协议可能会创造性能问题由于锁争，而 MVCC可能会为 InnoDB 提供高并发和减少了锁定的需求，但可能会增加存储的成本。 要选择一种策略，应考虑应用程序的需要和考虑，例如性能、一致性和复杂性。 主题：1.7 回和评估你已经做得非常好地探索了数据库事务的关键方面，了解了并发控制的概念，它所倾向的问题，并使用各种策略来处理这些问题。 到目前为止，我们已经了解了并发控制的必要性，即处理同时发生的事务。我们已经识别了潜在的挑战，例如脏读、不可重复读和幻读，这些基本上涉及事务如何处理来自其他事务的数据更改。 我们深入探讨了脏读是什么，它是如何发生的，以及对数据库事务的影响。同样，我们对幻读发生的情况进行了详细讨论，并讨论了它可能会导致的问题。 我们研究了 MySQL 中 InnoDB 存储引擎的角色，特别是它是如何实现“一致读取”来处理幻读。 我们进一步深入探讨了事务隔离级别的概念，了解配置不同的事务隔离级别可以影响脏和幻读的发生。 我们还讨论了处理并发问题的各种策略，例如事务调度和使用各种类型的锁定基于的协议。 现在，让我们回一下这些关键概念，通过评估来评估你对脏读、幻读和 InnoDB 解决这些问题的方法的理解。 好的，让我们来解决三个评估问题。试着解决每一个，然后我会提供答案。 简单问题（难度：3/10）假设同时发生两个事务，事务 1 读取了数据对象，事务 2 后来更新了它。识别这种读取问题可能会发生的。 复杂熟问题（难度：6/10）在数据库事务的上下文中，MySQL 中的 InnoDB 存储引擎是如何处理幻读的？描述一下 ‘一致读取’ 是如何帮助管理这些幻读。 复杂未熟问题（难度：9/10）你是银行系统的数据库管理员。同时发生两个事务，其中一个是客户 ‘A’ 向客户 ‘B’ 转账，另一个是银行计算客户 ‘A’ 的总余额。由于这些事务的并发性，银行余额计算发生在转账事务未完成之前。解释可能会发生的问题。 简单问题（难度：3/10）这是一个“脏读”的问题。在数据库管理中，脏读是指事务 1（Transaction 1）可以读取数据库中的行，该行已经由另一事务（Transaction 2）修改，但尚未提交。因此，如果 Transaction 2 回滚更改，Transaction 1 将读取被视为不存在的数据。 复杂熟问题（难度：6/10）InnoDB 存储引擎在 MySQL 中使用了“一致读取”来处理幻读。一致读取是 InnoDB 选择操作使用的非锁定读取，它为提供数据库的一致性快照提供了支持。它通过应用多版本并发控制（MVCC）来实现，其中存储多个版本的记录。这样，用户就可以无锁定延迟浏览数据库。 复杂未熟问题（难度：9/10）在给定的场景中，可能会发生不可重复读的问题。不可重复读是指事务读取了同一行两次并获取了不同的数据。在这种情况下，银行余额计算事务可能先计算了余额，然后再次读取数据后客户 ‘A’ 转账了金额。因此，第一次和第二次读取会导致不同的客户 ‘A’ 的余额。 English post: https://programmerscareer.com/mysql-interview12/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview12/"},{"title":"MySQL 面试：聚簇索引和非聚簇索引有什么区别？","text":"你曾被提过类似问题在面试中问过吗？或者将来会遇到，让我们一起探索和掌握它！ 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：1.1 聚集索引和非聚集索引的介绍了解数据存储和检索的方式对数据库的性能有着重要的影响。特别是了解 MySQL 是如何使用索引的非常重要。这就是聚集索引和非聚集索引的概念发挥作用的地方。 索引是数据库的一个重要组成部分。它们是查找表，数据库引擎使用它们来加速数据检索，就像书的索引一样，它可以帮助你快速定位信息，而不必阅读每一页。 现在，让我们详细地讨论聚集和非聚集索引： 聚集索引： 就像名字所表明的那样，聚集索引决定了表中数据的物理排列顺序。为了更好地理解这一点，请考虑聚集索引是字典。在字典中，单词不是随机排列的，而是按字母顺序排列，这样你就可以快速跳到特定的字母部分并找到单词。在数据库的上下文中，这个“单词”是数据行。MySQL 就是按聚集索引的顺序组织数据行，以加快检索。请注意，表中只能有一个聚集索引。 非聚集索引： 非聚集索引不决定表中数据的物理排列顺序。然而，它们保存了数据的“指针”。为了更好地理解，如果聚集索引是字典，那么非聚集索引就是书的索引。书的索引指向包含信息的页面，但它们本身不包含信息。这意味着数据库引擎必须执行额外的工作，以“去”数据行，与聚集索引相比，非聚集索引的数据检索可能会慢一些。然而，你可以有多个非聚集索引，这可能对数据检索的多种场景有所帮助。 主题：1.2 聚集索引详解聚集索引与数据的物理存储有关。当你为表创建一个聚集索引时，表中的行按索引键的顺序存储在磁盘上。表中只能有一个聚集索引，并且如果你没有显式定义一个聚集索引，SQL Server 将自动为你创建一个。这被称为堆。 聚集索引的结构也被称为 B+ 树结构。堆栈树的根节点位于树的顶部，然后分支出多个叶节点位于底部。这些叶节点包含数据行在索引的顺序中。 主键约束自动创建一个聚集索引，但在某些情况下，你可能希望手动创建一个聚集索引，这取决于你的要求。例如，如果你有一个员工数据表并经常按员工聘用日期进行查询，则可能会为聘用日期列创建一个聚集索引，以加快这些查询。 此外，在表中具有聚集索引的记录更新时，数据库可能会更慢，这是因为当记录更新在表中具有聚集索引时，数据库可能需要物理移动整行，以维护排序顺序。 主题：1.3 非聚集索引的介绍现在我们已经对聚集索引有了深入的理解，了解它是如何排列和存储数据的。但是，并不总是想要根据单个聚集索引来检索数据。这就是非聚集索引的作用所在。 非聚集索引与聚集索引有着明显的区别。首先，创建非聚集索引不会重新排列表中数据的物理顺序。相反，它会创建一个独立的数据库对象，其中包含一个排序的列表，指向表中的数据。 为了说明这一点，请考虑一本书——相对于浏览整本书以找到特定主题，你通常会转到书的索引，是不是？它会直接将你导向包含指定主题的页面。这种快速导航就是非聚集索引所执行的功能！ 非聚集索引的架构与聚集索引相似——B-树数据结构中的根节点、中间级节点和叶节点。然而，非聚集索引的叶节点仅包含索引列和指向数据表中相应行的指针。你可以为单个表创建多个非聚集索引，每个索引都为特定查询提供了加速。 在 MySQL 中，非聚集索引就是所有的辅助索引，其中每个索引都包含主键列的副本，用于指向搜索键匹配的行。 主题：1.4 聚集和非聚集索引的差异现在我们已经对聚集和非聚集索引有了深入的理解，让我们来明确它们之间的主要差异： 数据的排列顺序：聚集索引决定了表中数据的物理排列顺序。另一方面，非聚集索引不会改变数据记录的存储方式，但会创建一个数据库对象，该对象指向原始记录。 索引数量：表中只能有一个聚集索引，但是可以有多个非聚集索引。请记，越多的索引，就需要越多的磁盘空间。 数据检索速度：聚集索引可能会比非聚集索引更快地检索数据，但这并不总是如此。如果非聚集索引覆盖了查询（即，查询的数据可以从索引的叶节点中服务），它可能会更快地检索数据，尽管它需要一些额外的跳转。 更新性能：聚集索引可能会降低更新的性能，而非聚集索引通常不会影响性能。 存储空间：由于非聚集索引是与表数据分开存储的，因此它需要额外的存储空间。每个非聚集索引是一个独立的磁盘结构，其中包含一个排序的列表，其中包含列值，而聚集索引是表数据本身并形成了索引的最低级别。 在数据库的大图景中——数据检索速度、存储效率、更新速度等等——所有这些因素都依赖于良好的索引。清楚地了解何时和为什么使用聚集和非聚集索引可以帮助您优化数据库性能。 主题：1.5 选择正确的索引恭喜！现在我们知道什么是聚集索引和非聚集索引，并了解了它们之间的主要差异，让我们深入探讨选择正确的索引进行性能优化。 在 MySQL 中选择正确的索引来进行性能优化，主要取决于了解将要执行的查询。它不仅仅是选择聚集或非聚集索引，还包括了列和其卡inality 的理解。 下面是一些关键点来帮助你决定： 使用聚集索引来处理宽列查询：由于聚集索引本身就是表数据，因此对宽列查询来说非常有用，因为它可以减少读取的数量。 使用非聚集索引来处理特定列查询：非聚集索引在需要检索较小的列集时非常有用。在这种情况下，为这些列创建非聚集索引可能会有好处。 高卡inality列：当列具有高卡inality（每行都是唯一的）时，使用它作为聚集索引可能会导致更快的查找。 低卡inality列：对于具有低卡inality（许多行共享相同值）的列，使用非聚集索引通常更有效。 数据修改操作：如果应用程序包含频繁的插入、更新和删除操作，非聚集索引可能是更好的选择，因为它们不会影响磁盘上的数据排序。 空间考虑：由于非聚集索引是独立的磁盘结构，它们会消耗额外的存储空间。如果存储空间是一个限制，聚集索引可能是更好的选择，虽然在某些情况下，它可能会影响速度。 记住，最佳策略总是取决于特定的工作负载。它是必要的进行持续的监控和分析，并根据性能进行索引策略的调整。 主题：1.6 示例和用例好的！你已经做得很好了。为了巩固理解，让我们来看看一些实际的例子和用例。 开始时，让我们考虑一个基本的例子，假设你直接管理一个在线书店。你有一个名为 Books 的表，其中包含以下列：BookID、Title、Author、Genre、Price 和 PublicationDate。 使用聚集索引：假设客户经常根据 BookID 在您的商店中搜索书籍。为了提高这些常见的拉取请求的速度，您可以使用 BookID 列上的聚集索引。由于聚集索引确定数据在表中的物理排序，行查找可能会显著加快。 使用非聚集索引：如果客户经常根据 Genre 或 Author 搜索书籍，则可能有利于创建非聚集索引在这些列上。正如我们所了解的，非聚集索引特别有用当你需要检索较小的列集时。 用例：假设您的数据库具有名为 Customers 的表，其中包含数百万条记录，并经常需要检索客户信息根据 CustomerID。在这种情况下，使用 CustomerID 列上的聚集索引可以显著加快这些查找。然而，如果业务需求要求您根据 LastName 和 ZipCode 检索记录，则非聚集索引在 LastName 和 ZipCode 列上可能更有效。 请记住，这些只是例子，并且实际的实现可能会大大地变化，取决于因素如数据大小、查询复杂性和硬件能力。了解何时使用聚集和非聚集索引——基于智能数据库设计——是管理 SQL 数据库的重要方面。 主题：1.7 回顾和评估恭喜！让我们回顾主要的概念并进行评估。 聚集索引：这种类型的索引确定了表数据的物理排序。表只能有一个聚集索引。 非聚集索引：这种类型的索引是独立的磁盘结构，引用表数据，帮助加速不在聚集索引范围内的查询。表可以有多个非聚集索引。 高 vs. 低卡inality：高卡inality指的是具有独特值的列，在大多数，如果不是所有，行上。对高卡inality列使用聚集索引可能会导致更快的查找。低卡inality指的是具有多个行共享相同值的列。对于这些列，非聚集索引通常更有效。 选择正确的索引：这取决于各种因素，包括查询类型、卡inality、数据修改需求和空间约束。 现在，让我们通过几个问题来评估我们的理解： 聚集索引和非聚集索引之间的主要区别是什么？ 在哪种情况下，非聚集索引比聚集索引更适合？ 高卡inality和低卡inality是什么意思，并且如何影响索引类型的选择？ 问题：聚集索引和非聚集索引之间的主要区别是什么？答案：聚集索引和非聚集索引之间的主要区别在于存储和引用数据的方式。聚集索引确定了表数据的物理排序，本身就是表数据，而非聚集索引是独立的结构，指向数据位于数据库的其他地方。 问题：在哪种情况下，非聚集索引比聚集索引更适合？答案：非聚集索引更适合在数据库需要支持大量搜索查询的列上，这些列不在聚集索引范围内。此外，非聚集索引还更适合在表经常更新时，因为更新不会导致整个表需要重新组织，与聚集索引相比。 问题：高卡inality和低卡inality是什么意思，并且如何影响索引类型的选择？答案：卡inality是数据值在列中的独特性。高卡inality意味着列中具有大量独特值，低卡inality意味着列中具有多个重复值。对高卡inality列使用聚集索引可能会导致更快的查找，而对低卡inality列使用非聚集索引通常更有效，因为在这些列上，值是非常重复的。 English post: https://programmerscareer.com/mysql-interview13/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview13/"},{"title":"MySQL 面试：什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项？","text":"你曾被提过类似问题在面试中问过吗？或者将来会遇到，让我们一起探索和掌握它！ 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题 1.1 — 深入探讨事务简单地说，事务是在数据库管理系统（或类似系统）中对数据库进行的单元工作，并以可靠的方式独立处理。 事务通常表示数据库中的任何更改。更具体地说，事务是一系列数据库操作的逻辑单位。 考虑转移银行帐户中的资金的例子。这项操作需要两个步骤： 在一个帐户中取款。 在另一个帐户中存款。 两个步骤都必须完成，以便事务被认为已完成。如果在这两个操作之间发生了什么，例如服务器故障，事务将被认为是不完整的，并且数据库必须回滚到其前一致状态。 这样，事务帮助数据库保持完整性，确保相关操作的集合要么全部发生，要么全部不发生。事务的概念与 ACID（原子性、一致性、隔离性、持久性）密切相关，为数据的可靠处理提供了框架。 主题 1.2 — MySQL 和事务MySQL 是一个数据库管理系统，提供了处理事务的支持。这意味着 MySQL 允许您将某些操作组合在一起，以便要么所有操作都执行，要么不执行。这在数据库中的中间步骤失败可能导致数据库不一致的场景中尤其重要。 再次考虑转移银行帐户中的资金的例子。现在，让我们说我们正在使用 MySQL 数据库来管理这些事务。让我们按步进： 用户 A 启动了一项事务，请求转移 $100 给用户 B。 MySQL 开始了事务。 MySQL 从用户 A 的帐户平衡中扣除 $100。 MySQL 尝试为用户 B 的帐户添加 $100。 我们考虑两种情况： 如果操作成功，MySQL 提交了事务，数据库显示了两个用户的更新帐户平衡。 如果出现故障（可能是由于服务器崩溃或未预期的问题），MySQL 回滚了事务。结果是数据库保持了其初始状态，没有对用户 A 或用户 B 的帐户平衡进行更改。数据库保持一致性。 这样，MySQL 在保持 ACID 原则的情况下，为数据库处理提供了关键角色。 请记，MySQL 的事务处理功能不是每个设置都提供，而是需要特定类型的存储引擎。我们将在以后的主题中进一步探讨这一点。 主题 1.3 — 了解 InnoDB现在，我们已经了解了事务在维护数据库完整性的重要性并了解了 MySQL 是如何处理事务的，是时候探讨 InnoDB 了。 InnoDB 是 MySQL 的存储引擎。初始版本的 MySQL 用户需要选择两种主要类型的存储引擎——MyISAM 和 InnoDB。每个引擎都有自己的优势和劣势。然而，MyISAM，一个更早的引擎，不支持事务。InnoDB，另一方面，提供了完整的事务支持，涉及多条语句的提交和回滚。InnoDB 还提供行级锁定，增加了多用户并发和性能，并具有我们已经讨论过的一些特性。 自 MySQL 5.5 版本的发布以来，InnoDB 已经成为默认的 MySQL 存储引擎，除非另外指定。这种决定主要基于 InnoDB 的稳定性和全功能性。 因此，InnoDB 的强事务支持，以及其他特性，使它成为广泛和复杂的数据库系统的强大选择。 主题 1.4 — InnoDB 的优势InnoDB 的主要优势在于其强大的事务处理和行级锁定功能。这使它成为广泛和复杂的数据库系统的强大选择，特别是在具有高数量并发用户的情况下。 让我们来详细分析一些这些优势： 可靠性和持久性——ACID 遵从性： 就像我之前提到的一样，InnoDB 的事务遵从 ACID 模型，由其提交、回滚和崩溃恢复功能支持。它确保您的事务是可靠的，并且数据是持久的。 行级锁定： InnoDB 使用行级锁定，而 MyISAM 使用表级锁定。行级锁定更有效，因为它允许更高的并发性和在多用户环境中的更好的性能。 InnoDB 缓冲池： InnoDB 使用缓冲池来缓存其表的数据和索引。这个特性减少了 I/O 操作，使系统更快和更具有性能。 外键约束： InnoDB 支持使用外键约束来维护参考完整性。当数据在一个表中依赖数据在另一个表中时，您可以通过外键约束来防止错误地删除关键数据。 自动崩溃恢复： InnoDB 具有自动崩溃恢复的功能。在崩溃期间更新的关键数据不会丢失，因为引擎自动重放其日志。 这些只是 InnoDB 为 MySQL 数据库带来的许多优势的一些。根据您的特定需求，可能还有更多与您的使用场景相关的好处。 主题1.5 — InnoDB 与 MyISAMInnoDB 和 MyISAM 都是 MySQL 的存储引擎，但它们有显著的差异。了解这些差异对决定适合特定用例的存储引擎至关重要。 让我们根据以下几个关键参数进行比较： 事务： 我们以前已经讨论过，InnoDB 支持事务，而 MyISAM 不支持。如果您需要事务性整性，则应选择 InnoDB。 锁定： InnoDB 实现了行级锁定，而 MyISAM 实现了表级锁定。行级锁定允许更高的并发性并提供更好的性能，特别是对频繁、小数据修改的操作。 外键约束： InnoDB 支持外键约束，而 MyISAM 不支持。 全文搜索： MyISAM 具有内置的全文搜索支持，这使它成为主要要求的好选项。 数据安全性： InnoDB 使用事务日志来确保数据安全性（ACID 兼容性），而 MyISAM 不使用。 压缩： InnoDB 支持表压缩，允许表数据和相关索引进行压缩，以节省磁盘空间并提高 I/O 效率和性能。 最重要的是要记住，没有一个通用的“正确”选择之间的 InnoDB 和 MyISAM。适合的引擎取决于您的特定情况和要求。 主题1.6 — 案例研究：真实世界的例子和场景，数据完整性和事务的重要性数据完整性和事务是许多真实世界的应用程序中的关键要素。为了说明其重要性在实际场景中，让我们考虑几个案例研究。 在线银行和金融服务： 在在线银行系统中，假设一个客户从储蓄账户转移了资金到支票账户。这个过程包括两个单独的任务：减少储蓄账户的余额和增加支票账户的余额。两个任务都需要发生。如果系统在储蓄账户被扣除后但是在支票账户被加载之前出现故障，客户就会损失资金。事务的 ACID 特性确保数据的一致性。 电子商务平台： 考虑一个客户在电子商务网站上下单。这个过程包括检查库存、确认付款、更新库存和确认订单。任何错误或故障在一个阶段应该阻止整个过程。事务为这些操作提供了安全的通路，确保数据的一致性。 航空航班预订系统： 当一个座位在航班上预订时，系统先检查座位的可用性，然后预订座位，然后接受付款。如果航空预订系统崩溃在座位被预订但是在付款确认之前，航空公司就会损失。通过事务，在后期的故障中，前期的阶段自动回滚，释放座位以供其他客户使用。 这些是几个场景，其中数据一致性是至关重要的。在关键系统中，InnoDB 的强大功能为数据的一致性提供了非常有用的支持。 主题1.7 — MySQL 面试题：数据库事务为什么重要，为什么 InnoDB 是 MySQL 的默认选项？事务是数据库系统的一个重要概念。它们用于保护组织的信息，在系统故障（例如电力中断、软件崩溃或更危险的内容攻击）发生时进行保护。 事务是一系列的单个逻辑单元的操作序列。操作可以包括读取数据库记录、修改这些记录或者在特定参数内进行数据操作。 在数据库系统中，事务被管理使用 ACID 的缩写，它代表原子性、一致性、隔离性和持久性。 原子性：保证事务中所做的所有更改都被提交到数据库中，或者如果发生错误，则不会提交任何更改。 一致性：确保事务不会在运行后将数据库置于不一致的状态。 隔离性：确保一个事务不会干另一个事务。 持久性：确保已提交的更新持久化，即使发生电力中断或系统崩溃。 现在，为什么 InnoDB 是 MySQL 的默认选项？ InnoDB 存储引擎提供了一种强大和可靠的方式来处理事务。它具有许多特性，例如 ACID 兼容事务支持、行级锁定和实际实现，例如外键，使其成为 MySQL 的默认引擎。 此外，InnoDB 提供了崩溃恢复功能并提供硬件加速，例如固态硬盘 (SSD) 或硬盘。 简而言，InnoDB 的优势在于其广泛适用的特性集，包括事务、可靠性和性能优化，适合大多数工作负载。 主题1.8 — 复习和评估在本课程中，我们已经讨论了： 事务 的重要性在维护数据完整性， MySQL 如何支持事务并为其提供好处， InnoDB 的介绍、其优势和为什么它是 MySQL 的默认存储引擎， InnoDB 和 MyISAM 之间的差异， 在实际场景中，数据完整性和事务的重要性， 并提供了一些常见的 MySQL 面试问题和答案。 为了复习，我将提供一组问题和问题，它们将从简单到复杂，所以请思考深入地。 问题 1 (3/10 难度)： ACID 是事务的四个属性的缩写，它们是什么？ 问题 2 (6/10 难度)： 为什么事务在数据库中的数据完整性方面重要？ 问题 3 (9/10 难度)： 为什么 InnoDB 是 MySQL 的默认选项，并在哪些方面优于 MyISAM？在回答中包含 InnoDB 的好处。 English post: https://programmerscareer.com/mysql-interview14/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview14/"},{"title":"MySQL 面试：数据库的事务隔离级别有哪些？各有哪些优缺点","text":"你曾被提过类似问题在面试中问过吗？或者将来会遇到，让我们一起探索和掌握它！ 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题 1.1：事务隔离级别简介让我们开始了解 MySQL 中的事务隔离级别！ 先来看基本知识。 在允许并发事务的数据库系统中，事务隔离级别决定了一个事务与另一个事务之间的隔离程度。它们是必要的，因为它们帮助管理并发事务，防止数据不一致，并确保任何事务系统中的数据的完整性。 ANSI/ISO SQL 标准定义了四个事务隔离级别，具有相应的现象防止： 读未提交：这是事务隔离级别的最低级别，在这种情况下，一个事务可能会看到另一个事务尚未提交的更改。 读已提交：它保证了任何数据的读取是在读取时提交的。它不能防止其他事务修改数据。 可重复读：这个级别确保了如果一个事务读取了数据，然后其他事务修改了该数据，则第一个事务将获取相同的数据，不管后续的读取是否发生。 序列化 - 这个级别提供了最高的数据保护，它通过执行事务来实现，或者是一个接一个的事务。但是，这可能会导致性能问题。 还要知道，MySQL，具有 InnoDB 存储引擎，只支持 Repeatable Read（默认隔离级别）、Read Committed 和 Serializable。 每个隔离级别都有其优点和缺点，解决了某些问题，同时可能会引入其他问题。这是管理并发事务的必要权衡，以平衡性能和准确性。 主题 1.2：读未提交级别在“读未提交”中，事务可能会读取尚未提交的数据，这是因为它读取的数据尚未提交到数据库中。 考虑下面的场景：一个事务正在修改表的一些行： 123UPDATE Inventory SET Quantity = Quantity - 10 WHERE ItemName = 'Apples'; 当这个事务仍然在进行时，另一个事务读取了同一表的数据。根据读未提交级别，它会看到尚未提交的更改，包含正在处理的数据，导致所谓的“脏读”。 可能会出现一个事务失败（并发行回），使这些更改无效。但是，第二个事务已经读取了未提交数据，继续使用错误、不准确的数据。这可能会导致数据不一致。 在性能方面，然而，“读未提交”通常更快，因为它不需要为读数据锁定，以防止其他事务修改或读取。 然而，“读未提交”的缺点现在显现出来。它无法保证数据的准确性和一致性，因为，就像我们所说的，它允许“脏读”。 在实际应用中，这个隔离级别通常被避免，除非性能是最重要的因素，数据准确性不是主要考虑因素。 主题 1.3：读已提交级别根据名字所表明，“读已提交”级别允许事务只看其他事务在开始读取之前已经提交的更改。因此，它解决了我们在“读未提交”隔离级别中讨论的“脏读”问题。 让我们通过一个简单的例子来说明： 考虑两个账户，‘A’ 和 ‘B’，其当前余额分别为 $500 和 $200。假设一笔交易被初始化，从账户 ‘A’ 中转出 $100，并转入账户 ‘B’。在此过程中，账户 ‘A’ 的余额减少到 $400，尽管交易尚未完成。 在“读未提交”隔离级别中，如果另一项目试图同时计算两个账户的总余额，它可能会将账户 ‘A’ 的中间状态（即 $400）和账户 ‘B’ 的原始状态（即 $200）相加，导致错误的总余额 $600。 然而，在“读已提交”隔离级别中，第二项目等待第一项目完全完成。因此，它正确地计算总余额为 $700（$400 在账户 ‘A’ 中 + $300 在账户 ‘B’ 中）。 因此，在“读已提交”隔离级别中，一个事务不会看到其他事务未提交的更改，这是维护数据一致性的一个大步。 然而，现在我们面临另一个问题，称为“非重复读”。这发生在单个事务的生命周期内，试图两次读取同一行，但每次读取时获取不同的数据。这种情况是可能的，如果，在第一次和第二次读取之间，另一项目修改了该行并提交了更改。 主题1.4：可重复读级别在“可重复读”隔离级别下，不仅其他事务的变更在提交之前是不可见的（就像“读提交”一样），但是事务第一次读取某些数据后，该数据在该事务的生命周期内不能变化。 换句话说，在同一事务中多次运行相同的 SELECT 查询将返回相同的结果，不管其他并发事务是否发生变化。这种约束解决了“非重复读”问题。 让我们来看一个例子： 考虑一种情况，其中事务读取了某些行，然后另一个独立事务修改了其中的某些行并提交了变更。如果第一个事务再次尝试读取相同的行，根据“读提交”隔离级别，它会注意到这些变化。 但是，在“可重复读”隔离级别下，第一个事务不会因为其他事务在其生命周期内提交的变更而察觉到任何变化。因此，读取相同的行会产生相同的结果。 虽然它解决了“脏读”和“非重复读”问题，但它也会遇到另一个问题：“幻读”问题，我们将在我们的下一节中讨论。 主题1.5：序列化级别“序列化”级别是所有级别中最严格的，提供了最高的数据一致性。它不仅处理“脏读”和“非重复读”问题，还解决了“幻读”问题。 首先，让我们了解一下“幻读”是什么。它是在事务的中间运行时新行被添加或现有行被删除的事务中发生的。它被命名为“幻”，因为这些记录似乎是“幻”的。 例如，考虑一个事务读取了某些行。另一个独立事务在此期间添加了某些新行并提交了变更。如果第一个事务再次读取该表，它会看到新行，这些行似乎是“幻”的。 在“序列化”隔离级别下，这种情况是不可能的。当事务在这个级别下运行时，它似乎就像其他事务不存在一样，消除了并发性相关的问题。 然而，这种精确性有代价。“序列化”隔离级别严重降低了性能，特别是对大型数据库。 简而言，“序列化”隔离级别确保绝对数据完整性，但是以性能为代价。 在讨论了每个特定的隔离级别之后，必须注意，您选择的级别最终取决于应用程序的性质。它总是关于性能和数据完整性之间的平衡。 主题1.6：MySQL事务隔离级别解释我们先讨论过，MySQL 中可用的四种事务隔离级别分别是读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和序列化（Serializable）。每种级别都为数据一致性、并发性和性能之间提供了不同的平衡。 然而，问题仍然存在：MySQL 是如何内部实现这些级别的？ MySQL 主要使用锁定来确保并发事务之间的数据一致性和隔离。它使用不同类型的锁，例如共享锁和排他锁，根据事务的要求和设置的隔离级别。 我们不会深入讨论细节，但是让我们了解这些锁是什么： 共享锁（S 锁）：当事务只是读取记录并未修改它时，会保持共享锁。多个事务可以同时保持共享锁的同一记录。 排他锁（X 锁）：当事务修改记录时，会保持排他锁。在给定时间内，只有一个事务可以保持排他锁的记录。 这些锁用于维护数据一致性并防止数据不一致。例如： 在 Read Uncommitted 级别下，不会使用任何锁来防止其他事务写入记录。 在 Read Committed 级别下，会使用共享锁，但是在读取行后立即释放锁。 在 Repeatable Read 级别下，会使用共享锁并保持其直到事务完成。 在 Serializable 级别下，会使用共享锁，并且直到事务完成之前，其他事务不能修改或插入新记录。 因此，根据使用的隔离级别，MySQL 引擎会以不同的方式获取和释放这些锁来实现所需的数据一致性，并在并发性和反之之间进行权衡。 然而，这种机制只是冰山一角。实际实现要复杂得多，并涉及许多其他因素，例如锁升级、死锁检测、日志缓冲和更多。 主题1.7：实践案例在本节中，我们将通过实际场景来了解不同的事务隔离级别的实际应用，并将所有的学习联系起来。 最合适的隔离级别主要取决于特定的读/写工作负载和每个应用的业务要求。在实际场景中，我们需要找到并发性和隔离之间的平衡。 让我们来看几个场景： 场景 1：银行系统 对于处理事务性数据的银行系统，例如银行转账，脏读和非重复读是绝对不可接受的。例如，如果你从一个自动Tellermachine（ATM）取出了钱，但由于并发事务，系统未能立即注册扣除，这可能会导致你提取了超过你的余额。这是对我们来说的一个美妙的场景，但对银行来说是一个灾难性的情况！ 因此，对于这样的系统，通常使用较高的隔离级别，例如SERIALIZABLE或REPEATABLE READ，尽管这可能会影响性能。 场景 2：电子商务应用 对于电子商务应用，允许脏读可能会导致卖出更多的商品，而如果我们非常严格地处理隔离级别，它可能会降低应用的性能并影响用户体验。通常使用READ COMMITTED的隔离级别在这里进行了交换，在交换中，我们在严格的隔离和增加并发性之间进行了权衡。 场景 3：数据分析和报告 在数据分析或报告场景中，我们正在读取大量数据但不会修改它，通常可以使用较低的隔离级别，例如READ UNCOMMITTED。这可以减少锁的开销并提高吞吐量。 请记，没有一个解决方案适用于所有的系统，它总是取决于特定的要求和情况。 主题1.8：就绪面试问题： 解释事务隔离级别。 答案： 事务隔离级别控制在从数据库中选择数据时所发生的锁定的程度。数据项上的锁定对数据库的并发性和一致性至关重要，特别是事务处理中。根据 SQL 标准定义的四种标准事务隔离级别：未提交读取、已提交读取、可重复读取和序列化。 问题： 每种事务隔离级别的优势和劣势是什么？ 答案： 未提交读取： 事务可能会读取其他事务尚未提交的更改，导致脏读和其他不一致性。优势是需要锁定的少量，因此性能更好。 已提交读取： 允许事务只读已提交的更改，避免脏读，但仍可能导致非重复读取或幻读。通常提供了一致性和性能的良好平衡。 可重复读取： 确保任何读取的数据不会更改，避免脏读和非重复读取，但仍可能导致幻读。 序列化： 最高级别的隔离。确保事务以完全隔离的方式进行，避免脏读、非重复读取和幻读，但可能会导致性能下降，因为需要广泛的锁定。 问题： 何时可能使用每种隔离级别？ 答案： 未提交读取： 数据分析任务，在看到未提交更改是可取的情况下，性能是关键的。 已提交读取： 应用程序，在维持高度并发性更重要的情况下，可能会出现偶尔不一致性，例如某些低影响的电子商务应用程序。 可重复读取： 在维持数据的一致性是至关重要的情况下，例如某些金融应用程序。 序列化： 仅在严格需要时使用，因为性能方面的影响，例如管理高度敏感数据的应用程序。 这些只是一些可能的面试问题的例子。记住，深入理解这些概念将允许您适应面试者可能会问的任何特定问题。 主题1.9：回顾和评估了解数据库事务的事务隔离级别是处理数据库事务时的基本知识。到目前为止，我们已经探讨了不同的事务隔离级别、其使用、优势和可能的弱点。 为了巩固理解，让我们来快速回顾并提出一些问题： 1. 根据 SQL 标准，描述四种事务隔离级别。 _你的答案： ______ 2. 描述一种场景，在哪里你会使用 REPEATABLE READ 隔离级别。 _你的答案： ______ 3. ‘脏读是指事务读取其他事务尚未提交的数据’ 是否为真？ _你的答案： ______ 4. 哪种事务隔离级别具有最严格的锁定，导致事务性能上的最大影响？为什么？ _你的答案： ______ 5.&nbsp;‘在 Read Committed 级别下可能会发生幻读’ 是否为真？ _你的答案： ______ 花时间来回答这些问题，反思你的回答，并与我们所学的内容进行比较。当你准备好时，我们可以一起讨论答案。如果你有任何不确定或需要更深入的解释，请勿犹豫。让我们确保你完全理解了这个概念！ English post: https://programmerscareer.com/mysql-interview15/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview15/"},{"title":"MySQL面试问题:什么时候分割数据库，什么时候分割表?","text":"让我们概述一下在MySQL中拆分数据库和表的课程 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：了解数据分布你好，我们将在本课程中开始了解数据分布。首先，让我们确定我们所说的“数据分布”是指什么。 数据分布是将数据、计算任务和应用程序分布在网络中的多个计算机上的方法。分布数据可以提高应用程序的性能、可靠性和可访问性。 😊 数据分布有多种原因。请允许我为您介绍其中的一些主要优势： 提高性能：通过分布数据，可以提高应用程序访问数据的速度。如果有效地执行，数据分布可以确保资源位于需要它们的地方，从而降低访问延迟并提高速度。 冗余和可靠性：通过数据分布，可以存储多个数据副本在不同位置。这提供了冗余并增加了数据的总体可靠性。如果一个服务器失败，应用程序可以从另一个服务器访问相同的数据。 可伸缩性：通过数据分布，当业务或应用程序增长时，可以更轻松地扩展基础设施。新的服务器可以随时添加到网络中。 负载平衡：通过有效地分布数据，可以确保服务器的负载均衡。这确保了无单点瓶，影响应用程序性能的情况不会发生。 数据分布可以采用多种方法，例如水平分区（也称为分片）、垂直分区和功能分区。每种方法都有其特点并适用于不同类型的应用程序。我们将在后续课程中详细探讨这些。 主题：MySQL数据库分割（分片）我很高兴看到你想深入了解！现在，让我们深入探讨数据分割，也就是分片。 在 MySQL 中，分片是将一个较大的数据库分割成更小的、更易于管理的部分，称为分片。每个分片都是一个独立的数据库。 想象一下，类似于将一个大书分割成多个章节，其中每个章节可以独立存储独特的信息。类似地，当我们分片数据库时，它就像将一个大数据库分割成多个“章节”，其中每个章节存储独特的数据。 然而，为什么要这样做呢？ 🤔 分片通常用于以下几个原因： 提高性能：分片可以大大提高读/写速度。当您发出查询时，不必浏览整个数据库，只需浏览特定的分片，显著提高速度。 可伸缩性：分片使数据库水平可伸缩。如果您的应用程序增长并且数据库开始变得太大以适合单个服务器，您可以随时添加更多的分片。 可靠性：如果一个分片出现故障，它不会导致整个应用程序崩溃。其他分片将继续运行无事故。 虽然分片有其多种好处，但它也有一些缺点： 增加复杂性：整个数据库环境变得更复杂。 数据分布：您必须决定如何分布数据，这可能会困难。 跨分片加入数据：如果您想要加入来自不同分片的表，这可能会困难或慢。 在 MySQL 中，分片通常在应用程序层上进行，通过分片库或框架。其中一些流行的分片算法包括范围基础、列表基础、哈希基础和目录基础分片。 主题：MySQL中的表分割（分区）如果记忆中，以前我们讨论了数据分布和为什么要将数据库分割成多个小部分，这个过程称为分片。 类似地，表分区是一种将大表分割成更可管理的小部分的方法，同时仍然能够访问和操作数据，就好像分区的表是一个单独的实体。换句话说，即使数据存储在分区中，从用户的角度来看，它仍然像是一个表。很酷，对吧？ 现在，为什么会有用处？ 😊 分区可能是解决方案，如果你有一个非常大的表，导致慢查询和更新，特别是如果该表预计会超过单个服务器的容量。 在本质上来说，分区是关于管理和优化数据以提高性能的。在不必要的复杂性出现的情况下使用分区可能会导致问题。 MySQL提供四种分区类型： 1. RANGE分区： 这是分区的简单类型。它最适合处理在特定范围内的数据，例如日期或量。 2. LIST分区： 它根据预定义的值列表进行分区。 3. HASH分区： 在这种情况下，MySQL应用哈希函数在分区键上进行确定。它用于确保数据均匀地分布在指定数量的分区中。 4. KEY分区： 它类似于哈希分区，但在这种情况下，MySQL服务器内部计算哈希值，用户不能控制。 所以，这是理论，在下一课中，我们将讨论如何在 MySQL 中实现这些原理，并提供一些实际示例来帮助说明这个概念。 主题：数据库和表分割的实践例好的！现在让我们将数据库分片和表分区的理论应用到实际例子中。 例 1：数据库分片 假设我们有一个全球范围的电子商务网站，客户数据在迅速增长中。我们可以为每个地理区创建一个分片，例如北美、欧洲和亚洲等。每个区的数据库分片仅存储位于该区内的客户数据。这样，我们就可以通过局部化数据和查询来提高性能。 例 2：表分区 在我们的电子商务网站的情况下，考虑一种情况，其中我们有 millions 的订单，并且大多数查询都是对最近的订单进行的。我们可以决定按日期分区“Orders”表，并为每个月保存单独的分区。这样，对特定时期的查询只需要扫描更少的行并执行更快。 但是，这些是如何在实践中进行的？ 对于 MySQL 中的数据库分片，有各种分片框架可用，例如 Vitess、phpMyAdmin 等。例如，在 Vitess 中，您将定义一个 VSchema，其中包含分片指令来自动分片所需的表。 123456789101112131415161718{ \"sharded\": true, \"vindexes\": { \"hash\": { \"type\": \"hash\" } }, \"tables\": { \"your_table\": { \"column_vindexes\": [ { \"column\": \"your_shard_column\", \"name\": \"hash\" } ] } } } 对于 MySQL 中的表分区，可以使用 ALTER TABLE 命令进行分区。 123456789ALTER TABLE orders PARTITION BY RANGE( YEAR(order_date) ) ( PARTITION p0 VALUES LESS THAN (1990), PARTITION p1 VALUES LESS THAN (2000), PARTITION p2 VALUES LESS THAN (2010), PARTITION p3 VALUES LESS THAN (2020), PARTITION p4 VALUES LESS THAN MAXVALUE ); 在这个脚本中，我们根据“order_date”列对“orders”表进行分区。 请记，这些过程通常由应用程序或框架处理，因此对 SQL 有一些了解是必要的。同时，分片和分区都会带来复杂性，只有在其好处超过复杂性时才应该使用它们。 主题：作出明智的决定我们已经讨论了很多内容，最后我们将讨论如何作出一个有理由的决定，重复了前面的课程中的一些关键点，并提供了一些额外的提示。 下面是要考虑的因素： 数据库分片（分割）决策作出： 数据大小：如果数据库变得太大而难以有效处理，可能需要分割。 性能：如果数据库中的频繁查询因数据量而变慢，分割可以帮助提高处理速度，因为它可以减少每个查询处理的数据量。 可伸缩性：如果您预计数据库将超过单个服务器的容量，在早期阶段实施分割可能是一个好的预防措施。 数据类型：分割可能会受数据类型的影响。例如，多租户应用程序，其中来自多个客户的数据存储在同一数据库中是一个分割的好候选。 表分区决策作出： 表大小：如果表在数据库中变得无限大，可能需要分区。 查询性能：如果大多数查询只处理表的某个部分（例如，最近的条目），分区可以大大加快这些查询的速度。 维护：分区也可以帮助维护表（例如，备份、更新和删除），因为这些操作可以在单个分区上执行，而不是对整个表进行线下维护。 在决定是否要分割或分区时，应该根据需要提高性能和处理大量数据或两者都是的。然而，这是一个复杂性增加的决定，应该只有在必要时并且其他简单优化技术不足时才应用。 主题：回顾和评估我们已经完成了数据分布的旅程，特别是MySQL中的数据库分割（分片）和表分区（分区）。现在，让我们快速回顾一下主要点，然后转到评估来巩固您的学习。 主要点 了解数据分布：数据分布具有显著的性能优势，但也会增加复杂性。了解何时和怎样使用它是至关重要的。 MySQL数据库分割（分片）：MySQL数据库分割涉及将数据库分割为更小的部分，基于一个键。它可以显著提高查询响应时间，增加可靠性并支持水平缩放。 MySQL表分区（分区）：MySQL表分区涉及将表分割为更小的部分，而无需更改SQL查询。分区可以根据各种策略进行，例如范围、列值、哈希值等。 实际示例：我们讨论了如何为全球客户的电子商务网站实现数据库分割，并如何使用表分区来提高性能，以处理最近的数据。 作出明智的决定：决定是否要实现数据库分割或表分区，或者两者都要，并为什么要考虑数据大小、查询性能、可伸缩性和数据类型。 现在，让我们来进行评估。您将被提供一些场景，并要求决定是否要使用分割、分区、两者都要，或者不要，并为什么。 评估场景 场景 1：您正在为医院设计应用程序，其中包含一个名为 patients 的表，用于存储患者记录。医院每年处理数千名患者，并且大多数患者只会来一次每年。大多数查询涉及访问最近的患者记录。您应该使用分割、分区、两者都要，或者不要，并为什么？ 场景 2：您正在为技术新闻网站开发应用程序，其中文章经常更新以进行修正，并且新信息和用户评论被不断地写入。评论被存储在一个名为 comments 的表中，每条评论与一个文章相关。您应该使用分割、分区、两者都要，或者不要，并为什么？ 场景 3：您正在为全球范围内的电子商务网站开发应用程序，其中包含一个名为 transactions 的表，包含网站上的所有交易的详细信息。您应该使用分割、分区、两者都要，或者不要，并为什么？ 场景 1：根据场景，应该在 patients 表上实现 表分区。查询涉及访问最近的患者记录，并且分区可以为这些查询提供有效的查询性能。分割可能不是必要的，因为我们没有明确的分割键，并且管理分布式事务和维护一致性可能会增加不必要的复杂性。 场景 2：在这种情况下，可能的解决方案是在 comments 表上实现分区。基于日期的分区系统可能会很好地工作，因为旧文章的评论可能会被频繁地读取，但不太可能会更新。分割可能会对这种情况造过多的复杂性。 场景 3：在这种情况下，分割 transactions 表可能会有好处，特别是在交易的位置上。这可能会使来自同一地区的交易被分组在一起，从而可能会导致更有效的查询。此外，分割还可能会帮助平衡多个数据库的负载，并为其提供额外的规模和性能优势。此外，您可能还会考虑分区单个分片。 这些是根据提供的信息而作出的推荐解决方案。然而，每个应用程序可能有独特的要求和约束，并且在作出设计决定时要考虑所有因素。记住，先测量再优化！ English post: https://programmerscareer.com/mysql-interview16/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview16/"},{"title":"MySQL面试问题:MySQL MVCC的实现原理","text":"我们可以深入了解MySQL如何实现多版本并发控制(MVCC)的细节 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：解析 MVCC多版本并发控制 (MVCC) 是数据库管理系统中使用的技术，用于处理多个用户同时访问同一数据而不发生冲突，从而提高处理效率。 简单来说，MVCC 允许多个事务同时访问同一数据而不发生冲突或需要读锁，这可能会严重影响性能。这是通过为事务创建数据的一个“快照”来实现的，其他并发事务不会影响这个快照。 现在，让我们分解一下术语 MVCC： 多版本：这意味着数据库保存多个版本的同一行。版本是数据在某个时间点的一个快照。 并发控制：这表明技术用于处理同时进行的事务，不发生冲突，确保每个事务都保持数据库的假象，就好像它是唯一访问数据库的。 MySQL 在其 InnoDB 存储引擎中实现了 MVCC。当事务更新 InnoDB 中的行时，原始行不会立即被覆盖或删除。相反，InnoDB 会存储更新前的旧版本，以便其他正在进行的事务可以看到原始版本。这就是数据行的多版本来源。 所以，为什么我们在 MySQL 中使用 MVCC？主要是性能原因。通过允许多个事务同时访问同一快照的数据，我们避免了读锁，这可能会严重影响性能，特别是在许多用户同时查询和更新同一数据库的情况下。 主题：MySQL 中的 MVCC 是如何工作的让我们来详细地了解 MySQL 中的 MVCC 是如何工作的。 当事务在 MySQL (InnoDB) 中开始时，它会被分配一个唯一的事务 ID。这个 ID 用于创建事务的数据库视图。这个视图包含已提交数据的所有版本，直到事务开始时，并且包含事务自身所做的更改。事务不能看到其他并发事务所做的更改，这为其提供了一致的快照并确保隔离性。 当行被修改时，InnoDB 不会覆盖现有数据。相反，它会写入新行版本并保存旧版本的信息在一个名为撤销日志的区域中。这个日志包含需要反转更改的信息，如果事务被回滚，并且提供旧版本的行给其他事务，如果它们需要它们。 现在，让我们讨论一些相关的主题：读视图、撤销日志和清理。 读视图 是 InnoDB 使用的机制，用于实现一致的读取，即读取数据库的快照，与事务开始时相对应。 撤销日志 是 MVCC 的一个关键部分。当事务修改数据时，InnoDB 会写入新行并在撤销日志中存储需要反转更改的信息。如果其他事务需要看到旧版本的行，InnoDB 使用撤销日志中的信息来重构它们。 清理 与 InnoDB 如何清理不再需要的旧版本的行有关。一旦所有可能需要访问旧版本的行的事务都完成了，InnoDB 就可以释放这些版本所占用的空间。这个过程被称为清理。 主题：ACID 特性和 MVCC在可靠的数据库管理系统中，维持 ACID 原则（Atomicity、Consistency、Isolation、Durability）是至关重要的方面之一。 原子性：如果事务包含多个操作，原子性意味着要么所有操作都成功执行，要么都不执行。事务不能部分完成。如果发生任何操作中的错误，整个事务将被回滚。 一致性：一致性意味着事务应该将数据库从一个一致状态转换到另一个一致状态，根据已定义的规则。例如，如果帐户没有足够的余额进行提款，则事务应该被拒绝以维持一致性。 隔离性：隔离性在多个事务同时执行时发挥作用。它意味着每个事务应该像是唯一一个事务一样执行。事务的中间状态不应该可见于其他事务。 持久性：持久性确保事务一旦提交，就会永久保存。换句话说，事务的结果是永久的。 MVCC (多版本并发控制) 与 ACID 特性相关，下面是详细的解释： 在 MySQL（特别是其 InnoDB 存储引擎）的上下文中，MVCC 提供了隔离和一致性。 隔离性 由每个事务使用其自身的数据库快照来保证。即使多个事务同时试图读写同一数据，每个事务也会看到其自身的一致快照，就好像它是唯一一个事务一样。 一致性 由 MVCC 中的回滚日志来维护。如果事务失败或回滚，则可以撤销该事务中的更改，以确保数据库处于一致状态。此外，通过为事务创建事务特定的数据视图，可以确保事务总是处理一致的数据集。 主题：快照读和当前读在 MySQL 中，当 MVCC (多版本并发控制) 发挥作用时，有两种主要类型的读取操作：快照读和当前读。让我们详细了解这些概念。 快照读 快照读，就像名字所表明的，提供了数据库在事务开始时的一致快照。它不会看到其他并发执行的事务所做的更改。这种读取是默认模式下 SELECT 语句的。快照读是 MVCC 的核心，它为 MVCC 提供了“一致视图”的概念。 当前读 与快照读不同，当前读看到最新提交的数据，包括其他事务所做的更改。模式如 SELECT…FOR UPDATE 和 SELECT…LOCK IN SHARE MODE 使用当前读。它还用于当前事务所做的数据更改，例如 UPDATE、INSERT 和 DELETE。 这两种类型的读取提供了事务处理数据的灵活方法。事务是否要看到数据库在事务开始时的状态，或者要看到最新数据，包括其他事务所做的更改，取决于使用哪种类型的读取。 主题：在 MySQL 中管理死锁现在，让我们探讨 MySQL 的 MVCC 中的另一个关键方面——处理死锁。 死锁发生在两个或多个事务同时持有和请求锁时，创造了一个循环依赖，无法解决。 无处理，这些事务可能会永久等待，显然不是理想的。 MySQL 处理死锁的方法是使用等待图。简单地说，当事务 A 等待事务 B 释放行锁时，就在 A 和 B 之间添加一条边。 如果添加这条边创建了一个循环，则检测到死锁。 在检测到死锁后，MySQL 需要解决它。它通过选择一个事务作为“受害者”并回滚它来完成。 在大多数情况下，它选择已经做了最少工作的事务，以便少量的工作被丢弃。 回滚受害者事务后，死锁就被解决了。 在 MySQL 中，您可以使用 SHOW ENGINE INNODB STATUS; 来获取有关最近死锁的信息，这可以帮助调试。 死锁管理，尽管大多数自动，要谨慎地处理事务的设计和执行。建议尽可能地缩短事务并尽可能地提交它们，以减少死锁的可能性。 主题：MVCC 性能影响尽管 MySQL 的 MultiVersion Concurrency Control (MVCC) 在内部为并发访问提供了许多好处，但要识别 MVCC 不是无价的。 让我们来探讨一些这些： 磁盘空间: 其中一个主要开销是增加的磁盘空间。 由于 MVCC 保存不同版本的行以提供隔离、一致的视图给事务，需要更多的磁盘空间。 这可能会在重读写混合的工作负载中显著。 CPU 和 I/O 资源: 生成多版本的数据、维护它们并清理不必要的版本 (垃圾回收) 可能会耗费 CPU 和 I/O 资源。 锁定开销: 尽管 MVCC 减少了锁定，它并不完全消除了，特别是对写事务 (插入、更新、删除) 的锁定。 这些锁定增加了性能开销。 增加复杂性: MVCC 增加了数据库引擎的复杂性。 它需要管理多版本的数据、处理回滚、解决冲突和清理旧版本。 这种复杂性增加了整体性能的开销。 在哪些场景中可能考虑替代 MVCC？ 虽然 MVCC 为多用户访问提供了出色的好处，但它可能不是每个场景的最佳选择。 例如，在大量写入一次并多次读取的应用程序中，可能更好地考虑 MyISAM 存储引擎，它不支持 MVCC。 此外，在要求绝对最新数据的应用程序中，也可能要考虑其他方法，因为 MVCC 提供了数据的“快照”，而不是最新版本。 要了解工作负载、性能期望和硬件资源可用性之前，就要考虑使用 MVCC 的决定。 主题：回并评估现在，让我们回和总结 MySQL 中 MultiVersion Concurrency Control (MVCC) 的不同方面： MVCC 是数据库管理系统中用于处理并发事务的方法。 MVCC 在 MySQL 中提供每个事务的“快照”，允许多个事务同时读取（并写入）同一数据项，大大提高了数据库的性能和可伸缩性。 快照读和当前读是 MySQL 中 MVCC 的两个关键概念。快照读提供事务开始时数据的一致视图，并确保事务使用了一致的数据状态。当前读是指考虑其他事务已提交的最新数据的一种读取方式。 MVCC 与数据库的 ACID 属性密切相关，确保事务的原子性、一致性、隔离性和持久性。 MVCC 在 MySQL 中处理死锁，这是两个事务等待对方释放资源的情况。 虽然 MVCC 提供了许多优势，但它也不是完全免费的，例如增加磁盘空间和 CPU 使用量。 这些是我们在 MySQL 中讨论 MVCC 的多个方面。现在，就是时候评估你的理解了。考虑以下问题： MVCC 如何在 MySQL 中提高并发事务？ MySQL 中 MVCC 的快照读和当前读有什么区别？ MVCC 在 MySQL 中是如何处理死锁的？ MVCC 在使用时会带来哪些性能交换？ 思考这些问题。您可以在纸上写下回答或者简单地为自我评估思考。 MVCC 通过允许多个用户同时访问同一行的表来提高并发事务。每个事务都会获取数据的一致状态，在事务开始时。 在 MySQL 中，快照读和当前读是两种不同的读取隔离级别。快照读是指事务读取数据库状态的一致快照，确保事务内部的数据一致性。当前读是指考虑其他事务已提交的最新数据的一种读取方式。 MVCC 在 MySQL 中处理死锁通过 wait-for 图来处理。当一个事务等待另一个事务释放锁时，会在 wait-for 图中添加一条边。如果添加这条边创造了一个循环，则会检测到死锁。MySQL 会选择一个事务作为“受害者”并回滚它来解决死锁。 MVCC 与数据库的 ACID 属性密切相关，确保事务的原子性、一致性、隔离性和持久性。 English post: https://programmerscareer.com/mysql-interview17/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview17/"},{"title":"MySQL面试问题:MySQL常用的存储引擎有哪些?有什么区别?","text":"这里是MySQL存储引擎学习计划的详细课程 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：1.1 MySQL存储引擎简介在 MySQL 中，存储引擎是数据库管理系统使用的底层软件组件，负责创建、读取、更新和删除（CRUD）数据的管理。简单来说，它就是负责数据库中信息的管理。您可以将其视为与磁盘上的文件系统类似的组件。 每个 MySQL 数据库中的表都是使用特定的存储引擎创建的。 MySQL 提供了多种存储引擎，例如 InnoDB、MyISAM、MEMORY 等，可帮助我们选择最合适的一种。 与数据库交互时，我们主要不需要关心存储引擎——我们可以只关注写 SQL 查询。但是，存储引擎的选择会影响数据库的各种特性，例如： 事务支持： 事务允许多次数据修改在数据库中处理为一个单元的工作，或者所有数据修改都被提交到数据库中，或者未被提交。 InnoDB 支持事务，MyISAM 不支持。 锁定级别： 锁定防止多个进程相互干扰。不同的存储引擎使用不同的锁定机制，从行级到表级锁定。 数据持久性和崩溃恢复： 这是数据库在崩溃或电源失败时的恢复能力。 InnoDB 具有强的数据持久性和崩溃恢复能力。 您可能正在问：可以在一个数据库中使用多个存储引擎吗？ 是的！事实上，每张表可以使用不同的存储引擎。 主题：1.2 了解 InnoDB 引擎InnoDB 是 MySQL 的默认存储引擎。它提供了标准的 ACID 事务特性，并且具有行级锁定和外键关系。这些是为什么它在数据完整性和性能方面非常受欢迎的原因。 让我们来详细了解这些特性： ACID 兼容性： ACID 是事务处理的关键概念。它保证数据的完整性和可靠性，并且确保数据在所有操作中保持一致和可靠。 行级锁定： 与 MyISAM 中的表级锁定相比，InnoDB 使用行级锁定，其中每行被修改的过程中锁定该特定行，并允许其他进程修改其他行。 外键关系： 外键强制在数据库中相关的表之间维护引用完整性。换句话说，它帮助防止破坏链接之间的表。 InnoDB 还具有崩溃恢复能力。这意味着 InnoDB 可以自动修正因预 mature 关闭或主要故障而导致的任何不一致性。 在性能方面，InnoDB 使用多版本并发控制（MVCC）来避免在执行 SELECT 语句时需要读锁定。这是在具有忙站点的繁忙网站上非常有帮助的，因为 SELECT 语句非常常见，并且数据完整性是至关重要的。 主题：1.3 了解 MyISAM 引擎MyISAM 是 MySQL 中最早的存储引擎之一，在 MySQL 版本 5.5 之前，MyISAM 是默认的存储引擎。MyISAM 有一些特别的特性和用例，使它在特定的场景中非常有效。 MyISAM 使用完整的表级锁定来处理 INSERT、UPDATE 和 DELETE 操作。这意味着当行被写入或更新时，整个表，该行是一部分，被锁定，并且其他操作不能在同一表上写入，直到写入或更新过程完成。 虽然这可能被看作是 InnoDB 所提供的行级锁定的缺点，但在读操作远远多于写操作的场景中，表级锁定是完美的。例如，在博客或网站上，大多数时间你只是显示数据，并且数据更新非常少频。 另一项重要特性是 MyISAM 支持全文搜索索引，允许自然语言搜索在字符字段中。虽然 InnoDB 现在也支持这个特性了，但 MyISAM 曾经是全文搜索的主要选择很长时间。 然而，MyISAM 不支持事务和外键约束，这可能是某些应用的重大缺点。此外，它缺少崩溃恢复，因此崩溃可能会导致数据丢失或数据损坏。 主题：1.4 其他 MySQL 存储引擎除了 InnoDB 和 MyISAM 之外，MySQL 还提供了其他存储引擎，每个引擎都有其特别的优势和最佳使用案例。让我们来了解一下： MEMORY 引擎： 名字就说明了，这个引擎保存所有数据在内存中，提供了非常快的数据访问时间。但是，请记住，使用 MEMORY 引擎的表中的数据在服务器关闭或崩溃时会丢失。它非常适合存储会话或临时数据。 CSV 引擎： 这个引擎允许您以逗号分隔值 (CSV) 格式访问数据。您甚至可以使用任何文本编辑器来查看和编辑表中的数据。它不支持索引，因此每行搜索都是全表扫描。 ARCHIVE 引擎： 如果您需要存储大量未索引的数据，例如日志，这是您所需要的引擎。它使用压缩来节省空间并以易于备份和传输的方式存储数据。虽然 ARCHIVE 引擎允许简单的 SELECT 和 INSERT 语句，但它不支持事务或能够删除或更新记录。 BLACKHOLE 引擎： Blackhole 引擎接受数据，但丢弃它并不存储它。您可能会问，为什么它有用？Blackhole 引擎用于复制到多个从服务器，并且还用于数据库服务器的审计日志。 FEDERATED 引擎： Federated 存储引擎允许您访问位于其他数据库上的表。它提供了能够创建一个逻辑数据库的能力，其中包含多个物理服务器。 每个这些引擎都有独特的功能和适用于不同场景的最佳使用案例。这就是 MySQL 的可插拔存储引擎架构的美妙之处——您可以选择最适合您需求的一个。 主题：1.5 存储引擎比较MySQL 的多种存储引擎，每个存储引擎具有独特的特性集，使其成为适应各种工作负载的灵活选择。现在，我们将比较这些存储引擎，探讨其强项和弱项，并建议适合的场景。 InnoDB vs. MyISAM：在写操作密集或要求事务的工作负载中，InnoDB优于 MyISAM，因为它提供 ACID 事务特性、行级锁定和崩溃恢复。然而，如果工作负载是读密集，并且事务的持久性或原子性不是关键问题，MyISAM可能是有意义的选择。 InnoDB/MyISAM vs. MEMORY：MEMORY 存储引擎通过在内存中存储所有数据来提供 lightning-fast 数据访问，适合存储临时或会话数据。然而，与 InnoDB 和 MyISAM 不同，所有数据在服务器关闭或崩溃时都会丢失。 InnoDB/MyISAM/MEMORY vs. CSV：CSV 存储引擎使数据处理变得更加简单和灵活，因为它允许在任何文本编辑器中编辑数据。然而，由于缺少索引，因此对每行搜索可能会进行全表扫描，并且可能不是对大型工作负载的有效解决方案。 InnoDB/MyISAM/MEMORY/CSV vs. ARCHIVE：当处理大量 seldom-referenced 数据时，例如日志或历史事务，ARCHIVE 存储引擎具有优势，因为它通过压缩数据来节省存储空间。 InnoDB/MyISAM/MEMORY/CSV/ARCHIVE vs. BLACKHOLE 和 FEDERATED：这两个存储引擎相对较特殊，与其他存储引擎相比较：BLACKHOLE 可能有助于审计日志或多主复制，而 FEDERATED 可能有助于创建逻辑上的单个数据库来自多个物理服务器。 记住，选择正确的存储引擎主要取决于您的特定工作负载和应用要求。 主题：1.6 选择正确的存储引擎选择正确的存储引擎对设置 MySQL 数据库至关重要，因为它可以大大影响应用的性能和可靠性。下面是要考虑的因素： 数据完整性：如果您的应用要求高数据完整性，并且事务需要原子性（所有或者没有），您应该考虑使用 InnoDB 存储引擎，它支持 ACID（原子性、一致性、隔离性、持久性）特性。 全文搜索：如果您计划运行全文搜索查询，MyISAM 和 InnoDB 都支持这些，但具有不同的特性。您需要独立地探索这些特性，以确定它们是否适合您的使用情况。 内存使用：如果您需要最大的读/写速度，并且数据是临时的（例如会话数据），MEMORY 存储引擎，它将所有数据存储在内存中，可能是最佳选择。 大量数据：处理大量 seldom-referenced 或历史数据时，考虑 ARCHIVE 存储引擎，它通过压缩数据来有效地存储数据。 读/写操作比率：评估应用的读/写操作比率。如果读操作明显多于写操作，您可能会从 MyISAM 中受益。然而，InnoDB 更适合写密集的应用。 服务器故障：考虑发生故障时的情况是至关重要的。如果数据持久性是关键问题，InnoDB 应该是您的选择，因为它可以通过事务日志恢复从故障中。然而，MyISAM 不保证数据持久性在故障时。 主题：1.7 回顾和评估在我们的上一课中，我们深入了解了 MySQL 的各种存储引擎，了解了它们的独特特性并比较了它们基于某些标准。我们已经： 定义了存储引擎是什么并讨论了它们在 MySQL 中的角色。 了解了 InnoDB 和 MyISAM 存储引擎的特性和优势。 探索了其他 MySQL 存储引擎，例如 MEMORY、CSV 和 ARCHIVE 等。 比较了这些存储引擎，以了解它们的最佳使用场景。 讨论了在选择正确的存储引擎时要考虑的因素。 让我们测试一下你的理解，在我们结束这个系列之前： 问题 1： InnoDB 与 MyISAM 有什么区别，并且在哪些情况下可能会更喜欢使用其中一个？ 问题 2： 描述一种情况，在哪里使用 MEMORY 存储引擎可能会有所帮助？ 问题 3： 如果您有存储大量日志数据的要求，您将选择哪个存储引擎，并且为什么？ 问题 4： 在选择数据库时要考虑的几个因素是什么？ 请按顺序回答这些问题。 答案 1： InnoDB 是一个存储引擎，它提供了 ACID（原子性、一致性、隔离性、持久性）完整性支持的事务功能，并且在写密集的应用或需要高数据完整性的场景中非常有用。然而，MyISAM 通常用于读密集的应用，因为它具有更快的读操作。然而，请记，MyISAM 不支持事务和崩溃安全性功能。 答案 2： MEMORY 存储引擎可能会在处理临时数据时非常有用，例如会话数据。因为所有数据都存储在内存中，并且比磁盘存储更快，它提供了极快的访问时间。然而，请记，所有使用此存储引擎的数据在服务器终止或崩溃时都会丢失。 答案 3： ARCHIVE 存储引擎可能会在处理大量偶尔引用数据或日志数据时非常有用。这个存储引擎支持压缩，可以节省大量的存储空间。 答案 4： 在选择数据库时要考虑的因素可能包括： 数据库主要处理的操作类型（读操作或写操作）。 事务支持和崩溃安全性机制是否是必需的。 数据量和接受的访问/读写速度。 特定功能，例如全文索引或 GIS 功能。 English post: https://programmerscareer.com/mysql-interview18/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview18/"},{"title":"MySQL面试问题:假设创建一个复合索引(a, b, c)，如果查询字段a和c，会使用这个复合索引吗?","text":"让我们创建一个以MySQL为重点的课程计划，特别是理解复合索引的应用 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：1.1 MySQL的复合索引介绍复合索引，也称为联合或多列索引，是数据库表中两个或多个列组成的索引。这些列按照特定的顺序排列，并由此列的顺序所导向。 以图书馆为例，单列索引就像根据作者的名字来排列书籍。而复合索引就像根据作者和书名来排列书籍。 在 MySQL 中，复合索引起着非常重要的作用，帮助提高数据库操作的效率。要了解的是，MySQL 可以使用复合索引来加速包含任何列的查询，但是它的效率最高是在使用左侧前缀的索引列表中。 MySQL 复合索引的一个重要特性是“左侧前缀”。在复合索引中，列的顺序很重要。例如，在复合索引 (a, b, c) 中，MySQL 可以使用这个索引来加速包含 ‘a’ 或 ‘a 和 b’ 的查询，但不能使用 ‘b 和 c’，因为 ‘b 和 c’ 不是复合索引的左侧前缀。 复合索引可以大大提高查询的性能，但是它们的有效使用取决于如何查询数据。 主题：1.2 创建复合索引在 MySQL 中创建复合索引与创建单列索引的语法有些差异。 下面是创建复合索引的基本语法： 12CREATE INDEX index_name ON table_name(col1, col2, ...); index_name 是您想要为索引命名的名称。 table_name 是要创建索引的表的名称。 (col1, col2, …) 是要包含在索引中的列的名称，按照您希望它们出现的顺序排列。 让我们考虑一个具体的例子。 假设有一个 sales 表，其中包含 ProductID、OrderDate 和 Region 列。 如果您经常执行过滤或排序操作，并使用 ProductID 和 OrderDate，复合索引将会有所帮助。 下面是如何创建它： 12CREATE INDEX idx_sales ON sales(ProductID, OrderDate); 在上面的例子中，idx_sales 是一个复合索引，在 sales 表上包含 ProductID 和 OrderDate。 索引的顺序很重要，因为 MySQL 将使用索引来加速包含 ProductID 的查询，或者包含 ProductID 和 OrderDate 的查询，但不是 OrderDate 的查询。 要记住的是，使用复合索引来提高查询性能是有代价的。 虽然它们可以大大提高查询性能，但它们可能会慢下来写操作（例如，INSERT、UPDATE、DELETE），因为 MySQL 必须更新索引。 要优化数据库性能，需要找到一个合理的平衡。 主题：1.3 查询字段 A 和 C本主题讨论了一个重要的问题：如果你只查询字段 A 和 C，MySQL 会使用复合索引 (a, b, c)？ 答案主要取决于 SQL 查询和索引的结构。如果 WHERE 子句中使用的列是复合索引的前 N 个连续列，则可以使用索引。因此，如果你在复合 (a, b, c) 索引中查询字段 A 和 C，但不查询字段 B，索引可能不会很有效。 例如，考虑下面的复合索引： 12CREATE INDEX comp_index ON table(a, b, c); 并且假设我们有这样的查询： 123SELECT * FROM table WHERE a = 1 AND c = 3; 在这种情况下，MySQL 将只使用字段 a 的索引，并忽略字段 c 的索引，因为字段 c 不是与字段 a 在复合索引的左侧前缀中连续的。 为了确保字段 a 和 c 的索引被使用，您可以重构复合索引为 (a, c, b) 或 (c, a, b)，并相应地调整查询。主要是 WHERE 子句中的字段应该与复合索引的左侧前缀中的字段对齐。 请记，总是一个好主意定期分析查询的性能并根据需要调整索引。MySQL 的 EXPLAIN 语句是一个有用的工具来了解如何查询与索引的交互。 在下一节中，我们将学习如何优化 MySQL 中的复合索引来获取更好的结果。 主题：1.4 复合索引优化优化 MySQL 中的复合索引可以显著提高数据库查询的效率和速度。记住，有效地实现索引可以节省时间、资源并提高整个应用的性能。 下面是优化复合索引的几个关键点： 索引列的顺序： 索引列的顺序可能会有显著的差异。如果 WHERE 子句中使用的列与复合索引的左侧前缀中的列对齐，MySQL 可以高效地使用索引。如果 WHERE 子句中使用了多个列，您可能会得到多个索引或复合索引，选择这些选项取决于特定的应用要求。 索引卡 Cardinality： 索引卡 Cardinality 是索引值的多样性。索引列中具有更高卡 Cardinality 的列会导致更少的行扫描并提高查询性能。因此，在复合索引中，列的优先级应该是从左到右的。 等式与范围条件： 在复合索引中，MySQL 可以对所有列进行等式检查，并对最后一列进行范围检查。如果 WHERE 子句中的范围条件位于中间，MySQL 不能使用右侧的索引部分。 过度索引： 虽然索引可以加速数据检索，但它会慢下数据修改操作（如 INSERT、UPDATE 和 DELETE）的速度，因为每次修改索引列数据都需要更新索引结构。确保您不会过度索引表格——每个索引都应该有目的。 使用 EXPLAIN： MySQL 的 EXPLAIN 关键字显示优化器如何选择索引来执行查询。定期使用 EXPLAIN 来了解如何查询与索引的交互。 主题：1.5 回顾和评估在会话中，我们学习了 MySQL 中的复合索引的结构和区别，并学习了创建复合索引的语法并演示了一个例子。我们然后探讨了如何通过特定的字段，例如 A 和 C，来查询复合索引。我们进一步深入了解了如何优化使用复合索引的方法。 我们学习的关键概念包括： 复合索引：它是多列的索引，可以显著加快查询执行的速度。 创建复合索引：我们学习了语法并演示了一个例子。 查询 A 和 C 字段：我们观察到 MySQL 只能使用索引中的列的左到右的部分，并且不会跳过任何列，只要 WHERE 子句中的列被引用。 复合索引优化：我们学习了优化复合索引的有效技巧和技巧，包括索引列的顺序、索引卡inal性、区分等式和范围条件、避免过索引和使用 EXPLAIN 关键字。 现在是时候评估你对复合索引的了解了。 例子问题： 假设你是运营一个线上书店，书库中有千千本书。主要的 books 表在 MySQL 数据库中具有以下列：id, title, author, genre, publication_year 和 price。你发现自己经常执行以下查询： 123SELECT * FROM books WHERE genre = '科幻' AND publication_year = 2018; 为了优化这个查询，你创建了以下复合索引： 12CREATE INDEX genre_year_index ON books (genre, publication_year); 这个复合索引应该会使你的常用查询变得更快。 现在，它是你的回合！ 问题：圣诞节到来了，你的商店正在为许多书籍提供折扣。你打算通过电子邮件向所有购买了《科幻》书籍发表后 2010 年的用户发送邮件。从 orders 表中获取用户 ID 列表，该表具有以下列：order_id, user_id, book_id, order_date。假设还有一个名为 orders_books 的中间表具有 order_id, book_id。 要从 orders 表中获取购买了《科幻》书籍发表后 2010 年的用户 ID，我们可以使用 JOIN 来合并 orders、orders_books 和 books 表中的信息。 您的 SQL 查询可能会像下面这样： 12345SELECT DISTINCT o.user_id FROM orders AS o JOIN orders_books AS ob ON o.order_id = ob.order_id JOIN books AS b ON ob.book_id = b.id WHERE b.genre = '科幻' AND b.publication_year &gt; 2010; 这个查询检查每个订单中的书的类别和出版年份，并返回用户 ID，其中匹配了条件。 DISTINCT 关键字用于删除结果集中的重复 user_id。 记住，了解数据的结构和如何相互关联是在使用 SQL 和数据库时至关重要的。同时，确保为您的查询设置了正确的索引是至关重要的。 English post: https://programmerscareer.com/mysql-interview19/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview19/"},{"title":"MySQL面试: 简述数据库中的 ACID 分别是什么？","text":"我将为学习MySQL准备一个主题概述，特别关注数据库中的ACID属性。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：1.1 ACID 理论ACID（原子性、一致性、隔离性和持久性）是一个缩写词，用于定义一组属性，确保数据库操作的可靠处理，尤其是在事务模型中。 ACID的元素代表： 原子性：这意味着事务必须被视为一个单位，它要么完全成功，要么完全失败。如果事务中的任何部分失败，则整个事务失败，并且在事务期间所做的更改被回滚（返回到其前一个状态）。 一致性：一致性确保事务将数据库从一个有效状态带到另一个有效状态。它不允许事务将数据库留在一个不一致的状态。 隔离性：隔离性确保事务安全地和独立地在同一时间内处理，而不会相互影响。 持久性：名字所暗示的，持久性确保提交事务的结果或效果在未来的系统故障后仍然有效。 这些基本属性使数据库在所有事务中维持数据完整性和一致性。 主题：1.2 ACID 实践ACID属性在MySQL数据库中极其重要，确保数据的可靠性和完整性。现在，让我们看看它们在实践中是如何工作的。 原子性：MySQL 通过事务来确保原子性。在MySQL数据库中，事务是一组SQL语句，以单一的单位执行。这意味着事务中的所有SQL语句都要么全部执行，要么全部不执行。如果在事务过程中发生任何故障，则在事务期间所做的更改被回滚，并将数据库返回到其前一个状态。 一致性：MySQL中的一致性属性确保只有遵循所有规则和约束的有效数据被写入数据库。如果事务导致无效数据，则整个事务被回滚，数据库保持不变。这确保了数据库从一个有效状态到另一个有效状态的过渡。 隔离：在MySQL中，并发事务与其他事务隔离。这意味着事务的执行不会影响其他事务的执行。MySQL使用锁和不同的隔离级别来实现隔离。这防止了脏读、不可重复读和幻影读等问题。 持久性：MySQL通过在事务成功之前将更改永久写入磁盘存储来确保持久性。这意味着一旦用户收到事务成功的通知，他们就可以确信事务已经永久记录并且在任何后续服务器故障或重启之后都会存在。 了解这些时，重要的是要注意MySQL允许您根据应用程序的需求定义事务边界，提供不同的配置选项。 主题：1.3 MySQL中的原子性原子性是ACID数据库系统中的关键属性。它确保事务被视为一个单位的工作单元，要么完全成功，要么完全失败。没有一个事务被留在部分完成的状态。 在MySQL中，事务通常包含多个SQL命令。原子性保证，如果发生电源故障、系统崩溃或网络问题，那么事务执行后的命令被撤销。这就好像事务从未发生过一样。另一方面，如果所有事务中的命令都成功执行，则认为事务成功提交到数据库。 以下是MySQL事务中原子性的示例： 假设我们运营一家书店，我们正在更新库存和销售记录中的书籍数量。事务可能类似于以下内容： 1234START TRANSACTION; UPDATE Inventory SET Quantity = Quantity - 1 WHERE BookID = 100; UPDATE Sales SET TotalSold = TotalSold + 1 WHERE BookID = 100; COMMIT 在这个事务中，我们有两个UPDATE语句。这两个语句都要成功，以便事务成功提交。如果例如由于系统崩溃或网络错误，则整个事务由于原子性原则被回滚，确保我们的库存和销售记录保持一致。 原子性是一个强大的属性，确保我们的数据库操作是安全可靠的。 主题：1.4 数据库中的一致性数据库系统中的一致性确保数据库事务将系统从一个一致状态带到另一个一致状态。这意味着如果执行一个违反数据库一致性规则的事务，整个事务将被回滚，并且数据库将保持不变。 在MySQL中，一致性由约束系统保留。约束是对表中列的规则，防止无效数据被输入到它们。有几种约束类型，包括： 唯一约束：这确保所有列中的值都是唯一的。 主键约束：这唯一地标识表中的每一条记录。 外键约束：这维护引用完整性，确保两个表之间的链接是有效的。 不为空约束：这确保列不能有NULL值。 检查约束：这确保所有列中的值满足特定条件。 以下是一个示例，展示了唯一约束如何确保一致性： 1234567CREATE TABLE Employees ( ID int NOT NULL, Name varchar(255) NOT NULL, Age int, PRIMARY KEY (ID), UNIQUE (Name) ); 在上述示例中，UNIQUE (Name)约束确保了两个员工不能有相同的名字，从而促进了一致性。如果我们尝试插入两个具有相同名字的员工，MySQL将不允许这样做，并且数据库的一致性将得到保留。 主题：1.5 数据库中的隔离隔离是ACID中的“I”，意味着每个事务都应该以与其他事务相隔离的方式进行。这意味着一个事务的执行不会影响其他事务的执行。在数据库中，隔离对于防止在事务同时执行时可能出现的一些问题非常重要。 在MySQL中，并发事务由一个特定的机制称为锁定管理。MySQL提供了多种锁类型，包括共享锁（读锁）和独占锁（写锁）。锁的类型取决于事务是读还是写。 MySQL还支持多个隔离级别，包括： 未提交读：最低级别的隔离。事务可以看到其他事务中未提交的更改，通常导致问题如脏读。 已提交读：与其他事务相比，隔离级别较高。事务只能看到其他事务已提交的更改。 可重复读：MySQL中的默认隔离级别。保证单个事务内的所有读取都会返回相同的数据，即使在事务期间发生更改。 可序列化：最高级别的隔离。事务以串行方式执行，即一次只执行一个事务。 以下是隔离在MySQL中的一个示例： 123456789-- 开始一个事务 START TRANSACTION; -- 读取数据 SELECT * FROM table_name WHERE condition; -- 尝试再次读取相同数据将返回相同的结果， -- 无论其他事务是否对数据进行更改 SELECT * FROM table_name WHERE condition; -- 提交事务 COMMIT; 在上述示例中，在可重复读隔离级别下，两个SELECT语句将返回相同的结果，即使其他事务对数据进行更改，因为其他事务对数据的更改在事务提交之前不会对这个事务可见。 主题：1.6 数据库中的持久性在数据库系统中，“持久性”（ACID中的“D”）关注一次事务成功提交后数据的持久性。如果事务已成功提交，持久性保证该事务所做的更改将在任何后续故障（如电源失败、系统崩溃或其他未预期的关机）后仍然存在。 MySQL 确保持久性，在事务更改被实际更改之前，先将所有事务更改写入二进制日志中。这个二进制日志作为历史记录，可以用来从任何时间点重建数据状态。 每次提交事务时，MySQL首先将该事务所做的更改写入二进制日志，然后MySQL开始实际执行更改。如果系统故障发生，MySQL可以回放二进制日志，直到上一个已提交事务，确保所有已提交事务的持久性。 让我们考虑一个更新表中的记录的例子： 123START TRANSACTION; UPDATE Employees SET Salary = Salary + 5000 WHERE ID = 100; COMMIT; 在上述事务中，员工薪资被更新。一旦COMMIT语句执行，更新将在二进制日志中立即写入，在实际更改之前。这确保了，即使在更新后的系统崩溃，该事务也不会丢失。 主题：1.7 在MySQL中的事务控制事务控制是管理ACID属性的方法，并引用用于控制事务的操作和命令。在MySQL中，事务控制命令包括START TRANSACTION，COMMIT和ROLLBACK。 START TRANSACTION：标记事务的开始。 COMMIT：标记事务的结束，并永久保存自上次COMMIT或START TRANSACTION以来所做的任何更改。 ROLLBACK：撤销自上次COMMIT或START TRANSACTION以来所做的任何更改。 以下是在MySQL中的事务控制实际操作的示例： 1234567891011-- 开始一个事务 START TRANSACTION; -- 将数据插入表中 INSERT INTO Customers (Name, Email) VALUES ('John Doe', 'johndoe@example.com'); -- 如果上述语句出现问题，我们可以撤销（反转）事务 ROLLBACK; -- 现在让我们再试一次，这次没有错误 START TRANSACTION; INSERT INTO Customers (Name, Email) VALUES ('John Doe', 'johndoe@example.com'); -- 由于一切顺利，我们现在可以提交事务（完成并保存我们的更改） COMMIT; 在这个示例中，ROLLBACK语句用于反转一个包含错误的事务。一旦问题得到解决，事务再次尝试，并在成功时，COMMIT语句用于完成并保存更改。 事务控制帮助维护ACID属性，因为它为将一个或多个语句组合成一个事务提供了能力，从而提供了更大的控制权，确保数据完整性。 主题：1.8 在MySQL中的高级主题了解ACID原则及其如何在MySQL中实现后，您可能还想探索更多高级主题，以提高您的MySQL专业知识。一些值得注意的领域包括但不限于： 索引：MySQL中的索引用于加速从数据库中检索数据的速度。数据库中的索引与书中末尾的索引类似，它们帮助您更快地找到信息。 存储过程：这些是预先编写的SQL语句，以名称存储并以单元形式执行。它们有助于避免重复编写经常需要的SQL代码。 数据类型：MySQL具有多种数据类型，以适应各种数据。从字母数字字符串、日期和时间、数值到更复杂的数据类型，如JSON和空间数据类型都有在MySQL中的可用性。 处理NULL值：MySQL数据库中的NULL值可能很困难。它们表示缺失或未知的数据。MySQL提供了多种函数，如IS NULL、IS NOT NULL、IFNULL()和COALESCE()，以处理NULL值。 连接和联合：连接用于将两个或多个表的行组合在一起，基于相关列。它们在数据库中经常使用，因为很少有一个表中包含所有需要的数据。联合用于将两个或多个SELECT语句的结果集组合在一起。 安全：处理用户权限和安全连接到MySQL数据库是任何数据库管理的重要部分。 **主题:**1.9 回顾和评估这是我们在这些课程中学到的概述: 理论中的ACID: 我们学习了ACID属性(原子性、一致性、隔离性、持久性)及其在数据库系统中的重要性。 实践中的ACID: 我们超出了理论,了解如何在MySQL中实现这些属性,以及它们如何确保数据完整性和一致性。 MySQL中的原子性: 我们探索了原子性,并通过实际示例了解了它如何确保数据库操作要么完全完成,要么不发生。 MySQL中的一致性: 我们学习了MySQL如何确保数据在任何SQL操作之前和之后保持一致。 MySQL中的隔离: 我们讨论了隔离的概念及其在并发数据库处理中的重要性。 MySQL中的持久性: 我们学习了持久性在MySQL数据库中的含义,并观察了MySQL如何确保数据更改在任何后续故障后仍然存在。 MySQL中的事务控制: 我们了解了如何使用事务控制在MySQL中管理ACID属性。我们主要了解了START TRANSACTION、COMMIT和ROLLBACK命令的使用。 MySQL的高级主题: 我们深入了解更高级的主题,如索引、存储过程、数据类型等,以扩展我们对MySQL的理解。 我建议重新查看这些主题,并确保对它们有坚定的理解。 以下是测试您关于ACID属性和MySQL事务控制理解的一些评估问题: 问题1: 在MySQL中,什么是原子性?它在实践中如何实现? 问题2: 在MySQL中,一致性的含义是什么,以及MySQL如何确保数据在任何SQL操作之前和之后保持一致? 问题3: 如何在MySQL中,特别是在并发数据库处理期间,实现隔离? 问题4: 在MySQL中,持久性属性的含义是什么? 问题5: 在MySQL中,关于事务控制,讨论START TRANSACTION、COMMIT和ROLLBACK命令的重要性。 答案1:在MySQL中,原子性表示一个事务必须被视为一个不可分割的单位,这意味着要么它完全完成,要么不执行。在实践中,MySQL通过START TRANSACTION、COMMIT和ROLLBACK命令实现原子性。如果事务被提交,则所做的更改都是永久的。如果事务被回滚,则没有任何更改。 答案2:在MySQL中,一致性确保所有数据更改都将将数据库从一个有效状态带到另一个,维持数据库规则和完整性。MySQL使用多种机制来确保一致性。这些包括定义的表架构,预定义规则,触发器和约束,如主键,外键,唯一,不为空和检查约束。 答案3:在MySQL中,隔离确保并发执行事务的结果使系统状态变为如果事务以顺序执行,即一次执行一个。MySQL通过多种隔离级别和锁定机制实现隔离。 答案4: 在MySQL中,持久性属性的含义是一旦事务被提交,它将保持不变,即使在系统故障,电源损失,崩溃或错误等情况下。这通常通过使用数据库备份和事务日志来实现,这些日志可以用于恢复数据库在故障发生前的状态。 答案5:在MySQL中,START TRANSACTION表示操作的开始点。COMMIT表示当前事务中所做的更改被永久化。ROLLBACK表示如果在处理任何SQL命令时发生错误,则已执行的SQL命令将被撤销以维护数据库完整性。这些命令共同帮助在MySQL设置中管理ACID属性期间的事务。 English post: https://programmerscareer.com/mysql-interview2/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview2/"},{"title":"MySQL 面试：MySQL 如何设计索引，如何优化查询？","text":"让我们详细设计一门深入理解 MySQL 的课程，特别是索引设计和查询优化方面的课程。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：MySQL 概述 数字世界的一个重要部分是数据库，MySQL 是其中的一位明星。那么，MySQL 到底是什么呢？ MySQL 是一个关系数据库管理系统。但是，MySQL 与其他数据库管理系统有什么区别呢？它是开源的，这意味着任何人都可以使用和修改它。这导致了全球范围内开发人员和组织的广泛采用。 你经常会看到 MySQL 支持网站和应用程序的数据需求，甚至在科学研究中起到了帮助作用。它的灵活性在支持各种数据类型和提供了大量用于数据操作和提取的函数方面显著。它的强大安全系统也巩固了其在数据库领域的重要性。 MySQL 的可靠性和速度在数据检索和管理方面是众多数据库管理系统中的一个明星。 MySQL 的核心是结构化查询语言（SQL），它为用户提供了操作数据库的能力。我们可以创建、检索、更新和删除数据，并执行其他复杂分析通过 SQL 命令。 在我们的课程中，我们将帮助您熟悉 SQL，包括基本和更复杂的命令，并进行进一步的学习。 了解 MySQL 是了解以后主题，例如数据库架构、数据库设计的原则和特定主题，例如索引设计和查询优化，的先决条件。 主题：SQL in MySQL&nbsp;(Basics) SQL，或结构化查询语言，是所有关系数据库管理系统的基石，包括 MySQL。它是我们与数据库交互和通信的语言。让我们来看看您需要了解的一些基本 SQL 命令，以便与 MySQL 数据库交互。 SELECT: 这是我们最常使用的命令——它允许我们选择数据库中的数据。例如，SELECT * FROM people; 将选择并显示所有数据从 “people” 表中。或者，您可能希望选择特定列，例如，先名和姓氏：SELECT firstname, lastname FROM people;。 INSERT INTO: 这个命令允许我们插入新数据到数据库中。例如，INSERT INTO people (firstname, lastname) VALUES('John', 'Doe'); 将插入一个新人，其名字为 John，姓氏为 Doe。 UPDATE: 就名称所言，使用这个命令可以更新现有数据。例如，UPDATE people SET age=30 WHERE firstname='John' AND lastname='Doe'; 将更新所有名为 John Doe 的人的年龄为 30。 DELETE: 请谨慎使用此命令，因为它会删除数据！例如，DELETE FROM people WHERE firstname='John' AND lastname='Doe'; 将删除所有名为 John Doe 的记录。 CREATE, ALTER, DROP: 这些命令用于操作数据库的架构或结构本身，并不是存储的数据。CREATE 允许我们创建新表，ALTER 允许更改表的结构，DROP 删除表。 熟悉这些命令将为您提供一个良好的基础，以深入探讨更复杂的 SQL 命令在 MySQL 中的使用。 请记在运行这些命令并了解其结果时练习。 主题：MySQL中的高级 SQL 虽然基本的 SQL 命令提供了一个坚实的基础，但是真正理解和利用 MySQL 的更高级工具来处理数据库是如此重要。下面是一些高级 MySQL 命令，可以帮助您更有效地操作数据库： JOIN：SQL 的 JOIN 子句允许您根据公共字段组合来合并表的行。JOIN 命令有多种类型，例如 INNER JOIN、LEFT JOIN、RIGHT JOIN 和 FULL OUTER JOIN 等。例如：SELECT Orders.OrderID, Customers.CustomerName FROM Orders INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID; 这条命令将显示订单 ID 和客户名称从 Orders 和 Customers 表中，其中客户 ID 匹配。 GROUP BY：这个命令与聚合函数 COUNT、MAX、MIN、SUM 和 AVG 一起使用，用于根据一个或多列来分组结果集。例如：SELECT COUNT(animal_type), animal_type FROM animal GROUP BY animal_type; 这条命令将显示每种动物类型在 ‘animal’ 表中的数量。 HAVING：这个命令类似 WHERE 子句，但是适用于聚合函数。例如：SELECT COUNT(product_id), product_name FROM products GROUP BY product_name HAVING COUNT(product_id) &gt; 5; 这条命令将显示来自 ‘products’ 表的产品名称和数量，但只显示数量大于 5 的产品名称。 UNION：UNION 操作用于合并两个或多个 SELECT 语句的结果集。每个 SELECT 语句内部必须有相同数量的列，并且列必须具有相似的数据类型。例如：SELECT column_name(s) FROM table1 UNION SELECT column_name(s) FROM table2; CASE：这个命令允许 SQL 中的条件语句。例如：SELECT CASE WHEN age &lt; 18 THEN 'Children' WHEN age BETWEEN 18 AND 65 THEN 'Adults' ELSE 'Seniors' END AS age_group FROM people; 这条命令根据人们的年龄来分类人们在 ‘people’ 表中。 学习这些命令会为您打开 MySQL 的全部力量。 记住，要真正理解这些，实践是关键。 主题：MySQL 中的数据库架构 在高效的数据库中，架构是至关重要的抽象蓝图，它展示了数据库结构的组织和访问方式。因此，让我们来讨论一下！ 当您想象数据库时，想象一整个文件柜。在 MySQL 术语中，数据库中的表就成为了数据库架构的一部分。它们包含了我们通过 SQL 命令交互的数据。 每个文件柜（或者数据库）中的分区（或者列）被称为列或字段。每个列代表数据库中的一种数据类型。例如，在存储员工信息的表（或者文件柜）中，不同类别的信息，例如员工 ID、姓名、职位等，成为了不同的列。 设计数据库架构可能看起来很简单——为每种数据类型创建一个表，对吧？但是，不！有效地设计架构可以避免冗余，防止数据异常，并优化资源使用。 MySQL 强烈地遵循关系数据库的原则，将数据组织在相互链接的表中。这给我们带来了主键和外键这些概念，帮助建立表之间的连接（我们将在数据库设计课程中进一步讨论）。 主题：数据库设计的原则 设计数据库不仅仅是决定表、列和使用 SQL 命令。一个良好的数据库保证了有效和可靠的数据存储和检索。让我们来讨论一下数据库设计的基本原则： 实体-关系 (ER) 模型：想象一下实体是“事物”或“对象”，与数据库相关（例如公司数据库中的员工）。关系定义了这些实体之间的交互。以图形方式表示这些实体和其关系给我们提供了 ER 模型，这是数据库设计的基本步骤。 规范化：这是组织数据的过程，以消除冗余并提高数据完整性。有多种规范形式（第一、第二、第三、BCNF），每个形式都有其前提条件。 主键：每张表都必须有一个列（或一组列），称为主键，可以唯一地识别表中的每一行。 外键：这是另一张表的主键的字段（或集合）。外键用于防止破坏表之间的链接。 原子性：这是操作完全成功或失败的想法。您不想数据库更新部分完成——它完全成功或不成功。 安全性：数据库通常包含敏感数据。良好设计的数据库具有多层安全性，包括授权、访问控制和加密。 备份和恢复：数据是有价值的。良好设计的数据库包括定期备份策略和有效的恢复，以处理数据丢失。 可伸缩性和性能：良好的数据库设计还考虑了可伸缩性（数据量增长时数据库能否处理？）和性能（系统能够响应查询多快？）。 了解这些原则会为您提供一个能够设计一个健壮、可靠和高效的数据库的能力。 主题：MySQL 索引 MySQL 索引是数据库设计的关键部分，可以大大提高数据库表上的数据检索操作的速度。类似于书的索引，MySQL 索引允许数据库系统找到数据，而无需扫描整张数据库表中的每一行。 下面是关于 MySQL 索引的一些要点： 索引用于更快地找到具有特定列值的行。在没有索引的情况下，MySQL 必须从第一行开始，然后逐行读取整张数据库表，以找到相关的行。 索引还用于强制 UNIQUE 约束，并帮助有效的排序和分组。 索引可以根据其结构分类：B-Tree、哈希、RTree 和 Full-text。 B-Tree（平衡树）是最常用的索引结构，它按顺序排列数据，以便快速检索。 B-Tree 确保树保持平衡，以优化搜索时间。 索引会增加数据库操作的成本。虽然数据检索操作变得更快，但数据修改操作（例如 INSERT、UPDATE 和 DELETE）会变得更慢，因为需要额外的操作来维护索引。 不是所有的字段都需要索引。只有在 WHERE、ORDER BY、GROUP BY 或 JOIN 子句中使用的字段才会受益于索引。 了解和正确实现索引可以大大提高数据库操作的性能。 主题：在 MySQL 中设计索引 在高效的数据库管理中，设计索引是一个重要的部分。今天我们将讨论 MySQL 是如何设计索引的，以及它如何提高整体性能。 创建正确的索引是更多的艺术而不是科学，通常需要查询速度和写入速度之间的权衡。 在设计索引时要考虑的步骤： 选择正确的列： 索引可以包含多列，但是需要考虑列的顺序。MySQL 只能使用索引中的左侧列。 考虑数据类型： 数据类型越小，存储量越小，因此索引也越小，并且查询速度越快。 考虑卡尔性： 具有多个唯一值的列（高卡尔性）通常具有更有效的索引。 了解您的工作负载： 如果您的应用程序执行大量 SELECT 查询，则更多的索引可能有帮助。另一方面，如果您的应用程序执行大量 INSERT、UPDATE 和 DELETE 操作，则更多的索引可能会降低性能。 分析您的查询： 使用 MySQL 的 EXPLAIN 语句来了解如何使用您的索引，并识别可以进行改进的地方。 记住，索引是数据库设计的重要部分。它们可以显著提高数据库的性能，因此在处理大量数据时，总是值得考虑。 主题： MySQL 查询优化 管理数据库的一个重要方面是确保它们运行有效地。当处理大量数据时，查询可能会变得耗时。因此，在 MySQL 中优化这些查询是至关重要的，以提高数据库系统的整体性能。 在 MySQL 中进行查询优化包括多个步骤： 解析： MySQL 开始解析 SQL 查询，以确保其语法正确，并确定数据库对象的存在。 预处理： MySQL 决定表的读取顺序，尤其是多表查询。它还确定要使用的索引。 优化： MySQL 应用多种优化策略，以使查询更有效。最著名的是使用索引，但 MySQL 还利用其他技术，例如合并多个相似的查询，减少临时表，并选择有效的表连接路径。 执行： 最后，MySQL 执行查询并返回结果。实际执行是一个平衡，在从存储引擎获取数据和处理 SQL 命令之间进行。 了解 MySQL 如何优化查询有助于编写更有效的 SQL 代码并设计更好的数据库架构。它可以显著减少查询执行时间，特别是对复杂查询和大数据库的处理。 记住使用 EXPLAIN 语句，它可以提供有关如何优化您的查询的见解。它显示 MySQL 如何计划执行查询，并可能帮助识别瓶颈或改进的地方。 主题：复习和评估经历了 MySQL 的复杂地图后，现在是时候进行详细回并通过评估测试你的实践知识了。 回： 我们开始了 MySQL 的角色，了解 MySQL 作为一个强大的数据库管理系统。 然后我们进入了 MySQL 的本质，了解 1.2 SQL 在 MySQL（基本） 和 1.3 SQL 在 MySQL（高级），掌握了 MySQL 中使用的基本和更复杂的 SQL 命令。 我们学习了数据库的结构，通过 1.4 数据库架构在 MySQL 的概念。 了解 1.5 MySQL 数据库设计原则 帮助我们理解确保数据库有效运行的结构。 我们了解了 1.6 MySQL 索引 的重要性，帮助加快数据检索的速度。 然后我们学习了如何通过 1.7 在 MySQL 中设计索引 来提高性能。 最后，我们探讨了 MySQL 如何通过 1.8 MySQL 查询优化 来提高数据库性能。 如果你想测试你的理解，你可以说 “/test” 来进行评估。请记，这项评估是为了帮助固定你的知识并识别可能需要更多关注的地方。不要太担心它——它是学习的工具，不是最后考试。 让我们开始评估。 问题 1：说出 MySQL 中 CHAR、VARCHAR 和 TEXT 数据类型之间的区别。 问题 2：解释 MySQL 中的 JOIN 操作是什么，并列出其不同类型。 问题 3：在 MySQL 数据库表中，说明 NULL 值是什么，并说明如何检查数据库表中的这些值。 答案 1：CHAR 和 VARCHAR 在 MySQL 中用于存储字符串值，主要区别如下： CHAR 是一个固定长度数据类型，意味着它保留指定的空间，不管数据的实际大小。它在读操作时更快，因为 MySQL 知道 CHAR 列中的值的位置。 VARCHAR 是一个变长数据类型。它根据存储的数据的大小来消耗空间。如果你处理变长的字符串，它可以节省存储空间。 TEXT 也是用于存储字符串的数据类型，但它是为了存储大量文本而设计的。字符串的长度不是固定的，类似于 VARCHAR。 答案 2：MySQL 中的 JOIN 操作是将两个或多个表的行组合在一起，根据它们之间的相关列。 JOIN 的类型包括： INNER JOIN：返回具有匹配值的记录，来自被加入的两个表。 LEFT JOIN (或 LEFT OUTER JOIN)：返回左表的所有记录和右表的匹配记录。如果找不到匹配，右侧的结果为 NULL。 RIGHT JOIN (或 RIGHT OUTER JOIN)：返回右表的所有记录和左表的匹配记录。如果找不到匹配，左侧的结果为 NULL。 FULL JOIN (或 FULL OUTER JOIN)：返回左表或右表的记录，当存在匹配时。 答案 3：在 MySQL 数据库表中，NULL 值表示缺少或未知的数据。你可以使用 SQL 语句中的 IS NULL 或 IS NOT NULL 子句来检查数据库表中的 NULL 值。 记住，当处理 NULL 时，它不是值，它是一个状态，表明值是未知或缺少的，因此 NULL 不等于 NULL。 English post: https://programmerscareer.com/mysql-interview3/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview3/"},{"title":"为什么MySQL使用B+树进行索引?","text":"讨论数据库中索引的重要性，特别是如何提高查询性能。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 1.1 **为什么索引？类似书的索引一样，数据库中的索引帮助我们快速找到数据，无需阅读整本书。索引在数据库表被访问时大大加快数据检索的速度，从而提高应用性能。索引对大表的优化非常重要，尤其是对“SELECT”查询和 WHERE 子句的优化。虽然索引提高了读性能，但它们也会慢下写性能（插入、更新和删除）。这是因为每次数据变化时，索引都需要更新。因此，有过多的索引可能会影响数据库性能。总之，一个好的索引是创造一个平衡。我们想要保持查询快速和有效，但不要过载系统并使其性能受到损害的索引维护。 1.2 MySQL 中的索引类型：MySQL 使用各种索引类型来提高查询性能。下面是常见的类型： 主键索引（Primary Index）：这种索引要求列只能包含唯一、非空值。每张表只能有一个主键索引。 唯一索引（Unique Index）：如果列不包含 NULL 值，这种索引防止字段具有重复值。除了允许 NULL 值外，唯一索引与主键索引几乎相同。 索引（或普通索引）：它允许重复和 NULL 值在列中。它是 MySQL 中的基本索引类型。 全文索引（Full-text Index）：如果你处理文本数据并经常使用全文搜索，这种索引非常有用。 复合索引（或多列索引）：如果在 WHERE 子句中使用多列，创建复合索引可以加快查询性能。 这些索引类型为我们创建或管理的数据库提供了不同的优势，并帮助我们确保数据库性能尽可能优化。 1.3 B+ 树解析B+ 树是一种自平衡搜索树，它维护有序数据并允许高效的插入、删除和搜索操作。与二叉搜索树（BST）不同，B+ 树是多层次的树，每个节点可以有多个子节（通常大于两个）。B+ 树的重要特性包括： 所有数据都存储在叶节点中。 所有叶节点处于同一深度，确保平衡。 所有叶节点都相连，允许有效的范围查询。 非叶节点存储复制的键来指导搜索。 B+ 树的组合特性使它们特别适合处理大量数据和大量读操作的系统，例如数据库或文件系统。 每个节点在 B+ 树中包含一些键和指针。键用作分隔值，分割其子树。例如，如果节点包含值 [10, 20, 30]，它有四个子节（子树）。 B+ 树中的一个基本属性是，如果节点包含 n 个键，它将有 n+1 个指针（子节）。另一个属性是，所有的 B+ 树键是排序的。 由于 B+ 树的高效性在访问、存储和检索数据方面受到广泛的欢迎，它们与数据库世界，包括 MySQL 密切相关。 主题 1.4: B+ 树的优势让我们深入探讨 B+ 树为数据库带来的优势，特别是 MySQL： 有效的磁盘读写操作: 每个 B+ 树节点包含多个键和指针在同一磁盘块上，这大大减少了读取或写入大范围的数据所需的 I/O 操作。因此，您可以扫描大量数据使用最少的磁盘读取。 更快的搜索时间: 由于 B+ 树是平衡的，所以相等数量的比较都会导致所有叶节点，使数据检索变得更快。搜索操作的时间复杂度为对数级别。 有效的插入和删除: B+ 树的数据结构使其在插入和删除操作时保持平衡和有序。这导致最小的磁盘空间浪费并最大化了性能效率。 升序或降序排序顺序检索: B+ 树的叶节点相互链接，这使得快速的顺序读取变得更加容易，特别是在数据库中。 适用于等式和范围检索: 由于自平衡性和每个页面的最小和最大键，B+ 树非常适合等式和范围查询。 多级索引: B+ 树可以适应多级索引，进一步提高搜索性能并减少磁盘 I/O 操作。 主题 1.5: MySQL 中的 B+ 树索引让我们详细了解 MySQL 中为什么和如何使用 B+ 树进行索引。 在 MySQL 中，特别是使用 InnoDB 存储引擎时，B+ 树用作主索引和辅助索引来提高数据库的性能，主要是通过显著地减少数据访问时间。 这是怎样工作的： 主索引: MySQL 使用 B+ 树作为主索引来唯一地识别每行，其中按主键顺序排列。叶节点存储实际数据，主键值作为指针来访问数据。因此，当直接搜索主键时，MySQL 快速地通过 B+ 树来找到并检索数据。 辅助索引: MySQL 表中的辅助索引也是一个 B+ 树。唯一的差异是叶节点不存储实际数据，而是存储主键的指针。因此，当使用辅助索引进行搜索时，MySQL 使用辅助索引的 B+ 树来找到主键，然后使用主键来导航主 B+ 树来获取实际数据。虽然这需要导航两个 B+ 树，但它仍然非常快和有效。 B+ 树在 MySQL 索引中的优势是它大大减少了需要进行磁盘访问的项目数量，这大大提高了性能，因为磁盘访问比内存操作慢得多。 主题 1.6: MySQL 索引最佳实践:基于我们对 B+ 树的了解，让我们来讨论 MySQL 索引的最佳实。有效的索引是绝对必要的，以确保数据库查询运行顺畅和迅速。 了解数据: 在开始索引之前，先深入了解你所处理的数据。哪些列通常一起被查询？哪些列在 WHERE 子句中出现得比较常？这些了解可帮助指导索引策略。 使用 EXPLAIN 关键字: 当优化索引时，使用 SQL 中的 EXPLAIN 关键字来了解数据库是如何解释查询的。这可以为你提供有关 SQL 优化器如何使用索引以及在哪里可以进行改进的见解。 谨慎使用索引的开销: 虽然索引加速了搜索查询，但它们也涉及成本。它们占用空间，并且每次修改表中的数据（INSERT、UPDATE、DELETE）时，索引也需要更新。这可能会慢下来这些操作。 索引 WHERE 子句中使用的列: 经常在 WHERE 子句中使用的列通常是索引的好候选。 有效地使用多列索引: MySQL 允许您在多个列上创建索引。当您创建这样的索引时，MySQL 可以使用它来处理第一列，或者第一和第二列，或者所有列在索引中。 为不同的存储引擎使用适当的索引: 如果您使用 InnoDB，请注意，它根据主键在磁盘上存储其行。因此，主键的选择对 InnoDB 表的性能有很大影响。 请记，这些只是指导，最佳实可能会因使用情况的差异而变化。 主题 1.7: 实际案例研究好！我们已经顺利地完成了结构化课程的学习。总是有帮助的是通过实际例子来增强我们的学习。因此，让我们来研究一些 MySQL 索引和 B+ 树的实际案例研究。 电子商务系统: 考虑亚马顿这样的在线商店系统。这些平台处理了巨大的数据量，包括商品、用户详细信息、交易详细信息等等。给定巨大数量的产品和交易频率，数据检索的速度至关重要。在这里，MySQL 索引发挥了重要作用。有效使用主键、唯一和全文索引显著加速了查询处理过程，为用户提供了有效、流畅的体验。B+ 树用于索引允许系统处理数百万个项目，而性能下降不会太大。 社交媒体平台: 社交媒体平台如脸书或推特也广泛使用索引。每次我们打开我们的时线，系统就会查询一个非常大的数据库，以获取相关的帖子。想象一下在海量数据中找到一个 needle 在 haystack 中——这就是在没有索引的情况下找到我们的个人化时线所需要的时间。有效的索引允许这些服务快速地为我们提供每次登录或刷新时线所需要的数据。 搜索引擎: Google、Yahoo、Bing 等搜索引擎也广泛使用索引来提供快速和准确的搜索结果。在没有有效的索引策略的情况下，无法在互联网的庞大世界中立即获取搜索结果。 这些只是展示了实际应用中 B+ 树和索引的一些快照。无 matter 您是开发网站、应用程序或任何处理大量数据的平台，了解并有效地使用这些结构可以为性能和效率带来显著的差异。 主题1.8：可能的面试问题和答案好的，让我们前进。让我们为 MySQL 索引和 B+ 树准备好一些可能的面试问题。掌握这些概念可以帮助你在工作申请中表现良好，总是更好的准备好！ 下面是一些问题和答案 为什么数据库中的索引重要？索引在数据库中增加了数据检索的效率。索引与书籍中的索引类似，可以更快地访问数据。在 absence 的情况下，要找到数据，数据库需要浏览整个表的每一行——称为全表扫描——这可能会耗费时间和资源。 什么是 B+ 树？B+ 树是数据库中用于有效和有序地存储数据的数据结构。它是一个平衡树结构，其中所有叶节点位于同一级别，使搜索、插入和删除操作都非常有效，即使处理大量数据也是如此。 MySQL 是如何使用 B+ 树进行索引？MySQL 在 InnoDB 存储引擎中使用 B+ 树作为默认索引方案。主索引和辅助索引的 B+ 树都存储在 InnoDB 中。主索引的 B+ 树的叶节点包含表的行数据，辅助索引的 B+ 树的叶节点包含主键值。 MySQL 索引的最佳实践？重要的最佳实践包括了解数据之前进行索引，使用 EXPLAIN 关键字来了解查询执行，索引列用于 WHERE 子句，有效地使用多列索引，考虑索引开销，并使用适当的索引取决于存储引擎。 在哪里索引可以显著提高性能？电子商务平台可以作为一个好的例子。它们需要处理大量数据——用户详细信息、产品详细信息、交易历史等。索引可帮助排序和检索这些数据，提高搜索和交易效率并增加用户体验。 主题1.9：回和自我评估到了课程的最后一部分，我们将回主要内容并进行自我评估。 让我们回一下我们学习的内容： 为什么索引：我们已经了解了数据库中索引的重要性，并提高了数据检索的效率。 MySQL 中的索引类型：我们已经探讨了 MySQL 中的各种索引类型，包括主索引、唯一索引、全文索引、简单索引和复合索引，并了解了它们的应用场景。 B+ 树：我们已经深入了解了 B+ 树的结构，以及它们是如何工作的。 B+ 树在 MySQL 索引中的应用：我们已经看到了 MySQL 如何使用 B+ 树作为索引结构，特别是 InnoDB 存储引擎。 MySQL 索引的最佳实践：我们已经探讨了如何有效地使用索引，并提供了三个最佳实践。 实际应用：我们已经看到了如何在社交媒体平台、搜索引擎和电子商务系统中应用索引和 B+ 树。 现在，为了自我评估，请参考以下问题和小项目： 问题： 数据库中的索引有哪些作用？ 简要描述 B+ 树的结构和工作原理。 主索引和辅助索引在 MySQL 中有什么区别？ 在 MySQL 中使用索引时，可以提供三个最佳实践。 小项目： 创建或下载一个小数据集，并在 MySQL 中实现索引，然后观察检索数据时的性能差异。 考虑一个电子商务数据库，其中包含用户信息、产品详细信息和交易历史表。为其设计一个基本架构并说明各种 MySQL 索引的应用。 开心学习！ English post: https://programmerscareer.com/mysql-interview4/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview4/"},{"title":"MySQL 面试：简述乐观锁以及悲观锁的区别以及使用场景","text":"你曾被提过类似问题在面试中问过吗？或者将来会遇到，让我们一起探索和掌握它！ 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题 1.1：MySQL 和锁定机制简介让我们开始学习 MySQL 和锁定机制！ MySQL 是世界上最著名的开源关系数据库管理系统（RDBMS）之一。它非常受欢迎，特别是用于网站和在线出版的网络应用程序，并是 LAMP 开源网站应用程序软件堆栈的核心组件。 现在让我们谈谈为什么我们需要锁定机制在数据库中。 想象一场场景，两名人同时试图从同一银行账户中提款。 如果没有机制来防止它，他们可能会同时检查帐户余额，看到足够的资金，并继续提取超过帐户中实际存在的资金。 这是一种竞争条件，并可能导致严重的数据完整性问题。 这就是锁定机制发挥作用的地方！ 主题 1.2：锁定机制概述所以，让我们深入探讨 MySQL 中的锁定机制。 就像我们所说的，锁定在数据库中非常重要，特别是在多用户数据库环境中。 在 MySQL 中，锁定主要用于控制如何访问事务，以便每个事务可以看到数据的一致快照。 MySQL 中使用的主要类型的锁定有： 共享锁（读锁）：共享锁用于执行读操作（选择）时。 它允许并发事务读取（选择）资源，并保证无事务可以写入（更新/删除）该资源。 排他锁（写锁）：排他锁用于执行数据修改操作时。 它确保持有锁的事务是唯一的事务，可以读取或写入资源。 在下一章中，我们将深入探讨两种流行的锁定机制—— 乐观锁定和悲观锁定。 选择使用哪种锁定机制通常取决于系统的特定要求，例如并发事务可能会发生冲突的概率。 主题 1.3：了解乐观锁定让我们来详细了解乐观锁定！ 这是在多用户数据库中处理并发更新的策略。 乐观锁定基于多个事务可以完成而不会影响彼此的假设，因此允许多个事务访问同一条记录进行编辑。 这种方法在数据的争用较低的系统中很有用。 下面是乐观锁定的简单方法： 从数据库中获取记录以进行更新。 更新之前，应用程序会检查另一用户是否已更新该记录以来。 如果记录未被其他用户更新，应用程序可以执行更新并一切顺利进行。 如果记录已被其他用户更新，应用程序通常会通知用户并中止事务或自动重试事务。 乐观锁定的主要优点是其高效性。 它避免了获取和释放锁的开销并避免了事务等待锁。 但请记住，没有免费的午餐！ 在数据争用较高并且数据更新频繁的环境中，可能会出现许多事务冲突，这可能会导致性能问题。 主题 1.4：了解悲观锁定让我们来深入了解悲观锁定！ 这是 MySQL 中基于完全不同的假设的机制。 它假设冲突很可能会发生并强制执行严格的控制来防止这种情况。 下面是悲观锁定的工作方式： 当获取记录以进行更新时，立即获取排他锁。 直到释放锁，其他事务不能更新此记录。 释放锁时，其他事务可以获取锁并更新此记录。 悲观锁定是防止冲突的绝佳方法，因为它不允许另一事务进行，如果它可能会导致冲突。 它适用于数据争用较高并且记录频繁更新的环境。 但请记住，每个硬币都有两面！ 这种方法可能会导致降低并发性并影响系统性能，因为事务可能会被长时间保持等待锁。 主题1.5：比较乐观锁和悲观锁。现在你已经熟悉了乐观锁和悲观锁，了解在哪些场景下使用哪一种可以显著影响应用的性能和可靠性。 乐观锁 假设冲突较少并大多数避免了锁的获取和释放。它可能在低争用场景下导致更高的性能，因为它会导致更少的阻塞。然而，对于经常发生冲突的系统，锁的成本和频率的回滚可能会降低性能。 另一方面，悲观锁 假设冲突会经常发生并使用锁来防止它们。这种策略可能在高争用场景下有好处，因为它避免了冲突解决相关的回滚。然而，获取锁所需的等待时间可能会降低性能。 因此， golden rule 是： 在冲突较少的情况下，选择乐观锁。在冲突经常发生的情况下，选择悲观锁。 这就是 MySQL 中乐观锁和悲观锁的简要比较。 主题1.6：锁定机制的使用场景厉害！现在我们已经了解了主要的锁定机制，让我们来看看这些机制在真实的场景中可能会有好处。 银行系统：考虑一种银行应用程序，其中经常发生交易。这些交易需要一致和安全。在这种情况下，悲观锁是有利的，因为它确保一旦用户开始交易，就不会有其他用户修改数据，保证数据一致性。 票务预订应用程序：考虑一个在线票务预订系统，其中多个用户试图预订有限数量的票。在这种情况下，乐观锁可能是有利的，因为它允许多个用户同时访问票务预订功能。 内容管理系统：如果你在一个内容管理系统上工作，其中用户正在更新他们的博文或文章，乐观锁可能是有利的。由于两个用户试图编辑同一文章的可能性相对较低，系统可以处理这些偶尔的冲突。 股票交易应用程序：在一个股票交易应用程序上，悲观锁可能是有利的，因为它立即阻止其他交易，直到完成。在这种情况下，由于一次性的延迟可能会导致重大财务损失，悲观锁可能会有好处。 记住，决定使用乐观锁或悲观锁主要取决于应用的性质，冲突的可能性，并发性的要求，以及延迟的容忍度。 主题1.7 回顾和评估 MySQL 和锁定机制的介绍：我们讨论了 MySQL 的功能，锁定机制的重要性和并发数据库访问的帮助。 锁定机制的概述：我们浏览了各种锁定机制，它们的重要性在维护数据一致性和处理并发访问中，并分析了它们的优缺点。 了解乐观锁定：我们深入探讨了乐观锁定的概念，它的优缺点和在 MySQL 中的实现。 了解悲观锁定：我们探讨了悲观锁定，包括其强项和在 MySQL 中的实现。 比较乐观和悲观锁定：我们比较了这两种锁定机制并结论了选择高度取决于特定的使用案例和系统要求。 锁定机制的使用场景：我们浏览了可能的真实应用场景，其中这些锁定机制可以提供好处。 例子问题：让我们来看一个例子：你有一个 MySQL 数据库，其中一个名为“Account”的表存储了用户的账户余额。两个不同的金融事务试图从同一帐户中扣除资金同时进行。如何使用 MySQL 中的乐观和悲观锁定机制来处理这种情况？ 答案： 对于 乐观锁定，您可以通过在 Account 表中使用版本列来处理这种情况。这是怎样做的： 事务先读取帐户余额并记下版本。在更新帐户之前，它们检查版本是否仍然相同。如果版本已更改，这意味着另一事务在此期间更新了帐户余额，因此当前事务被回滚。这样就避免了不一致的扣除。 对于 悲观锁定，您将锁定帐户对于每个金融事务。这是怎样做的： 事务立即锁定帐户，在读取帐户余额时。只有一个事务可以持有锁，并持有它直到更新帐户余额。所有试图读取帐户余额的其他事务，当锁被持有时，将被阻止，直到锁被释放。 现在，测试你的知识。 **问题 1 (简单)**： 在哪种情况下会选择乐观锁定而不是悲观锁定？ **问题 2 (中等)**： 悲观锁定在高吞吐量系统中可能会有哪些缺点，并说明如何减轻这些缺点？ **问题 3 (困难)**： 描述一种场景，其中既不适合乐观锁定也不适合悲观锁定，并说明所需的锁定或并发控制机制。 English post: https://programmerscareer.com/mysql-interview5/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview5/"},{"title":"MySQL 面试：产生死锁的必要条件有哪些？如何解决死锁？","text":"我们先来了解死锁是什么，并了解它们在事务中是如何发生的。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题1.1：死锁的介绍在多线程环境中，当两个或多个线程因为彼此持有并请求资源而无法进行时，就会出现死锁。在 MySQL 数据库的上下文中，死锁发生在两个或多个事务中，它们相互持有并请求锁，形成了资源的循环依赖。 在事务中，线程可能需要锁定多张表或行，这可能会导致线程需要一个已经被另一个线程锁定的资源的情况。同时，该线程可能正在等待另一个线程锁定的资源。这就是所谓的死锁。 让我们用一个简单的故事来说明： 想象两名漫画爱好者，Alice 和 Bob。Alice 现在持有最新的《超人》漫画，Bob 也想要它。同时，Bob 持有最新的《巧女》漫画，Alice 也想要它。现在，Alice 不想放弃她的《超人》漫画，直到她得到了《巧女》漫画。同时，Bob 也不想放弃他的《巧女》漫画，直到他得到了《超人》漫画。因此，两人都在等待对方释放他们的漫画，这就是死锁。 在数据库事务中，Alice 和 Bob 可能是事务，并且漫画可能是被锁定的资源。 主题1.2：了解必要条件以创造死锁要了解死锁是如何发生的，我们需要熟悉 Coffman 条件，这是一组四个条件，它们必须全部满足才能发生死锁。这些条件被 Edward G. Coffman， Jr. 提出并命名。条件是： 互斥：至少一个资源必须以非共享模式持有。这意味着只有一个进程（或线程）可以使用资源在任何给定时间内。如果另一个进程请求资源，请求进程必须被延迟，直到资源被释放。 持有和等待（资源持有）：一个进程至少持有一个资源并等待其他资源，这些资源目前被其他进程持有。 不可抢占：资源不能被强行从持有它们的进程处除，直到资源被使用完成。资源只能在持有它们的进程释放它们时释放。 环形等待：存在一个环形链条中的进程，其中每个进程持有一个资源并请求另一个资源，被另一个进程在链条中持有。基本上，存在一个进程 P1，它在等待一个由进程 P2 持有的资源，并且 P2 在等待由 P1 持有的资源。这就形成了一个环形链条中的等待进程。 这四个条件 inherently 提供了一个逻辑结构来了解和结构防止策略。通过确保至少一个上述条件不会发生，我们可以防止死锁的形成。 主题1.3：在 MySQL 中检测死锁在 MySQL 中，InnoDB 存储引擎自动检测并解决死锁，通过回滚与其中一笔交易。因此，您的应用应该总是准备好重新发出交易，因为它被回滚了，因为发生了死锁。 当在 MySQL 中发生死锁时，它会立即被检测和解决。这是通过维护哪些事务正在等待哪些其他事务持有的锁的 wait-for 图 来实现的。通过这种方法，MySQL 可以检查等待图中是否存在循环。如果它检测到循环，这意味着死锁，并且它会回滚一笔交易来解决死锁。 为了提供更多的见解，MySQL 还提供了诊断信息，当它检测和解决死锁时。这些信息可以从 SHOW ENGINE INNODB STATUS 命令获取，它会显示最新的死锁错误。 但是，需要注意的是，死锁并不总是表明设计错误或错误。在高并发系统中，死锁可能会偶然发生，并且可以被视为做生意的成本。然而，如果您经常遇到它们，可能值得进一步调查，以看看是否可以进行交易处理的改进。 主题1.4：避免死锁下面是避免死锁的几个策略： 锁定表的顺序保持一致：总是锁定表以相同的顺序。例如，如果所有的事务都先锁定“orders”表，就不会有一个事务锁定“orders”表，另一个事务锁定“products”表并等待“orders”表。 快速和短的事务：短的事务更少可能会锁定需要的行，因为它们更少可能会锁定需要的行。 错误处理：由于 InnoDB 自动检测死锁并回滚一笔交易，因此您需要准备好在代码中捕捉该错误并重新发出交易。 使用较低的隔离级别：如果可能，请使用读提交隔离级别而不是重复读来减少死锁的可能性。 避免热点：如果可能，请避免频繁更新的行，以减少死锁的可能性。例如，如果可能，请考虑使用不同的策略来计数操作，而不是使用计数表，每次操作时更新。 主题1.5：解决死锁在解决死锁方面，理想情况是MySQL的InnoDB存储引擎自动检测和处理死锁。 InnoDB 使用一种称为 wait-for graph 的机制来检测死锁。当发生死锁时，InnoDB 选择一个事务并杀死它，从而解决死锁。 虽然这样解决了死锁，但对应用程序开发者来说，应该在应用程序中处理这些场景。当 InnoDB 因为死锁而杀死事务时，它会引发一个错误，需要在应用程序中捕捉。通常情况下，被终止的事务应该重试。 InnoDB 的自动死锁检测可以解决死锁，但在某些情况下，检测和杀死事务可能会花费较长的时间，影响应用程序的性能。因此，还要为避免死锁而设计应用程序。 虽然完全避免死锁在高并发系统中困难，但尽量避免它们会使数据库系统的操作更加稳定和高效。良好的编码习惯、有效地设计表格、正确地应用事务和锁控制可帮助避免大多数死锁。 主题1.6：诊断死锁调查和诊断死锁可以提供有价值的见解，帮助防止它们或提高响应时间。MySQL 包含多种工具可帮助这个过程。 SHOW ENGINE INNODB STATUS：这条命令输出了一段文本报告，包含最近的死锁的信息，如果发生了死锁。它是在死锁发生后立即运行的，因为其信息会在下一个死锁中丢失。 InnoDB 监视器：这些是更详细和更广泛的报告，包含 InnoDB 内部的详细信息，包括死锁。它们分为标准、锁和互斥监视器。 性能架构：MySQL 的性能架构可以配置为捕获详细数据事件，包括事务事件。这些数据存储在表中并可以像其他 MySQL 数据一样查询。 二进制日志：MySQL 的二进制日志可帮助确定导致死锁的查询序列。这需要启用二进制日志并以行格式进行日志。 错误日志：死锁会在这里记录下来，如果启用了 innodb_print_all_deadlocks 配置选项。 通过分析这些来源，可以确定参与死锁的事务并了解它们试图访问的资源。在许多情况下，详细分析可能会指出更好的锁序或更好的事务大小来避免预见的死锁。 主题1.7： 复习和评估示例问题： 假设您在 MySQL 数据库中遇到了死锁。您决定运行命令 SHOW ENGINE INNODB STATUS 获取更多信息。 LATEST DETECTED DEADLOCK 部分给出了以下输出： 1234567891011121314151617181920212223LATEST DETECTED DEADLOCK ------------------------ 2022-08-24 23:08:02 7f3e6e2fd700 *** (1) TRANSACTION: TRANSACTION 118945420, ACTIVE 22 sec inserting mysql tables in use 1, locked 1 1700 lock struct(s), heap size 187648, 1249789 row lock(s), undo log entries 1 MySQL thread id 155, OS thread handle 0x7f3e6e3e7700, query id 25749768 localhost user INSERT INTO customer (id, name, address) VALUES (3, 'John Doe', '123 Main St') *** (1) WAITING FOR THIS LOCK TO BE GRANTED: RECORD LOCKS space id 66873 page no 70541 n bits 600 index `id` of table `test`.`customer` trx id 118945420 lock mode S waiting up to 3 years total: 47.56T, and currently at 47.68T to rise above: 47.68T *** (2) TRANSACTION: TRANSACTION 118945416, ACTIVE (PREPARED) 13 sec committing, thread declared inside InnoDB 476 mysql tables in use 1, locked 1 1 lock struct(s), heap size 368, 0 row lock(s) MySQL thread id 117, OS thread handle 0x7f3e6e2fd700, query id 25749765 localhost user COMMIT *** (2) HOLDS THE LOCK(S): RECORD LOCKS space id 66873 page no 70541 n bits 600 index `id` of table `test`.`customer` trx id 118945416 lock mode S *** (2) WAITING FOR THIS LOCK TO BE GRANTED: RECORD LOCKS space id 66873 page no 70541 n bits 600 index `id` of table `test`.`customer` trx id 118945416 lock_mode X waiting up to 3 years total: 47.68T to rise above: 47.56T *** WE ROLL BACK TRANSACTION (1) 根据此信息，什么是导致死锁的原因，并可能解决它？ 问题 1 — 简单熟练问题（难度 3/10）： Coffman 条件中的四个条件是什么？请提供每个条件的简要说明。 问题 2 — 复杂熟练问题（难度 6/10）： 为了预防或最小化死锁发生，您将执行哪些步骤？ 问题 3 — 复杂问题（难度 9/10）： MySQL InnoDB 引擎为什么会自动解决死锁？什么是其优势和潜在的缺点？ 请先自己试图找到答案，再问助。 解决示例问题的方法： 两个事务同时等待资源，其中事务（1）正在等待 id 索引的 S 模式（读）锁，该锁被事务（2）所持有。同时，事务（2）正在等待同一资源的 X 模式（写）锁，并持有 S 模式（读）锁。 这种情况意味着两个事务都无法进行，导致死锁。解决方法是确保事务请求锁的顺序，这是避免死锁的一种常见技术。 回答问题 1 的方法： Coffman 条件如下： 互斥： 资源只能由一个进程所持有。 保持和等待： 已经持有资源的进程可以请求新资源。 不可抢： 只有持有资源的进程才能释放它。 环形等待： 存在一个环形链条，其中每个进程持有下一个进程所需的资源。 回答问题 2 的方法： 多种方法可以防止或最小化死锁： 锁超时设置： 限制事务等待获取锁的时间，可以减少等待时间并可能解决死锁。 锁顺序： 按特定顺序请求锁可以避免环形等待条件。 频繁提交： 较小的事务更可能与其他事务不发生冲突。 死锁检测工具： 使用内置或第三方工具确定死锁发生的时间和原因，以便编程解决方案可以应用。 回答问题 3 的方法： 当 MySQL 发生死锁时，InnoDB 引擎会自动选择具有最少行锁的事务并回滚它来解决死锁。 优势： 这种自动解决可以帮助保持数据库运行良好，无需手动干预。 潜在的缺点： 如果事务较大或重要，则回滚可能会导致数据不被更新或保存正确。 持续回滚可能会影响性能。 不是所有的业务逻辑场景适合自动回滚。 English post: https://programmerscareer.com/mysql-interview6/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview6/"},{"title":"MySQL 面试：什么是 SQL 注入攻击？如何防止这类攻击？","text":"下面是学习 MySQL 中的 SQL 注入攻击的提议课程： 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：SQL 注入攻击简介SQL 注入（SQLi）是网站应用安全性漏洞中最著名的类别之一。它发生在攻击者可以在输入字段中插入恶意 SQL 语句以执行或修改时。简单来说，SQLi 攻击利用网站的弱输入验证，其中 SQL 命令被解析。 这种攻击可能导致未经授权的用户列表查看、整个表的删除以及在某些情况下，攻击者可能会获得管理员权限，全部通过在数据库上运行恶意 SQL 语句来完成。SQLi 相对容易防止，但仍然发生非常频繁，并且具有令人惊讶的后果。 攻击者可以通过在被包含在 SQL 语句中的字段中插入自己的命令来操纵您的 SQL 查询。这些攻击成功时，网站应用程序未能正确验证输入之前将其包含在 SQL 查询中。 例如，想象一下一个简单的登录功能，其中用户必须输入用户名和密码。与此功能相关的 SQL 查询可能会像这样看起来： 1SELECT * FROM users WHERE username = '[username]' AND password = '[password]'; 在这种情况下，攻击者可能会提交“admin'; --”作为他们的用户名。您的查询将然后看起来像这样： 1SELECT * FROM users WHERE username = 'admin'; --' AND password = '[password]'; 在 SQL 中，从&nbsp;--&nbsp;开始的任何内容都被视为注释并被忽略。因此，攻击者已经成功地绕过了密码检查并可以以&nbsp;admin&nbsp;身份登录。 请记，这是 SQLi 的最简单形式——存在更复杂的 SQLi 方法，它们可能会有更为严重的后果。 主题：SQL注入攻击的示例SQL注入攻击的形态很多种。下面是一些常见的例子： 1. 显示隐藏数据：假设我们有一个显示过滤后的产品的页面： 1https://example.com/products?category=Books 它可能使用以下 SQL 查询： 1SELECT * FROM products WHERE category = 'Books' 攻击者可以更改 URL 到： 1https://example.com/products?category=Books' OR '1'='1 这可能会修改 SQL 查询为： 1SELECT * FROM products WHERE category = 'Books' OR '1'='1' 由于 ‘1’=’1’ 总是真的，它会显示所有的产品，不仅仅是书籍。 2. 绕过应用程序逻辑： 考虑另一种情况，其中应用程序检查用户的登录凭证使用以下代码： 1SELECT * FROM users WHERE username = '$username' AND password = '$password' 攻击者可以使用 SQLi 绕过密码检查使用以下输入： 12' OR '1'='1' -- 对于用户名randompassword 对于密码 这将看起来像： 1SELECT * FROM users WHERE username = '' OR '1'='1' --' AND password = 'randompassword' 注释掉密码检查的 SQL 查询的部分，导致非授权的登录。 3. UNION 攻击： UNION 操作可以用于从数据库的其他表中检索数据。例如，URL： 1https://example.com/products?category=Books 如果查询是： 1SELECT price, name, description FROM products WHERE category = 'Books' 攻击者可能会试： 1https://example.com/products?category=Books' UNION SELECT username, password FROM users -- 这可能会导致泄露用户凭证。 请记住，这些攻击大量依赖于后端查询结构和保护机制的存在。不是所有的网站或数据库都会受到这些精确的攻击。然而，这些示例应该能够给你一个想法，说明 SQLi 利用了不正确处理用户提供的数据来操纵 SQL 查询。 主题：了解 SQL 注入的影响SQL 注入可能导致各种危险后果，其严重程度大量取决于攻击者侵害的用户帐户的权限和数据库的用途。下面是 SQL 注入攻击的可能影响： 1. 数据泄露： SQL 注入攻击的最直接和危险的后果是数据泄露。如果攻击者成功利用了 SQL 注入漏洞，他们可能会获取存储在数据库中的敏感数据。这可能包括个人身份信息（PII）、财务数据、商业秘密、密码或更多内容。 2. 数据修改： SQL 注入不仅仅是关于查看数据的事情。攻击者可能会使用它来修改或删除数据库中的数据——这可能范围从更改价格或平衡到删除整个表。 3. 丢失的可追溯性和非否认性： SQL 注入可能会导致丢失的可追溯性和非否认性。攻击者可能会在数据库上执行操作，并以其他用户（或者管理员）的身份进行。这可能会使追踪操作的过程变得困难，创造了非否认性问题。 4. 损害商业的声誉： 成功的 SQL 注入攻击可能会严重损害业务的声誉。客户信任商业处理其数据，并且一旦发生数据泄露，可能会损失这种信任。 5. 法律后果： 根据侵害的数据和司法管辖区，SQL 注入攻击可能会导致法律后果，例如罚金、诉讼或两项都有。 这些后果显示了 SQL 注入攻击的重要性，并且在接下来的课程中，我们将深入探讨如何防止它们。 主题：防止 SQL 注入攻击防止 SQL 注入攻击的关键是确保应用程序和数据库之间的数据流是安全和有保证的。下面是可以用来帮助防止 SQL 注入攻击的技术： 1. 使用准备好的语句（参数化查询）： 最有效的方法是使用准备好的语句。定义了参数的准备好的语句确保参数被绑定到查询中，并且不是查询的一部分，这意味着攻击者不能影响查询结构。这有效地消除了所有的 SQL 注入攻击。大多数网络语言现在都支持准备好的语句。 2. 使用存储过程： 与准备好的语句类似，存储过程也分离了数据和命令和查询。然而，存储过程还具有额外的好处，例如提高性能和可重用的代码。 3. 输入验证： 虽然这种方法自身不足以防止 SQL 注入攻击，但它仍然是必要的步骤。通过验证用户输入，我们确保它符合长度、类型、语法和业务规则的特性。 4. 最小权限原则： 不要为用户帐户提供更多的权限，它们所需要的。例如，如果帐户仅用于在应用程序中执行选择语句，就不要为其提供删除表的能力。如果攻击者侵害了有限的帐户，则可能会限制其造成的损害。 5. 定期更新和补丁： 保持数据库管理系统（DBMS）和所有软件的更新和补丁，并使用最新的安全修复。 这些是可以用来确保数据库的安全性并防止 SQL 注入攻击的几个防护技术。 中文翻译: 主题：防止 SQL 注入的最佳实践除了上述防止措施外，下面是更多的最佳实践，可帮助避免 SQL 注入漏洞： 1. 数据转义： 数据转义是指将数据处理为原始数据，而不是作为 SQL 查询的一部分。这可以通过使用特定的函数来转义特殊字符，例如引号，或者通过使用预编译语句来隐式处理。 2. 详细错误处理： 黑客经常依赖数据库的错误消息来获取数据库的结构信息。最佳实践是避免直接向终端用户暴露这些错误，相反，使用通用错误消息并将详细错误信息记录到一个安全的文件中，开发人员可以参考这些详细信息。 3. 使用 Web 应用程序防火墙 (WAF)： Web 应用程序防火墙可以检查进入数据的数据并识别恶意 SQL 代码。它们不能替代良好的编码实践，但它们可以作为额外的防线。 4. 定期代码审查： 定期进行代码审查，其中安全是其中一个主题。这可以帮助确保安全编码实践被遵循并捕获潜在的问题。 5. 进行测试并使用安全工具： 定期测试应用、数据库和基础设施的安全性。有许多自动化工具可用，可以扫描 SQL 注入和其他漏洞。 记住，安全是一个过程，不是一个状态。定期更新技能和知识，了解新的漏洞和攻击技术，并定期审核和改进应用是维护强大安全性的一部分。 主题：测试 SQL 注入漏洞测试 SQL 注入漏洞是确保应用和数据库的安全性的关键部分。它可以手动进行或者使用自动化工具进行。下面是详细说明： 1. 手动测试： 手动测试涉及使用技术来注入特殊字符到应用的输入中并观察应用的反应。例如，输入单引号 ' 到文本字段中。如果应用抛出 SQL 错误，这可能表明应用受 SQL 注入攻击的影响。另一方面，如果应用运行良好并显示输入的字符，这可能表明应用正确处理输入。 记住，SQL 注入可能会以多种形式出现，并且详尽的手动测试可能涉及试验许多输入。 2. 自动测试与安全工具： 还有许多自动化工具可用，用于帮助检测 SQL 注入漏洞。这些工具可以爬行应用并测试各种输入，节省时间并提供详细的评估。它们可以测试已知的 SQL 注入技术并生成报告，显示可能的漏洞。 例如，SQLMap、Havij 和 Netsparker。 虽然测试和自动化工具可能非常有用，但它们并不完全可靠。即使工具未发现任何漏洞，这并不意味着应用是安全的。建议结合这些方法与上述防止技术和最佳实践。 主题：SQL 注入的审查和评估审查： SQL 注入攻击： 这是一种攻击方法，攻击者通过注入恶意 SQL 代码来操纵 SQL 查询，通过用户输入进行。 防范措施： 主要手段包括预编译语句、存储过程、输入验证和强制最小特权，并定期更新系统。 最佳实践： 这包括数据转义、详细错误处理、使用 Web 应用程序防火墙 (WAF)、定期代码审查和使用安全工具。 检测漏洞： 手动测试可能会涉及试验许多输入。自动化工具如 SQLMap 也可以帮助检测可能的漏洞。 现在，让我们进行评估。 评估：下面是一些简短的问题。这些问题是为了测试我们讨论的概念的理解和应用。 系统可能会显示 SQL 注入攻击的特征是哪些？ 如何使用预编译语句来防范 SQL 注入攻击？ 为什么详细错误处理和不向终端用户暴露数据库错误是重要的？ 描述至少两种应该遵循的最佳实践来保护自身免受 SQL 注入攻击的。 系统可能会显示 SQL 注入攻击的特征是哪些？答：系统可能会对 SQL 注入攻击感兴趣，如果它们直接使用未经过清理或验证的用户输入来构建 SQL 查询，或者如果它们向终端用户暴露数据库错误，或者如果它们不使用参数化查询或预编译语句。可能的征兆包括用户输入中的单引号导致错误，或者特定的输入提供了访问或数据检索，该访问或数据检索不应该可能。 如何使用预编译语句来防范 SQL 注入攻击？答：预编译语句分离 SQL 查询结构和用户提供的数据。这阻止攻击者通过更改查询结构来操纵查询，因为用户输入不被视为 SQL 命令的一部分，使 SQL 注入攻击无效。 为什么详细错误处理和不向终端用户暴露数据库错误是重要的？答：向终端用户暴露数据库错误可以为攻击者提供有用的信息关于数据库结构或应用设计，这可以用于攻击。另外，详细错误处理是防范 SQL 注入攻击的重要部分，因为它们允许系统友好地处理问题并可能提供日志或其他机制来警告可能的攻击。 描述至少两种应该遵循的最佳实践来保护自身免受 SQL 注入攻击的。答：其中包括： 使用预编译语句或参数化查询：这确保用户提供的输入不会更改 SQL 查询的结构不利地。 输入验证：输入应该被验证为具有正确的形式之前使用。例如，如果系统期望整数，它应该确认输入确实是整数。 其他最佳实践包括详细错误处理、定期系统更新、强制最小特权原则和更多。 English post: https://programmerscareer.com/mysql-interview7/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview7/"},{"title":"MySQL 面试：MySQL 的索引什么情况下会失效？","text":"详细分析MySQL中的索引。了解内部工作原理、好处和如何通过索引提高查询性能。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：MySQL索引深入分析MySQL索引发挥着优化数据库搜索性能的重要作用。为了深入了解索引，让我们更详细地分析它们。 MySQL中的索引是什么？ 简单来说，索引就像书的索引一样。当你需要找到信息时，你会参考索引，它会快速指导你到包含所需信息的页面。 在MySQL中，索引是数据结构（通常是B-Tree），它提高了数据库表的访问性能。索引用于快速定位数据，而不是每次访问数据库表时搜索整个数据库表。 它们可以使用数据库表的一个或多个列创建，为随机访问和记录的有序访问提供基础。 MySQL索引的优势： 更快的数据检索： 索引的主要优势是加快数据检索的速度。索引使数据检索变得更快。 ORDER BY 优化： 索引可以优化 ORDER BY 子句，以更快地对数据进行排序。 更好的性能： 它们显著提高了 SELECT 查询和 WHERE 子句的性能。 请记，虽然索引加快了数据检索，但它会慢下数据修改操作，例如 INSERT、DELETE 和 UPDATE。这是因为每次修改数据时，索引也需要更新。 主题：MySQL 中的索引类型了解 MySQL 中不同类型的索引，例如 PRIMARY、UNIQUE、INDEX、FULLTEXT 以及它们的使用。 MySQL 中有多种索引类型。每种类型在特定场景下使用，并提供其特殊的优势。让我们来详细了解这些不同类型： PRIMARY 索引： 这是表的主要索引。每张表都应该有一个主要索引。值在这个索引中是唯一的并不为空。在大多数情况下，这是表的主键。 UNIQUE 索引： 这个索引防止两条记录具有相同的值在特定列中。这帮助维护数据的完整性。它允许 NULL 值，但唯一性仍然被强制。 INDEX (或 KEY)： 这是最简单的索引类型。它允许重复和 NULL 值。它通常用于提高特定搜索的性能，并不需要强制唯一性或非 NULL 性。 FULLTEXT 索引： 这是用于全文搜索的索引。它是一个非常强大的索引类型，用于搜索文本值。然而，它是一个专门的索引类型，只适用于文本（不适用于数字或日期）。 每种索引类型都为特定目的服务。优化数据库的最佳使用是至关重要的。 了解何时和何处使用适当的索引是至关重要的。它取决于存储的数据、数据的完整性要求、执行的查询以及许多其他因素。 主题：MySQL索引管理了解如何在 MySQL 中管理索引是优化数据库性能的关键技能。 当处理索引时，您可以执行以下主要操作： 创建索引：要在 MySQL 中创建索引，您可以使用 CREATE INDEX 语句： CREATE INDEX index_nameON table_name (column1, column2, …); 例如，如果我们有一个名为 Students 的表，并且我们想创建一个索引在 LastName 和 FirstName 列上，我们将写： CREATE INDEX idx_students_nameON Students (LastName, FirstName); 删除索引：要在 MySQL 中删除索引，您可以使用 DROP INDEX 语句： DROP INDEX index_name ON table_name; 禁用索引：在某些情况下，您可能希望暂时禁用索引。MySQL 允许您使用 ALTER TABLE 语句禁用索引： ALTER TABLE table_name DISABLE KEYS; 要再次启用它，您将使用 ENABLE KEYS： ALTER TABLE table_name ENABLE KEYS; 重命名索引：MySQL 不支持直接重命名索引。要重命名索引，您需要先删除（删除）索引，然后再创建它们使用新名称。 请记，虽然索引有利并可能会加快数据检索，但它们也会带来其他成本。索引占用存储空间并会慢下数据更新操作（因为当数据更新时，索引也需要更新）。 主题：优化 MySQL 与索引了解如何优化 MySQL 性能使用索引是管理数据库的关键部分。 一个关键因素，影响数据检索操作的效率是索引的正确使用。但是，怎样知道索引是有效的呢？ 请参考 EXPLAIN 命令。 EXPLAIN 命令是 MySQL 中的一个强大工具，可帮助了解 MySQL 如何执行查询。通过使用 EXPLAIN 命令来查询之前，MySQL 将返回有关如何处理语句以及表的读取顺序的信息。 下面是一个例子： EXPLAIN SELECT * FROM Students WHERE LastName = “Smith”; 输出可能会返回大量数据，但您需要关注主要三列： select_type: 这告诉我们查询的类型。 key: 这告诉我们 MySQL 使用哪个索引来运行查询。 rows: 这告诉我们 MySQL 考虑了多少行来给出查询的结果。 另外一个重要的事情是，不同的查询需要不同的优化。例如，一个 SELECT 查询，用于检索数据可能会被优化不同于一个 UPDATE 查询，用于更新数据。 作为一般规则，索引列在 WHERE、JOIN、ORDER BY、和 GROUP BY 子句中经常使用的列上的索引可以显著增加 SELECT 查询的速度。 然而，请记，索引会为数据库添加额外的负担，特别是对 INSERT、UPDATE、和 DELETE 语句的处理。因此，索引的数量应该尽可能地保持在最小的水平上，以减少负担。 主题：何时MySQL不使用索引虽然索引是为了优化数据检索而设计的，但在某些场景下，MySQL可能会忽略已存在的索引。让我们深入探讨这些场景： 小表： 在具有较少行数的表中，MySQL优化器可能会忽略索引并执行全表扫描。这是因为在索引中先读取索引，然后再读取行可能会涉及更多的开销，而直接读取每一行可能更有效。 低选择性： 具有多个重复值的索引具有低选择性。如果索引列不足以有效地缩小行数，MySQL可能会跳过使用索引并执行全表扫描。 NULL值： 如果索引列包含 NULL 值并且 WHERE 子句是 IS NULL 或 IS NOT NULL，MySQL不能使用索引，因为比较操作不能与 NULL 值一起使用。 不使用索引的左侧前缀： MySQL可以有效地使用索引，当 WHERE 子句使用左侧部分的多列索引时。然而，当查询不涉及左侧部分时，MySQL可能无法有效地使用索引。 LIKE 操作符的通配符开头： 当使用 LIKE 操作符在 WHERE 子句中时，如果模式开头有通配符，MySQL不能利用索引。 记住，索引是优化数据检索的有用工具，但它们不总是被使用。深入了解 MySQL 如何和何时使用索引可帮助您的数据库设计和查询构造。 主题：回顾和评估已经到了课程的尾端。在我们结束之前，让我们先做一个快速回： 我们深入探讨了 MySQL 索引的概念。 我们学习了 MySQL 中的两种索引类型。 我们了解了如何管理 MySQL 中的索引。 我们看到了如何使用 EXPLAIN 命令来评估 MySQL 性能并优化数据检索。 我们探讨了 MySQL 可能不使用索引的场景。 现在，来试试你的知识！下面是一些思考性的问题： MySQL 索引的主要目的是什么，并且如何提高数据库性能？ 在 MySQL 中可以描述两种不同类型的索引，并且在哪些场景下使用它们？ 如何禁用并重新启用 MySQL 中的索引？ MySQL 可能会在哪些场景下不使用索引，即使它可用？ 如何使用 EXPLAIN 命令在 employees 表中基于 employee_id 进行数据检索？ 试着写下你的答案，然后与你的笔记或者你使用的其他资源进行比较。回和复习是强化学习的好方法。 记住，掌握任何主题都是时间、练习和持久努力的事情。保持坚持！ MySQL 索引的主要目的是什么，并且如何提高数据库性能？ An index in MySQL 是一种数据结构，可以显著提高数据库表上的数据检索操作的速度。它类似于书的索引，可以使数据库在每次访问数据库表时找到数据，而不是扫描整个数据库中的每一行。索引可以极大地提高数据库性能。 可以描述两种不同类型的索引在 MySQL 中，并在哪些场景下使用它们？ PRIMARY index: 这是一种唯一索引，其中列必须包含唯一且不为 NULL 的值。这通常用于主键。 FULLTEXT index: 这是用于全文搜索的索引。它专门用于通过 SQL 查询中的字符串定位模式进行文本搜索。 如何禁用并重新启用 MySQL 中的索引？ 禁用非唯一索引: ALTER TABLE table_name DISABLE KEYS; 重新启用非唯一索引: ALTER TABLE table_name ENABLE KEYS; 在哪些场景下 MySQL 可能会不使用索引，即使它可用？ MySQL 可能会在以下场景下不使用索引，即使它可用：如果 MySQL 估计使用索引会 slower 于全表扫描，例如，如果表很小或索引列具有很低的选择性（许多重复值）。 可以使用 EXPLAIN 命令在 employees 表中基于 employee_id 进行数据检索吗？ 下面是一个简单的例子： EXPLAIN SELECT * FROM employees WHERE employee_id = 101 记住，练习是学习这些概念的关键。不要害惕深入探讨并在真实的 MySQL 环境中试用这些命令来进一步探索！ English post: https://programmerscareer.com/mysql-interview8/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview8/"},{"title":"MySQL 面试：MySQL 有什么调优的方式？","text":"让我们深入探讨优化 MySQL性能 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：了解 MySQL 配置优化 MySQL 性能的关键方面之一是了解并适当地调整其配置。但是，先来理解我们所说的“配置”在 MySQL 中是什么意思。 MySQL 配置 指的是一组参数和设置，决定了 MySQL 如何运行。其中包括控制内存分配、表缓存大小和排序缓冲区大小的变量。 MySQL 配置文件通常被命名为 my.cnf，但是其位置可能因操作系统和 MySQL 版本而异。 my.cnf 文件包含多个部分。[mysqld] 部分包含服务器特定的设置，而 [client] 部分包含客户端特定的选项。对这些设置进行修改将影响 MySQL 服务器的操作。 让我们考虑几个重要的设置： innodb_buffer_pool_size: 如果您使用 InnoDB 存储引擎，则此是关键设置。缓冲池是数据和索引被缓存的地方，因此正确地设置它可以显著提高性能。 max_connections: 这决定了 MySQL 可以处理多少并发连接。但是，请谨慎，因为高值可能会使 MySQL 快速消耗可用资源。 query_cache_size: 查询缓存可以帮助加快响应时间，但它需要谨慎使用，因为它会为所有查询处理添加额外的开销。 要进行更改，您可以在 my.cnf 文件中编辑这些参数，然后重新启动 MySQL，以使更改生效。 了解这些配置并根据您的特定使用场景进行细化可以大大提高 MySQL 服务器的性能。 主题：调整服务器设置现在，让我们深入探讨一些关键的服务器设置，您可以调整以优化性能。 MySQL 有大量的服务器变量，您可以设置以影响其操作。它允许高度的自定化和调整，以适应特定的应用和硬件环境。以下是一些关键变量： 1. key_buffer_size: 这变量决定了 MyISAM 表索引在内存中的缓存量。如果您使用 MyISAM 表，则大值可能会提高性能。 2. innodb_buffer_pool_size: 我们已经提到过，这是对 InnoDB 存储引擎的关键设置。它指定 InnoDB 使用的内存缓冲区的大小，用于缓存其表的数据和索引。 3. thread_cache_size: 这变量用于指定服务器应该缓存多少线程以供重用。当客户断开时，客户端的线程被放入缓存中，并且如果客户重新连接，他们可以重用缓存中的线程。 4. table_open_cache: 这变量设置了所有线程可以打开的表数量。增加此值会增加 MySQL 所需的文件描述符数量。 5. query_cache_size: 它设置查询缓存的大小。它用于缓存 SELECT 结果并在不再执行相同查询时返回它们。 请记住，配置和优化 MySQL 是更多的艺术而非科学，主要是通过增量更改和持续监控来进行的。使用工具如 MySQLTuner 或 MySQL Workbench 可以非常有用，以监控 MySQL 服务器的性能并进行必要的调整。 主题：查询优化优化 MySQL 查询是提高 MySQL 服务器性能的有效方法之一。下面是一些策略： 避免全表扫描：尽可能避免全表扫描，通过合理使用索引（后面会详细介绍）来找到相关行。当发生全表扫描时，MySQL 必须读取整个表才能找到相关行，这可能会在处理大表时严重影响性能。 使用 EXPLAIN 分析查询性能：MySQL 提供了 EXPLAIN 语句，它可以提供有关 MySQL 如何执行查询的信息。这是一个有用的调试和优化工具。 利用索引：索引用于快速找到具有特定列值的行。 absence 索引，MySQL 必须扫描整个表才能找到相关行。 限制结果：如果您不需要完整的结果集来执行操作，请使用 LIMIT 可以显著降低查询的成本。 规范化和去规范化——按需进行：虽然规范化通常是一个好的事情，因为它减少了数据冗余性，但去规范化可能会在某些情况下帮助。例如，如果存在大表并且主键到主键的连接很慢，去规范化可能会加快这些查询，因为它允许您跳过这些连接。 主题：优化数据库对象虽然服务器和查询优化是 MySQL 性能的关键因素，数据库对象的优化也是一个重要的因素，不要忽略它们。下面是要知道的内容： 存储引擎类型选择：MySQL 支持多种存储引擎，每种存储引擎都有其特点。最常用的是 MyISAM 和 InnoDB。MyISAM 更简单，通常在读多写少的负载下表现更好。 InnoDB 支持高级特性，例如事务和外键，并在写多读少的负载下表现更好。 索引：索引用于快速定位数据，而不是每次访问数据库表时都搜索整个数据库表。它们可以加快数据检索，但每个索引都会增加插入、更新和删除记录的成本。 规范化：规范化是有效地组织数据库的过程，其目的是消除冗余数据（例如，在多个表中存储相同的数据）并确保数据依赖性有意义。虽然规范化通常会提高性能，但在某些情况下，您可能需要考虑去规范化来优化性能。 分区：分区是一个有力的工具，可以帮助提高数据库的性能，特别是对大表的处理。它是通过将大表分割成更小的、更可管理的部分来实现的，每个分区存储数据的特定子集，定义了分区函数。 记住，数据库对象的优化应该与应用程序的特定需求和工作负载相匹配。请定期监控数据库的性能并根据应用程序的要求调整数据库的架构。 主题：硬件考虑和调整MySQL 性能可能会受到硬件组件，例如 CPU、内存、存储和网络，的影响。让我们来详细了解： 1. CPU： 服务器的 CPU 速度越快，MySQL 性能越好。一种技术是平衡 CPU 的负载，MySQL 支持这种功能。 2. 内存： MySQL 服务器使用大量内存。越多的内存，就越多的数据可以被缓存，并且 MySQL 需要执行的磁盘 I/O 操作越少，性能就越好。考虑调整 innodb_buffer_pool_size，它是一个内存区域，用于存储被缓存的 InnoDB 数据，包括表和索引。 3. 存储： 存储类型对 MySQL 性能有影响。固态硬盘（SSD）通常具有更快的数据访问时间，与传统的硬盘驱动（HDD）相比。请记住，写入磁盘要慢得多于从内存读取数据。因此，有足够的内存可以帮助减少磁盘写入操作的数量是至关重要的。 4. 网络： 网络延迟可能会影响 MySQL 性能，特别是在分布式系统中，其中 MySQL 实例需要通过网络进行通信。升级到更快的网络技术可以降低这种延迟并提高整体性能。 优化硬件来满足 MySQL 数据库的需求可以显著提高其性能。请记住定期监控数据库，以评估硬件是否满足需求。在某些情况下，某些限制只能通过增加或添加更多的硬件资源来解决。 主题：MySQL 复制和分区MySQL 复制 和 分区 是开发人员的两个强大工具，可以帮助增加数据库性能。让我们来详细了解： 1. MySQL 复制： MySQL 复制是一个过程，可以帮助您维护多个 MySQL 数据库副本，通过自动地从主数据库复制数据。这可能会有帮助的多种方式，包括为数据备份创建副本、为故障转移环境创建副本或为数据分割简化常规任务。复制可以帮助提高高负载应用程序的性能，通过分担负载之间的多个从节点。 2. MySQL 分区： 分区是一个过程，通过将大表分割成更小的表来提高查询性能并简化管理任务。MySQL 可以将表分割成分区，并将其存储在分区中。分区可以通过以下方式进行： 范围分区： 表被分割为范围，其范围由分区函数确定。值在范围内被分配到分区中。例如，您可能会将销售数据分割为月度范围。 列分区： 类似于范围分区，但分区是基于列匹配一组特定值列表的。 哈希分区： 分区函数生成哈希值，该值确定分区。 键分区： 类似于哈希分区，但只有整数、二进制或字符串类型的列可以被使用。 复合分区： 是范围或列分区与哈希或键分区的组合。 了解这些概念并实施它们可以显著提高数据库的性能，并且还允许更强的冗余性和可伸性在您的系统中。 主题：回顾与评估在这一阶段，重要的是回顾我们所发现的一切。 1. MySQL配置： 我们学习了MySQL配置的重要性，并学习了如何调整各种参数来提高性能。每个MySQL安装都是独特的，并且根据个人需求进行细调可以显著提高性能。 2. 服务器设置的调整： 我们深入研究了内存、缓存和各种其他服务器设置的调整，以获取最佳效率。 3. 查询优化： 我们了解了MySQL如何处理查询，并学习了如何更有效地编写查询来节省资源。 4. 优化数据库对象： 我们了解了优化MySQL数据库对象，例如表和索引，以获取更好的性能，并学习了相应的技术。 5. 硬件考虑和优化： 我们学习了硬件参数，例如CPU、内存、磁盘和网络，对MySQL性能的影响，并学习了如何优化硬件资源以获取更好的性能。 让我们开始评估。 6. MySQL复制和分区： 我们探讨了MySQL复制和分区的概念，了解了它们的有用性来增强数据库性能。 评估 1：MySQL 配置 MySQL 配置是指在 MySQL 数据库中定义和设置各种参数的过程，这些参数可以帮助提高数据库的性能和可靠性。这是数据库管理的重要部分，因为它可以帮助数据库处理更多的请求和提供更好的性能。 评估 2：服务器设置的调整 通过更改服务器设置，可以帮助优化 MySQL 数据库的性能。这可能包括内存、缓存和其他服务器设置的调整，以帮助数据库处理更多的请求并提供更好的性能。 评估 3：查询优化 要优化 SQL 查询，可以采取多种策略，例如使用索引、避免使用子查询、使用 JOIN 代替子查询等等。这可能会帮助数据库处理更多的请求并提供更好的性能。 评估 4：模式对象 讨论 MySQL 中优化模式对象的重要性。 评估 5：硬件考虑 硬件对 MySQL 性能有影响，哪些参数可以进行优化？ 评估 6：复制和分区 解释 MySQL 复制和分区的概念。这些技术如何增强数据库性能？ 请花些时间来回答这些问题。 评估 1：MySQL 配置 MySQL 配置是自定义设置，决定了 MySQL 如何运行。它的重要性在于，正确的配置可以确保有效地利用系统资源，提高查询执行速度，并提供更好的性能。 评估 2：服务器设置 更改服务器设置，例如增加缓冲区大小或限制最大连接数，可以大大提高 MySQL 性能。例如，增加缓冲区大小可以允许更多数据存储在内存中，减少磁盘 I/O。然而，所有更改都应考虑系统资源的负载。 评估 3：查询优化 要优化 SQL 查询，可以使用策略，例如选择所需字段、正确使用连接、创建索引以进行更快的搜索、使用 LIMIT 以及避免使用 ‘%’ 作为查询的开头。 评估 4：模式对象 优化模式对象可以显著提高查询速度。技术包括适当的索引、选择合适的数据类型和正常化数据库。 评估 5：硬件考虑 硬件直接影响 MySQL 性能。CPU 速度决定了查询处理的速度，并且更多的内存允许更大的缓冲和缓存区，从而减少磁盘 I/O。更快的磁盘也会降低 I/O 等待时间。要进行优化，可以增加内存、使用更快的磁盘或者分布数据库到多台机器上。 评估 6：复制和分区 MySQL 复制是一个过程，其中数据从一个 MySQL 数据库服务器（主服务器）复制到一个或多个 MySQL 数据库服务器（从服务器）。它增加了数据安全性、为高量网站提供了性能并是数据备份的一部分。 分区是数据库设计技术，用于提高性能、管理性、简化维护和降低存储大量数据的成本。它通过将单张表分割成更小的成员来工作，每个成员可以独立管理和访问。 English post: https://programmerscareer.com/mysql-interview9/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/mysql-interview9/"},{"title":"Redis 面试: 简述 Redis 中跳表的应用以及优缺点","text":"解释跳跃表是什么以及它们通常在哪里被使用。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：1.1 跳跃表简介跳跃表是一种令人惊叹的数据结构。它们是为简单性和速度而设计的。 一个跳跃表是一种概率性数据结构，允许有效的搜索、插入和删除操作。它与有序链表非常相似，但跳跃表的魅力在于它们如何提高操作的速度。 跳跃表的主要思想是“跳过”大量元素，而不是遍历链表来找到一个元素。它使用连接以渐进方式的元素分数的链表层次结构。这个分数逐渐减少，这使得我们可以实现有效的搜索操作。 跳跃表在大数据场景中尤为出色。它的平均情况和最坏情况搜索和插入时间复杂度为O(log n)，这使它非常高效！ 尽管它们可能没有与更常见的数据结构相同的受欢迎程度，但跳跃表具有重要的应用，其中一个应用是在Redis等数据库中使用。下一节课将帮助我们更深入地了解Redis如何利用跳跃表。 主题：1.2 Redis中的跳跃表Redis，一款著名的开源内存数据结构项目，在其代码库中实现了跳跃表以解决某些用例。其中最令人印象深刻的是有序集合数据类型。 在Redis中，有序集合是一个元素与“分数”相关联的集合。尽管如何在传统哈希表中实现这一点，但有序集合的强大之处在于它们始终根据这个分数排序。这就是跳跃表发挥作用的地方。 Redis选择使用哈希表和跳跃表的组合来实现这个有序集合。哈希表允许Redis快速查找集合中的元素，而跳跃表维护元素根据它们的分数排序，从而实现快速检索元素范围、找到元素排名等操作。 有序集合之间的并集、交集和差集操作也使用跳跃表实现。此外，当Redis需要遍历大型有序集合时，它会使用跳跃表而不是哈希表进行遍历，因为这种方法更有效率。 跳跃表提供了有效的搜索和插入操作，对Redis的性能要求至关重要。 主题：1.3 在Redis中跳跃表的应用Redis广泛使用跳跃表，尤其是在有序集合方面。但为什么Redis会选择使用跳跃表，而不是选择其他可以使用的数据结构，例如二叉搜索树或AVL树？有几个原因。 首先，这与简单性有关。跳跃表更容易实现，并且与平衡树相比，有更少的边界情况。它们不需要在插入和删除操作后重新结构化/重新分配（例如树旋转），使它们成为对性能要求高的数据库Redis非常吸引人的选择。 由于其设计，跳跃表提供了接近平衡树的性能，而不需要平衡操作。虽然AVL树提供了很好的性能，但平衡操作在大量读写情况下可能成为瓶颈，这种情况在Redis等数据库中非常常见。 此外，跳跃表支持快速插入、删除和查找操作，只需要几个层次变化，使它们成为有序数据结构的理想选择。 跳跃表在Redis中的应用不仅仅是有序集合，还涉及到Redis集群特性的内部。在Redis集群中，跳跃表用于处理不同节点上哈希槽的分布。 这使Redis集群能够快速定位要分布给特定节点的给定数据，从而提高集群中数据操作的效率。 请记住，每种技术都根据性能、功能、简单性等因素做出决策。Redis使用跳跃表的决策是一个有趣的例子，适合用正确的工具。 主题：1.4 跳跃表在Redis中的优势在Redis中使用跳跃表带来了几个优势，特别是在处理项目列表时。使用跳跃表在Redis中的关键优势包括： 1. 高效的搜索操作：跳跃表具有对数时间复杂度的搜索时间，使其非常有效以搜索元素。而不是按顺序搜索列表中的一个项目，我们可以有效地跳过节点，从而获得更快的搜索时间。这使跳跃表在有序集合中具有显著优势。 2. 简单的实现：跳跃表比平衡搜索树更容易实现。例如，一个二叉搜索树需要在每次插入和删除后执行复杂的平衡操作。相比之下，跳跃表以概率维持平衡，因此不需要在每次变异后执行复杂的重新平衡操作。 3. 快速插入和删除操作：跳跃表支持快速插入、删除和搜索操作。特别是在Redis中，数据操作非常频繁，这些操作的效率对性能至关重要。 4. 高效的范围查询：跳跃表在范围查询方面非常有效，这对有序集合来说是关键的要求。例如，获取范围、找到元素的排名、最近的较低和较高排名项等操作要快得多并更简单。 5. 动态重新分配：跳跃表具有一个非常好的特性，即可以动态重新组织自身。当元素添加或删除时，跳跃表可以动态重建它们的层次。 这些优势对Redis性能的提升至关重要，使其能够有效地处理大量数据集。 主题：1.5 跳跃表在Redis中的缺点尽管跳跃表为Redis带来了许多好处，但可能出现的一些挑战： 1. 空间使用：跳跃表倾向于使用更多空间，因为每个跳跃表节点都维护多个指针，这增加了内存占用。然而，Redis通过限制跳跃表节点可以具有的最大层次数来解决这个问题。 2. 随机性：跳跃表的一个特点是其概率性。跳跃表的节点层次在插入时随机选择。虽然这种随机化有好处，但它导致跳跃表结构的不可预测性。 3. 不适合小数据集：跳跃表在管理大型、有序数据集时表现出色，因为它们的操作时间复杂度是对数。但对于小数据集，维护跳跃表指针的开销以及增加的空间使用可能不被认可。 4. 理解难度：虽然不是直接缺点，但跳跃表的概念可能对不熟悉它的人来说有些吓人。这可能使理解和诊断Redis性能变得复杂。 5. 缺乏广泛使用：跳跃表不像哈希表、AVL树或B-树那样广泛使用或研究。这可能导致理解和修改数据结构变得略显困难。 尽管存在这些挑战，Redis以优雅的方式实现了跳跃表，获得了这些好处而不受重大负面影响。 主题：1.6 在Redis中跳跃表的回顾和评估让我们对每个部分进行回顾： 1.1 跳跃表简介：我们讨论了跳跃表的基本结构和概念，包括它们通常使用的地方以及为什么。 1.2 跳跃表在Redis中的应用：我们关注了Redis如何利用跳跃表，尤其是在处理有序集合时。 1.3 在Redis中跳跃表的应用：我们深入探讨了在Redis环境中跳跃表的常见用例，从简单的有序集合到Redis集群内部。 1.4 跳跃表在Redis中的优势：我们检查了使用跳跃表的主要优势，例如在搜索、插入和删除操作中的效率、实现简单性以及动态重新分配功能。 1.5 跳跃表在Redis中的缺点：我们还讨论了它们的缺点，包括额外的空间使用、随机性、复杂性以及这些方面在理解、维护和使用跳跃表在Redis中所带来的挑战。 为了进一步巩固您的理解，我将为您提供一些简短的评估问题： 你能解释为什么在Redis中使用跳跃表吗？ 跳跃表如何在Redis中处理有序集合？ 在Redis中实现跳跃表时可能出现的挑战是什么？ 问题：为什么在Redis中使用跳跃表？答案： 跳跃表在Redis中使用是因为它们可以维护元素以有效的顺序进行操作，如搜索、插入和删除。这对于操作如获取范围、确定元素的排名、获取较低或较高排名项等操作非常重要。 问题：跳跃表如何在Redis中处理有序集合？答案： 在Redis中，跳跃表处理有序集合的优势在于它们能够有效地执行范围查询，并且能够快速检索元素的排名、最近的较低和较高排名项。这些能够快速插入、删除和搜索元素的能力也在处理有序集合时发挥作用。 问题：在Redis中实现跳跃表时可能出现的挑战是什么？答案： 在实现跳跃表时，可能会遇到以下挑战：每个节点可以维护多个指针，因此空间使用可能会增加。它们的概率性质可能导致跳跃表结构的不可预测性。对于不熟悉它的人来说，它们可能会复杂，而且它们的优势可能在处理小数据集时不被充分利用。 English post: https://programmerscareer.com/redis-interview1/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/redis-interview1/"},{"title":"Redis 面试：如何用Redis实现分布式锁","text":"深入探讨 Redis 的基本知识，并详细了解其数据类型和发布/订阅功能。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 1.1 深入了解 RedisRedis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，用作数据库、缓存和消息代理。它具有内置的复制、Lua脚本、LRU淘汰、事务和多种持久化级别。值得注意的是，Redis可以处理多种数据结构，例如字符串、哈希、列表、集合、有序集合（范围查询）、位图等。 先讨论一下 Redis 的核心特性。 性能：Redis 将数据库完全存储在内存中，仅在持久化时使用磁盘，这使其处理数据非常快速。 持久性：Redis 提供了 RDB（Redis 数据库文件）和 AOF（追加只写文件）两种持久化方式，可以按时间间隔或按每次更改记录进行持久化。 原子操作：Redis 的操作，例如 APPEND、INCR、等，是原子的，这意味着它们完全或不执行。这确保了数据的完整性，即使处于并发环境中。 数据结构：Redis 不仅仅是一个简单的键值存储，它是一个数据结构服务器，支持字符串、哈希、列表、集合和更多的数据结构。 发布/订阅功能：Redis 包含内置的发布/订阅命令，用于消息和队列系统，使用发布/订阅范式。 脚本：Redis 允许脚本化在服务器端使用 Lua，将原子命令转换为强大的脚本来处理数据。 接下来是 Redis 数据类型。 Redis 支持多种数据类型： 字符串：Redis 中的字符串可以存储任何数据，例如 JPEG 图像或序列化的 Ruby 对象。 列表：Redis 中的列表是有序值的序列。思考它像链表。 集合：Redis 中的集合是无序集合的字符串，其中添加和删除项目发生在常时间内。集合不能包含重复的成员。 有序集合：每个成员在有序集合中都与一个分数相关，用于对集合元素进行排序，从小到大的分数。 哈希：它们是键值对的映射，其中键和值都是字符串。 Redis 的功能和特性使它成为一个多功能的系统，用于缓存、会话缓存、全页缓存、消息队列应用程序、排行榜和计数、实时分析等。 1.2 了解数据库锁在我们深入了解如何使用 Redis 实现分布式锁之前，了解数据库锁的基本概念是必要的。 在数据库中，特别是允许并发事务（同时事务）的数据库中，锁是一个关键角色，用于维护数据的一致性并防止数据异常。 简单地说，锁 在数据库的上下文中是数据库为数据分配的标记或标记。这个锁控制数据的访问和修改。 详细说明： 共享锁（S 锁）允许读操作，并且可以读取数据库中的数据，但不能修改它。其他事务可以同时获取共享锁并读取数据，但是不能写入它。因此，共享锁帮助维护数据的一致性，确保数据在读操作期间不会被其他事务更改。 排他锁（X 锁）也称为“写锁”。如果一个排他锁被持有，那么不仅可以读取数据，还可以修改它。然而，其他事务不能获取任何锁（共享或排他），即使是在同一数据上。排他锁用于维护数据的完整性，确保数据在被修改时不会被其他事务访问。 在锁的概念中，处理潜在的 死锁 是一个主要挑战。死锁是两个或多个事务处于无限等待状态的状态，其中每个事务都在等待其他事务释放资源。解决死锁涉及其检测和实现方案，例如“等待死”或“被挑战”方案，这是一个更深的主题。 主题：1.3 分布式锁的需要在数据库中，锁已经为多个进程或事务访问和避免冲突访问共享数据提供了一种方法。 现在，想象一下在分布式系统中的场景。分布式系统是指位于网络上的多个计算机之间通过传递消息来通信和协调操作的系统。 在这样的环境中，使用常规锁就不足够了。这就是分布式锁的需要。 分布式锁或全局锁允许多个分布式进程同步其操作，通常用于避免在分布式系统中访问共享资源时的冲突。换句话说，它在网络上的多个节点或系统上工作，并确保在任何时候只有一个客户端可以拥有锁。 分布式锁的高级使用场景包括： 微服务架构，其中多个独立的应用程序在相互通信时，分布式锁可以控制访问共享资源。 数据复制或分片 经常需要确保写操作在多个位置或数据库上的一致性。 分布式事务的协调 在多个微服务和数据库上。 解决复杂的真实世界问题，例如领导选举、任务分发和同步、和确保幂等性在分布式系统中。 服务发现协议，其中微服务需要知道其他的存在，需要一个可靠的机制来避免竞争和冲突。这些协议通常使用分布式锁来避免冲突而更新公共注册表。 这些只是几个例子，并且有许多其他的分布式锁使用场景在分布式系统中。 请记住，分布式锁并不无挑战——一致性、可用性和网络分区（CAP 定理）都有其部分要满足。但是，随着我们进展，我们将更深入地了解如何使用 Redis 在我们的后续课程中实现分布式锁。 主题：1.4 使用 Redis 实现分布式锁首先，要了解的是分布式锁应该满足以下属性： 互斥性：任何时候只有一个客户端可以持有锁。 死锁自由：最终，每个锁请求都应该成功。 容错性：如果持有锁的客户端崩溃，系统应该恢复。 Redis 提供了 SETNX、EXPIRE 等命令，可能会创造锁系统。但是，锁的过期和释放的客户端不是持有锁的客户端可能会导致问题。因此，为了解决和克服这些问题，引入了 Salvatore Sanfilippo（Redis 的创造者）所提出的 Redlock（Redis 分布式锁）算法。 Redlock 算法的工作原理如下： 当客户端想要获取某些资源的锁时，它生成一个唯一的随机字符串（值）。 这个客户端试图在所有的 N Redis 主节点上使用 SETNX 命令（如果键不存在）并附加一个时间到生命（TTL）。 如果客户端在大多数的实例上成功地设置它（&gt; N/2），它认为锁已成功获取。 如果锁设置失败在大多数的实例上，客户端将尝试从所有的实例中删除键（即使在那些它初次成功地设置的地方），等待一个随机的延迟，然后再次尝试步骤 1-3。 要释放锁，它只需要发送 DEL 命令来删除键。 通过这样的方式，您可以创建一个健壮的分布式锁系统。请记住，该算法的成功主要取决于同步的时钟在 Redis 节点上，因为锁的 TTL 值与其关联。 主题：1.5 Redis 事务Redis 事务允许执行一组命令在一个步骤中。首先，所有的命令都会排队，然后使用最后一个命令，所有的命令都会按顺序执行。 Redis 事务使用两个主要命令：MULTI 和 EXEC。 下面是 Redis 事务的一个例子： 1234MULTI INCR foo INCR bar EXEC 在这个例子中，我们在键 ‘foo’ 和 ‘bar’ 上增加值，并在事务中执行这个增量操作。MULTI 是事务块的开始命令，EXEC 是事务块的结束命令并触发执行。 Redis 事务具有“所有或者没有”的性质。这意味着如果一个命令失败，所有的命令都会回滚。要注意的是，Redis 命令很少会失败，因为它们在命令的语法检查中总是会先发生，在命令被排队之前。 从锁的角度来看，要注意的是 Redis 使用了“乐观锁定”——锁不会在事务的执行过程中持有。相反，您可以使用 WATCH 命令在一个或多个键上。如果这些键在事务执行之前被其他客户端修改，则事务会被取消，允许安全地处理竞争条件。 请记住以下原则： Redis 事务是原子的，意味着所有的命令都会执行或者不会执行。 Redis 使用乐观锁定来处理并发事务。 主题：1.6 实践案例——在真实世界应用中使用 Redis 分布式锁分布式锁在多个系统、进程或线程之间的协调和同步中被广泛使用。下面是一些真实世界的使用案例： 电子商务平台：分布式锁的一个常见用例是在线购物平台中的库存管理。当多个用户同时试图购买库存中的最后一件商品时，分布式锁可以用来确保只有一个购买操作成功，防止过售。 银行系统：分布式锁可以在金融事务中发挥重要作用。例如，考虑两个操作（借贷）在同时进行时。需要确保这些操作在原子方式下进行，以防止余额不一致。 在线票务预订：分布式锁可确保单个座位不会被多个用户在并发预订操作中预订。 分布式系统的主节点选举：在分布式系统中，分布式锁可用于处理故障转移，并选择新的主节点当前主节点失败时。 观察这些使用案例，可以看出分布式锁满足复杂、分布式应用系统中维持数据一致性、完整性和协调之间的优先要求。 主题：1.7 回顾和评估在会话中，我们深入了解了 Redis、其内置支持的分布式锁和其在实际应用中的应用。我们还深入了解了 Redis 事务并获取了有关其参与分布式锁的见解。 我们已经覆盖了许多主题，例如： Redis 深入研究：我们扩展了基本知识，深入研究 Redis 的特性，例如其数据类型和 Pub/Sub 功能。 数据库锁的理解：我们获取了数据库锁的总体了解，其利用和类型。 分布式锁的需要：我们看到了分布式锁的需要并了解了它们在大规模应用中的作用。 使用 Redis 实现分布式锁：我们讨论了如何使用 Redis 实现分布式锁。 Redis 事务：我们讨论了 Redis 事务、其命令和如何与分布式锁协作。 Redis 分布式锁的实际应用：我们浏览了各种使用案例场景，其中 Redis 分布式锁已被应用。 例子问题： 假设您正在开发一个在线票务预订系统。存在一种情况，多个用户同时预订同一座位。如何使用 Redis 分布式锁来防止这种情况？ 这是我们如何解决这个问题的例子： 首先，我们将在预订过程开始时为座位实现锁定。这个锁将防止其他用户预订同一座位。 下面是如何在 Redis 中实现这个： 1SET lock:seat_id value NX EX 30 在这条命令中，lock:seat_id 是锁定标识符（其中 seat_id 是预订座位的 ID），value 是用于识别处理过程的唯一字符串，NX 告诉 Redis 只在键不存在时设置键，并且EX 30 为锁定设置了 30 秒的过期时间。 命令的返回值将是 OK 或 None。如果返回值是 OK，则表明我们成功获取了锁定。如果它是 None，则表明另一个进程已经获取了锁定。 现在，测试你的理解。 简单问题（3/10）： 为什么在大规模应用中需要分布式锁定系统？ 中等问题（6/10）： Redis 事务的主要原则是什么？ 复杂问题（9/10）： 如何解决分布式系统中的故障转移问题，例如，使用 Redis 分布式锁？ 简单问题（3/10）： 在大规模应用中，我们需要分布式锁定系统来处理并发和保证分布式系统中数据的完整性。例如，如果多个客户同时试图访问和修改同一块数据，分布式锁可帮助确保只有一个客户可以访问和修改该数据，从而防止竞争条件、不一致和其他潜在问题。 中等问题（6/10）： Redis 事务的主要原则如下： Redis 事务提供了一种执行批量命令的原子方式。 使用 MULTI 命令开始事务，使用 EXEC 命令执行事务。 使用 WATCH 命令可以实现乐观锁定。它帮助取消事务，如果监视的键已更改。 在事务中命令失败时，Redis 仍然执行事务中的其余命令。 复杂问题（9/10）： 分布式锁可在分布式系统中处理故障转移时发挥重要作用。在节点故障（其中节点在集群中失败）的情况下，我们必须选择新的主节点。分布式锁可用于确保选举过程无冲突并且只有一个节点被选为新的主节点。我们可以使用前面相似的锁定模式，其中锁表示主节点。谁成功获取了锁就成为新的主节点。 English post: https://programmerscareer.com/redis-interview2/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/redis-interview2/"},{"title":"你应该了解的 Golang 的语法糖","text":"探索 Go 中的语法糖：综合指南 The free man is he who does not fear to go to the end of his thought. — Léon Blum Golang 语法糖简介：解释什么是语法糖以及它们在 Golang 中的重要性。 在计算机科学中，”语法糖”是指一种编程语法，它是为了使程序更易于读或表达，而在内部转化为基础语法。换句话说，这种语法并没有引入新的功能，而是提供了一种更加方便的编程方式。 Golang，作为一个现代语言，包含了大量的语法糖来减轻程序员的负担并使代码更可读。 例如，许多高级编程语言中的 ++ 操作符，它是语法糖，用于增加变量的值 1。因此，我们可以输入 i++ 而不是 i = i + 1，它更短和更快速地输入，并且它表达相同的增量操作。 接下来我们将会遍历Golang中的常见语法糖，分别详细介绍。这将会帮助你更好的理解和使用Golang，写出更紧凑、可读性更高的代码。 当然，学习的目标不仅是学习这些特性，更重要的是了解何时和为什么要使用它们。一个负责的 Go 开发人员不仅知道如何利用这些语法糖，还需要知道何时合适地使用它们。 可变长参数基本介绍Go语言允许一个函数把任意数量的值作为参数，Go语言内置了…操作符，在函数的最后一个形参才能使用，使用它必须注意如下事项： 一个函数的最后一个参数可以是一个变长参数； 一个函数可以最多有一个变长参数； 一个变长参数的类型总为一个切片类型。 声明和调用变长函数声明和普通函数声明类似，只不过最后一个参数必须为变长参数。&nbsp;一个变长参数在函数体内将被视为一个切片。 12345678func SumData(values ...int64) (sum int64) { // type of values is []int64。 sum = 0 for _, v := range values { sum += v } return} 在变长参数函数调用中，可以使用两种风格的方式将实参传递给类型为[]T的变长形参： 1.传递一个切片做为实参。此切片必须可以被赋值给类型为[]T的值（或者说此切片可以被隐式转换为类型[]T）。&nbsp;**此实参切片后必须跟随三个点…**。2.传递零个或者多个可以被隐式转换为T的实参（或者说这些实参可以赋值给类型为T的值）。&nbsp;这些实参将被添加入一个匿名的在运行时刻创建的类型为[]T的切片中，然后此切片将被传递给此函数调用。 注意，这两种风格的方式不可在同一个变长参数函数调用中混用。 1234567891011121314func main() { a0 := SumData() a1 := SumData(3) a3 := SumData(3, 4, 8) // The top three lines are equivalent to the bottom three lines. b0 := SumData([]int64{}...) b1 := SumData([]int64{2}...) b3 := SumData([]int64{2, 3, 5}...) fmt.Println(a0, a1, a3) fmt.Println(b0, b1, b3) }// print // 0 3 15// 0 3 15 fmt标准库包中的Print、Println和Printf函数均为变长参数函数。 它们的声明大致如下： 123func Print(a ...interface{}) (n int, err error) func Printf(format string, a ...interface{}) (n int, err error) func Println(a ...interface{}) (n int, err error) 忽略相关信息我们只想初始化包里的init函数，但是不会使用包内的任何方法，这时就可以使用&nbsp;_&nbsp;操作符号重命名导入一个不使用的包： 1import&nbsp;_&nbsp;\"github.com/tfrain\" 方法的返回值我们并不一定都使用，还要绞尽脑汁的给他想一个命名，有没有办法可以不处理不要的返回值呢？当然有，还是&nbsp;_&nbsp;操作符，将不需要的值赋给空标识符，就可以忽略： 1_,&nbsp;ok&nbsp;:=&nbsp;test(a,&nbsp;b&nbsp;int) 有些时候我们想要json里面的某些字段不参加序列化，- 操作符可以帮我们处理，Go语言的结构体提供标签功能，在结构体标签中使用&nbsp;-&nbsp; 操作符就可以对不需要序列化的字段做特殊处理: 我们使用json.Marshal进行序列化时不会忽略struct中的空值，默认输出字段的类型零值（string类型零值是””，对象类型的零值是nil），如果我们想在序列化时忽略掉这些没有值的字段时，可以在结构体标签中中添加omitempty&nbsp;： 12345type&nbsp;Person&nbsp;struct{ &nbsp;&nbsp;Name&nbsp;string&nbsp; `json:\"-\"` &nbsp;&nbsp;Age&nbsp;string&nbsp; `json:\"age\"` &nbsp;&nbsp;Email&nbsp;string&nbsp;&nbsp;&nbsp;`json:\"email,omitempty\"`} 声明相关短变量声明每次使用变量时都要先进行函数声明，对于些其他语言的人来说，并不习惯，那么在Go语言是不是也可以不进行变量声明直接使用呢？我们可以使用&nbsp;name := expression&nbsp;的语法形式来声明和初始化局部变量，相比于使用var声明的方式可以减少声明的步骤： 123var&nbsp;a&nbsp;int&nbsp;=&nbsp;10 same asa&nbsp;:=&nbsp;10 使用短变量声明时有两个注释事项： 短变量声明只能在函数内使用，不能用于初始化全局变量 短变量声明代表引入一个新的变量，不能在同一作用域重复声明变量 多变量声明中如果其中一个变量是新变量，那么可以使用短变量声明，否则不可重复声明变量； 声明不定长数组数组一般是有固定长度的，所以我们在声明数组时一般要声明长度，因为数组在编译时就要确认，但也可以不写数组长度，使用…操作符声明数组时，你只管填充元素值，其他的交给编译器自己去搞就好了； a&nbsp;:=&nbsp;[…]int{1,&nbsp;3,&nbsp;5}&nbsp;//&nbsp;same as&nbsp;a&nbsp;:=&nbsp;[3]{1,&nbsp;3,&nbsp;5} 有时我们想声明一个大数组，但是某些index想设置特别的值也可以使用…操作符搞定： a&nbsp;:=&nbsp;[…]int{1:&nbsp;20,&nbsp;999:&nbsp;10} //&nbsp;数组长度是100,&nbsp;下标1的元素值是20，下标999的元素值是10，其他元素值都是0 判断相关判断map的key是否存在Go语言提供语法&nbsp;value, ok := m[key]来判断map中的key是否存在，一般都是只利用ok来进行判断。value如果存在就会返回key所对应的值，不存在就会返回空值： 12345678910import&nbsp;\"fmt\" func&nbsp;main()&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;dict&nbsp;:=&nbsp;map[string]int{\"tfrain\":&nbsp;1} &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;value,&nbsp;ok&nbsp;:=&nbsp;dict[\"tfrain\"];&nbsp;ok&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(value) &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"key:tfrain not exist\") &nbsp;&nbsp;&nbsp;&nbsp;} } 类型断言我们通常都会使用interface，一种是带方法的interface，一种是空的interface，Go1.18之前是没有泛型的，所以我们可以用空的interface{}来作为一种伪泛型使用，当我们使用到空的interface{}作为入参或返回值时，就会使用到类型断言，来获取我们所需要的类型，在Go语言中类型断言的语法格式如下： 1value,&nbsp;ok&nbsp;:=&nbsp;x.(T) x是interface类型，T是具体的类型。这里类型断言需要区分x的类型，如果x是空接口类型： 空接口类型断言实质是将eface中_type与要匹配的类型进行对比，匹配成功在内存中组装返回值，匹配失败直接清空寄存器，返回默认值。 如果x是非空接口类型： *非空接口类型断言的实质是 iface 中 itab 的对比。itab 匹配成功会在内存中组装返回值。匹配失败直接清空寄存器，返回默认值。* English post: https://programmerscareer.com/golang-syntactic-sugar/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/golang-syntactic-sugar/"},{"title":"新的开始","text":"从头开始之前也曾写过博客, 但工作的这2年多一直未曾再动笔, 这里准备重新捡起来. 换了一个新的博客系统, 最主要可能就是支持双语, 写博客的同时, 也能锻炼自己的英语水平.","link":"/zh-cn/hello-world/"},{"title":"Redis 面试：假设 Redis 的 master 节点宕机了，你会怎么进行数据恢复？","text":"让我们制定您的定制课程计划，以学习 Redis。该计划将特别关注 Redis主节点故障时数据恢复的场景。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：Redis架构 Redis 的全称是 Remote Dictionary Server，它是一个开源的内存数据结构存储，可以用作数据库、缓存和消息代理。其中一个主要原因是它在内存中执行所有操作并避免了磁盘操作所需的寻址时间。 Redis 支持各种数据结构，例如字符串、哈希、集合、列表等。让我们深入了解 Redis 架构。 Redis 服务器和客户端Redis 数据存储系统的基本角色有两个：Redis 客户端和 Redis 服务器。 Redis 客户端 是一个独立的应用程序，与 Redis 服务器连接并执行命令。客户端可以是任何内容，从一个小的脚本来管理应用程序会话，到一个大型系统来使用 Redis 缓存数据以提高访问速度。 Redis 服务器 是主要的功能单元。它是数据存储的位置，数据被缓存到内存中，数据结构被维护，并处理客户端发送的所有命令。 Redis 数据结构了解 Redis 架构的核心原理是它是一个键值数据存储，这意味着您存储在 Redis 服务器中的每一项数据都包含一个键和一个值。Redis 的独特之处在于它可以存储各种值类型。Redis 支持以下数据结构： 字符串 哈希 列表 集合 有序集合 每种数据结构都有自己的命令集来管理数据。例如，如果您正在处理列表，则可以执行命令，例如 LPUSH、LRANGE 等来操作列表。这些数据结构使 Redis 非常灵活，能够有效地解决许多不同类型的问题。 持久性——一瞥Redis 的一个关键组件是它能够将数据持久化到磁盘。想象一下，如果您的 Redis 服务器关闭时所存储的数据都会被清除——这不是非常有效的吗？为了避免这种情况，Redis 提供了一些持久化到磁盘的策略，以便在故或关闭时可以恢复数据。我们将在后续课程中详细讨论这个方面。 现在，我们已经了解了 Redis 基本架构的要素，我们将逐步深入更复杂的主题，例如数据复制、备份和 Redis Sentinel 高可用性等。 主题：Redis 复制 复制是一种机制，允许您的数据自动复制从主服务器到一个或多个副本服务器。复制提供两大好处： 性能提升：您可以将读操作分发到副本服务器以分担主服务器的负载。这允许主服务器处理更少的请求并提高整体性能。 数据冗余：您的数据将存储在多个服务器上，为了提供冗余选项，如果主服务器出现故障。这种容错性在生产环境中是必不可少的。 了解 Redis 主从复制配置当在 Redis 中设置复制时，它遵循主从复制配置。主服务器包含数据的原始副本，并将其复制到副本服务器。 在 Redis 中设置复制是简单的。基本上，这涉及创建一个主服务器并然后将一个或多个从服务器连接到主服务器上使用 SLAVEOF 命令，指定主服务器的 IP 和端口。 让我们了解如何在主服务器上的变更传递到从服务器： 当在主服务器上的数据集上发生变化（例如，写操作）时，主服务器会将命令发送到连接的从服务器。 每个从服务器将接收命令并执行它们，从而使其数据集与主服务器的数据集同步。 要了解的重要是数据操作是异步的——主服务器不会等待从服务器确认并执行命令。然而，主服务器会记录哪些命令被每个从服务器确认。 这种复制方案提供了一种强大的数据冗余和性能缩放机制。然而，它并不无挑战，例如，如果主节点出现故障怎么办？如何确保高可用性和数据一致性？Redis 是如何处理这些场景的？我们将在后续课程中详细讨论这些问题。 主题：Redis持久化深入分析 Redis主要在内存空间操作数据，提供快速访问和修改数据。然而，数据的持久化变得至关重要，以防止服务器崩溃或关闭时的数据丢失。Redis 包含两种方法来将内存中的数据保存到磁盘上，即 RDB 和 AOF。 RDB (Redis 数据库备份)RDB 持久化通过定期将数据集的快照保存到磁盘上来实现。这是怎样工作的： Redis 会 fork 一个子进程。 子进程会写入整个数据集到磁盘上（到 RDB 文件），以捕获数据在该时刻的快照。 可以配置 RDB 的保存频率。例如，您可以配置 Redis 在过去 15 分钟内至少发生了一次更改时保存到磁盘上。 RDB 的快照非常适合备份。如果您需要重建数据库，具有时间点快照非常有用。 AOF (追加只写文件)AOF 持久化则是记录每次接收到的写操作，然后可以在服务器启动时播放回来。这是怎样工作的： 当接收到一个命令修改数据集时，它会被追加到 AOF 缓冲区中。 Redis 经常将 AOF 缓冲区数据写入磁盘上。 可以配置 AOF 在磁盘上写入数据的频率。 与 RDB 相比，AOF 文件更耐久，因为它是追加只写的。这意味着即使在写操作期间发生了一次崩溃或电源故障，您也可能会收到命令的完整历史，直到故障之前的短时间内。 而 RDB 则可能会丢失更多数据，这取决于您的保存条件（具体取决于您的配置）。 RDB 和 AOF 之间的选择没有一个全面的答案。这取决于您的应用程序和数据的重要性。某些人喜欢 RDB 因为快速备份可以轻松地移动。其他人喜欢 AOF 因为它提供了更高的耐久性。 Redis Actually 允许同时使用 RDB 和 AOF！如果启用了两者，Redis 会在迭代数据集时为 AOF 重写生成数据库的快照。 您可以考虑这是一个混合方法，享受了两种方法的优势。 主题：Redis 备份 没有可靠和定期的备份，数据就面临丢失的风险，特别是在硬件或软件故障时。对 Redis 来说，快照功能，或者 Redis 数据库备份（RDB），提供了一种可靠的备份方式。它提供了一致和压缩的点到时间快照。 RDB 持久化模型通过在不同的时间间隔上保存数据集来操作，您可以指定这些间隔，例如，每 15 分钟内至少发生了 5 个键的更改，或者每 1 小时内至少发生了 1 个键的更改等等。 创建备份Redis 允许您在任何时候手动生成一个 RDB 文件，使用 SAVE 或 BGSAVE 命令。 SAVE 命令同步执行并会阻塞所有其他客户端，因此对生产环境来说，更好的是使用 BGSAVE 命令，它会分叉一个新进程来保存数据，而您的 Redis 服务器继续为客户端请求服务。 请注意，这个过程可能会消耗大量的 I/O 和 CPU，取决于数据的大小。 还原备份还原 RDB 文件非常简单，只需要停止 Redis 服务器，替换 RDB 文件并重新启动服务即可。 启动时，Redis 会从 RDB 文件中加载数据到内存并继续正常操作。在加载数据到内存之前，写入新数据到 Redis 存储或从存储中读取数据都不能进行。 了解备份是 Redis 的关键部分，因为它形成了任何灾难恢复计划的基础。正确和可靠的备份是保护数据并确保应用程序的顺利运行的关键。 主题：Redis Sentinel 现在，让我们讨论 Redis 的一个重要方面，Redis Sentinel 系统。它帮助完成两项主要功能——监控 和 自动故障转移。让我们来详细了解一下。 监控：Redis Sentinel 不断地检查主节点和副本实例是否正常运行。它不仅确认实例的可用性（运行中），还验证它们是否能够接受连接并响应查询。 自动故障转移：如果主节点失败，Sentinel 系统会自动检测这一点并开始故障转移过程。这个过程包括选择一个副本，提升它为新的主节点，并重新配置其他副本以使用新的主节点。 这些功能为 Redis 环境提供高可用性和耐性。在下一课中，我们将处理主节点故障的场景，常见的故障原因和 Redis 是如何处理这些事件的。 值得注意的是 Quorum，它表示最少需要多少个 Sentinel 节点同意才能进行故障转移。例如，如果您有五个 Sentinel 节点，Quorum 可能是三个。这意味着至少三个 Sentinel 节点需要同意主节点确实不可用，并且应该进行故障转移。 Redis Sentinel 为需要高可用性的应用程序提供了很大的价值。在下一课中，我们将处理主节点故障的场景，常见的故障原因和 Redis 是如何处理这些事件的。 主题：Redis主节点故障——一个概述 Redis主节点故障虽然不常见，但可能会对未经配置的Redis架构造成挑战。了解故障的可能原因并为其制定处理策略是至关重要的。 主节点故障可能的原因包括： 硬件故障：这可能是硬件损坏或硬盘的磨损。偶尔，内存组件也可能会失败，导致服务器崩溃。 网络中断：网络连接中断可能会导致主节点（或任何节点）与其他节点失去联系。这可能是暂时的问题或永久性问题，取决于基础设施的特性。 磁盘满错误：Redis可能会关闭以防止数据不一致性。 软件错误/服务器过载：软件BUG或服务器过载可能会导致崩溃，导致主节点故障。 当主节点故障时，关键问题是确保无中断的服务。这就是Redis哨兵系统和Redis复制的地方。 如果发现故障，哨兵系统将开始自动故障转移过程。故障转移过程包括提升副本并将其配置为新主节点，其他副本将被自动重配置以使用此新主节点。 了解故障的可能原因并了解后续恢复机制是维持高可用性的关键。 在下一课中，我们将深入探讨Redis主节点数据恢复过程后主节点故障。 主题：Redis主节点数据恢复 当Redis主节点因某些未预见的事件而崩溃时，恢复数据从备份中变得至关重要，以确保平稳的运行。 作为我们前面所学的，哨兵系统在主节点故障时会开始自动故障转移过程。其中一个副本将被提升为新主节点，其他副本将被自动重配置以使用此新主节点。 但是，我们也需要考虑如何恢复原始主节点并将其添加回系统，一恢复并同步后，可以重新配置。 现在，在故障期间写入的数据是否会丢失取决于持久性配置： AOF (追加只写文件) 持久性配置：在AOF中，所有写操作都会记录，如果主节点故障，AOF文件将继续记录这些操作，直到主节点恢复并与此副本同步。 RDB (Redis数据库备份) 持久性配置：在RDB中，在配置的间隔内进行快照。因此，在两个快照之间写入的数据可能会丢失，如果故障发生。 简而言，处理Redis主节点故障的机制主要取决于配置、哨兵系统和持久性设置。您可以根据使用场景和数据安全要求选择最适合的策略。 主题：复习和评估 我们已经详细探讨了 Redis 各方面的多个方面。让我们回顾我们所学的核心概念： Redis 架构：我们开始了解 Redis 的底层架构。 Redis 复制：研究了 Redis 数据复制的概念并了解了它是如何实现的。 Redis 持久性：深入了解 Redis 数据持久化的过程并了解它是为什么重要的。 Redis 备份：学习了如何在 Redis 中建立备份并了解了它们在数据恢复中的角色。 Redis Sentinel：了解了 Redis Sentinel 的原理并了解它在维持高可用性方面的作用。 主节点故障：讨论了 Redis 主节点故障的可能原因。 主节点数据恢复：了解了 Redis 主节点故障时的详细过程。 现在，重要的是回顾并重新评估我们的理解。这就是交互性评估的地方。它们为我们提供了一种机会来检查我们的理解、应用所学知识并纠正任何遗漏。 例子问题：假设您正在为应用设置数据存储系统。您决定使用 Redis 并需要配置它。您有两台服务器可用。如何确保数据安全和高可用性？ 现在，让我们测试你的知识。 问题 1：根据你所学的 Redis 内部结构，描述 Redis 架构的基本组成部分。 问题 2：解释 Redis Sentinel 的角色并说明它是如何帮助维持 Redis 基础设施的高可用性的。 问题 3：Redis 在主节点故障时会采取哪些步骤？ 对于每个问题，请分享你的答案。 示例问题是：假设您正在为应用程序设置数据存储系统，并决定使用 Redis。需要配置它。您有两台服务器可用。如何确保数据安全和高可用性？ 为了确保数据安全和高可用性，您可以按以下步骤设置 Redis环境： 使用两台服务器：在两台服务器上安装 Redis。其中一台将作为主服务器，另一台将作为从服务器（slave）。 数据持久性：在两台服务器上配置数据持久性机制。这将确保数据更改不会丢失，提供数据安全性。例如，您可能会选择 RDB 以获取较低的数据库备份程度，但更少的资源使用，或者 AOF 以获取更高的数据库备份程度，但更多的资源使用。 主从复制：将第二台服务器设置为主服务器的副本。这意味着主服务器上写入的数据也会写入副本。这在主服务器（设计为主服务器）出现故障时尤其重要。 Redis 哨兵：为了维持高可用性，请使用 Redis 哨兵。哨兵将监视两台服务器，并在主服务器出现故障时提升副本为新主服务器。 配置您的应用程序：配置您的应用程序以将写入操作发送到主服务器，并将读取操作均衡分配到两台服务器上。 这些步ZZ将为高可用性（通过主从复制和 Redis 哨兵）和数据安全性（通过数据持久性机制）提供平衡。 问题 1：Redis 架构的基本构件包括： Redis 客户端：这些是发送命令给 Redis 以执行数据存储操作的应用程序或用户。 Redis 服务器：这是 Redis 安装和运行的地方。它负责在内存中存储数据并执行操作。 数据结构：Redis 支持多种数据结构，包括字符串、列表、集合、有序集合等。每种结构都有特定的命令相关联。 数据库持久性：Redis 提供两种数据库持久性机制——RDB 和 AOF。RDB 在特定时间间隔内拍摄数据集。AOF 记录每次写入服务器接收到的操作。 复制：这是设置主从节点以确保数据冗余的过程。如果主节点失败，其中一个从节点将被提升为新主节点，并且其他从节点将被重新配置以使用新主节点。 问题 2：Redis 哨兵（如果配置）可识别主节点的故障。它将开始故障转移过程。Redis 哨兵系统将选举一个副本并将其提升为新主节点，并且其他副本将被重新配置以使用新主节点。应用程序也会被通知关于新主节点以重定向其查询。 问题 3：当 Redis 主节点失败时，发生以下步骤： Redis 哨兵（如果配置）检测主节点的故障。 一台哨兵开始故障转移，其他哨兵确认此操作。 Redis 哨兵将选举一个副本并将其提升为新主节点。 其他副本将被重新配置以使用新主节点。 在解决问题后，失败的主节点将加入回来作为副本到当前主节点。它需要对新主节点进行完全同步。 English post: https://programmerscareer.com/redis-interview3/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/redis-interview3/"},{"title":"Redis 面试：简述 Redis 中如何防止缓存雪崩和缓存击穿","text":"聚焦缓存防护方面，让我们一起深入探讨和掌握它 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题1.1：详细研究缓存穿透缓存穿透（Cache Penetration），也称为缓存错误或缓存突破，是指请求直接命中数据库，而不是缓存。这通常发生在请求查询未存储在我们的缓存中的数据时。 想象一下，一个购物网站，用户可以搜索产品。缓存可能包含受欢迎搜索项目，以提高检索速度。然而，罕见的产品搜索者可能会导致系统必须从数据库中查询。这是缓存穿透的一个例子。 虽然这可能不会造成严重的问题，但考虑一下高量的流量查询未缓存的项目。这可能会导致数据库的大量加载，并最终导致数据库崩溃。 甚至更严重的缓存穿透是当攻击者可以精确地预测特定请求不会被缓存时发生的情况，并在我们的系统上发起这些请求，使数据库成为主要的命中点，并最终导致系统崩溃。 缓存穿透是应用程序的流畅性和有效性所必需的。幸运的是，Redis提供了强大的策略来避免缓存穿透，并在本主题中探讨它们。 主题 1.2: Redis 中防止缓存穿透的策略Redis 提供了强大的策略来防止缓存穿透，确保系统在高负载下的高效性。这些策略主要集中在减少直接命中数据库的情况下。 一个常见的策略是默认缓存值。当请求未找到数据时，不要让请求直接命中数据库，而是在缓存层处理它，并返回默认值。这意味着数据库不会受到缓存穿透的影响，并且可以防止缓存穿透。 另一个强大的策略是Bloom 过滤器。Bloom 过滤器是一种概率数据结构，可以用来测试数据集中的元素是否是集合的一部分。这意味着它可以快速识别数据请求是否存在于我们的数据库或缓存中。如果 Bloom 过滤器说数据项不存在，我们可以立即返回默认值，而不必查询我们的缓存或数据库。 在设置这些策略时，需要考虑权衡。Bloom 过滤器可能会导致误报。然而，这通常会大大超越小错误概率的好处。 主题1.3：深入探讨缓存崩溃缓存崩溃是一种系统故障，发生在大量缓存项目同时过期，并且多个请求为这些数据项命中数据库，可能导致数据库崩溃或变得不可用，因为高负载。 想象一下，当网站缓存每日特惠时，所有缓存项目都在午夜过期。当时钟显示 12:00 时，所有缓存项目都变得无效。第一组用户在午夜之后试图访问这些特惠时，系统必须从数据库中获取新的特惠并填充缓存。 然而，想象一下，当数百万用户同时试图访问这些特惠时，这可能会导致数据库被大量请求所淹，使其变得不可用或崩溃——这是缓存崩溃的效果。 虽然缓存崩溃可能会令人恐惧，但我们可以采用各种策略来防止它发生。了解这些技术可以使我们设计的系统更加坚固和可靠。 主题 1.4: 使用 Redis 防止缓存崩溃防止缓存崩溃的效果是防止大量请求同时命中数据库。Redis 提供了许多实用的策略来实现这一点。 第一种技术是使用TTL (Time To Live) 延迟。不要为所有缓存项目设置相同的 TTL 值。我们可以轻微延迟或随机化它们的 TTL 值。这引入了差异，从而降低了多个项目同时过期的风险。 另一个主要策略是使用缓存预热。缓存预热是加载数据到缓存之前进行的实践。例如，如果我们知道某些缓存项目很可能很快过期，我们可以在低峰期预先刷新它们，以避免崩溃期间的峰值。 最后，可能值得考虑使用回退缓存。在这种方法中，即使缓存项目已过期，仍然返回过期的值，同时更新缓存的后台进程。这可以防止突然数据库加载，因为同时发生的缓存错误。 要记住的是，没有单一策略可以在每个场景中作为银弹。实际的实现可能需要根据使用案例的特定性组合这些策略。 中文翻译： 主题1.5：Redis事务与缓存预防Redis不仅仅是内存数据库，还可以支持事务——一系列命令按顺序执行，除非遇到命令中的错误。 Redis事务使用两步过程： 命令排队：使用 MULTI 命令来排队命令。在这一步中，Redis仅仅记录所有在这个事务中的命令。 命令执行：当 EXEC 命令被发出时，Redis就执行所有在事务中排队的命令，按照排队的顺序执行。 Redis事务用于确保所有缓存操作（例如读取、写入或更新）是原子的——这意味着它们全部执行或不执行。这是维持缓存一致性的关键，并可以帮助缓解脏读的影响，也可以帮助缓解缓存渗透的影响。 让我们来看一个例子。假设你正在实现一个排行榜系统并想以原子方式更新玩家的分数。下面是如何使用事务来实现这一点的： 1234MULTI GET player_score INCR player_score EXEC 通过将 GET 和 INCR 命令包装在一个事务中，我们可以确保如果其他客户端读取分数，他们总是会得到一致的值。 使用 Redis 事务与缓存预防技术，无论是防止渗透还是避免崩溃，都可以显著提高缓存层的一致性和可靠性。 主题1.6：Redis 缓存预防在实际应用中的应用Redis 和其缓存预防技术在许多实际应用中被广泛使用，以处理大量负载而不崩溃后端数据库。下面是一些例子： 电子商务网站：网站像 Amazon 一样使用 Redis 来缓存产品详细信息和推荐。Redis 的缓存预防技术对处理大量并发用户的能力至关重要，特别是在节日期间。 社交媒体平台：平台像 Twitter 和 Instagram 一样使用 Redis 来缓存用户数据和信息流。Redis 的高并发处理能力使其成为这些平台的理想选择。 排行榜系统：在游戏平台上，用户分数和排名被实时更新并需要被多个客户端同时访问。Redis 的原子事务能力确保分数在所有客户端中的一致性，即使处理大量并发用户。 在线票务服务：在高需求事件期间，票务服务可能会遇到数据库故，如果不处理正确。Redis 的缓存管理能力可以有效地防止这些情况。 在所有这些例子中，缓存优化技术，例如缓存时间的分层、缓存预热和使用备用值，被广泛使用来防止缓存渗透和缓存崩溃。 主题1.7：回顾和评估缓存渗透 发生在频繁请求未知数据时，每次请求都会到达后端数据库，因为缓存中不可用。这可能会导致过多的和不必要的数据库负载。Redis 提供了多种防止它的机制，例如 NULL 缓存和 Bloom 过滤器。 缓存崩溃 发生在多个缓存数据同时过期时，导致数据库的大量请求。Redis 提供了策略，例如 TTL 分层、缓存预热和备用缓存，来处理缓存崩溃。 Redis 事务 在多次读取或写入操作期间起着重要的作用，通过排队多个命令并以原子方式执行它们，Redis 事务可以防止脏读并提供更高的可靠性。 Redis 和防止缓存渗透和崩溃的技术在高流量、实际应用中被广泛使用，例如电子商务网站、社交媒体平台、实时排行榜系统和在线票务服务。 让我们开始评估。 问题1 以你自己的语言描述什么是缓存渗透。为什么它是一个问题，Redis 是如何帮助防止它的？ 问题2 描述一场实际场景，在这场场景中，Redis 事务可能会有用。在这种场景中，如何通过使用事务来促进数据一致性？ 问题3 考虑一场高流量的电子商务网站，并描述如何有效地处理缓存崩溃使用 Redis。 答案1 缓存渗透是指频繁请求未知数据时，每次请求都会到达后端数据库，因为缓存中不可用。这可能会导致过多的和不必要的数据库负载，并降低性能。Redis 帮助防止缓存渗透主要通过 NULL 缓存，在数据库返回 NULL 值时存储“NULL”关键字的情况下。 答案2 在 Twitter 上，当用户点赞一条推文时，推文的总喜欢数和用户的喜欢推文都需要更新。这场场景需要多次写操作，如果不处理原子方式，可能会导致数据不一致。Redis 事务可以将多个写命令排队并以原子方式执行，以维持数据的整性和一致性。 答案 3 在高流量的电子商务网站，例如 Amazon，缓存崩溃可能会发生，当多个缓存产品详细信息或用户推荐过期时。Redis 有效地处理这种情况，通过 TTL 分层，每个键值对在缓存中有不同的过期时间，或者通过缓存预热，在旧缓存过期之前刷新缓存中的最常访问数据。这可以防止数据库的突然增加。 English post: https://programmerscareer.com/redis-interview4/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/redis-interview4/"},{"title":"Redis 面试：简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点","text":"让我们用重点研究 Redis 的 RDB 和 AOF 持久性方案来学习 Redis。 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：Redis 架构想象一种系统，轻量和高效，专为快速存储和检索数据而设计。请允许我介绍名为 Redis 的奇迹！ Redis（Remote Dictionary Server）是一种内存数据结构存储。它可以用作数据库、缓存和消息代理。“内存”部分意味着它主要存储数据在 RAM 中，这使数据操作变得非常快速，因为从和写入主内存可以以更快的速度进行。 其结构基于服务器-客户端架构。这意味着每个 Redis 设置都有一个 Redis 服务器和一个或多个 Redis 客户端；想象一场对话，客户端不断请求，服务器回复。 我们有几个组件在 Redis 架构中处于作用： Redis 客户端：它们可以是不同的应用程序或同一应用程序的多个实例。他们要求，服务器响应。 Redis 服务器：服务器管理数据存储并响应客户端的命令。 Redis 数据：Redis 的核心是数据存储，这是我们的 Redis 架构的关键部分。 现在，正如我们所看到的，Redis 是一个内存数据结构存储。然而，Redis 的一个重要特性是它可以在磁盘上持久化数据。它可以记录每次客户端传递的写操作，因此为内存数据库提供了高级数据安全性。 这就是 Redis 架构的简要概述！ 主题：Redis 持久性概述Redis，一种内存数据结构存储，用于处理 lightning-fast 的数据操作。然而，由于它存储数据在 RAM 中，因此数据持久性问题成为了关注的焦点。Redis 是如何确保数据的长期存在性？ Redis 为此提供了两种方法来确保数据持久性：RDB（Redis 数据库）和AOF（追加只写文件）。 RDB 持久性：这种方法在特定时间点对数据集进行一次点击保存并将其保存在磁盘上以二进制格式进行保存。这些“快照”是紧凑的并且加载速度很快，因此 RDB 是一个出色的备份选项。 AOF 持久性：它记录所有来自服务器的写命令并将其保存在一个文件中。当服务器重新启动时，它使用这个文件来重建数据的状态。由于所有执行的命令都被 Redis 保存，您可以根据服务器的数据持久性级别来同步文件，每次写入命令，每秒或几乎不经常。 两种方法都有自己的优缺点，选择使用哪种方法完全取决于您的特定使用情况。在某些情况下，两种方法的组合可能是一个理想的解决方案。在下一节中，我们将详细讨论这些持久性技术，这将为您提供更深的了解，并帮助您作出更明智的决定。 主题：Redis RDB 持久性让我们来讲述 RDB 持久性 的故事。RDB（Redis 数据库）是 Redis 的一个非常方便的持久性格式。在这种方法中，Redis 服务器在特定时间点创建数据集的点击保存。想象一下，这就像创建定期的数据备份，在某些场景下非常有用。 RDB 的操作非常简单。在配置的间隔内，Redis 父进程会 fork 一个子进程。父进程继续为客户端服务，而子进程开始在磁盘上写 RDB 文件。这样，数据库就可以继续处理客户端请求，而创建快照的同时。 当子进程完成保存 RDB 文件时，它会替换旧的快照。子进程然后退出并向父进程发送成功信号。如果在保存过程中出现错误，子进程会向父进程发送错误信号。 RDB 持久性有自己的优势： 它是为灾难恢复而设计的。您可以配置 Redis 在每分钟或每几秒内创建快照。如果发生灾难性事件，您最多只会丢失一分钟的数据。 快照是以分秒内的速度创建的，并且是完整的。 RDB 快照生成过程非常快速并不会影响 Redis 服务器为写请求处理的性能。此外，它创建了紧凑的文件，Redis 可以很快地在服务器启动时消耗它们，减少了停机时间。 然而，与所有其他技术一样，RDB 持久性也有自己的缺点： RDB 是一个点到时间的快照系统，这意味着它不会记录每个单独的写操作。因此，在发生崩溃或故障时，您可能会丢失未包含在最后一次快照中的数据。 尽管是自动过程，快照生成可能会对大型数据库资源密集，导致服务的降级期间。 在这些信息的基础上，很明显，虽然 RDB 在数据备份和灾难恢复方面有许多优势，但它可能不是应用程序需要高数据持久性的最佳解决方案。 与两面的故事一样，这只是我们持久性故事的一半。在下一课中，我们将探讨 AOF（追加只写文件）持久性的内容和外容。 主题：Redis AOF持久化现在我们已经对 Redis 的 RDB 持久化有了深入的理解，让我们来关注另一种方法：追加只写文件（AOF）。 与 RDB 持久化不同，AOF 采用了更全面的方法。每次执行写命令时，Redis 都会记录它们。真的，每一个。这些命令然后保存到一个追加只写文件中，因此得名。 当 Redis 重新启动时，它使用这个文件来还原其以前的状态。命令按顺序执行，以重新创建数据。 AOF 持久化的一个优点是其持久性。由于每次写操作都会记录，您有了所有变化的详细帐户。它也许会让你兴奋地知道，Redis 提供了可调的持久性级别： 您可以设置 Redis 在写入命令时同步此日志文件 或者，Redis 可以在每秒钟同步此文件 或者，您可能会相信您的电源供应的稳定性并非常频繁地同步！ 想象一下！完全控制您的数据库持久性方法！ 然而，AOF 持久化也有自己的优缺点。在下一课中，我们将比较 RDB 和 AOF，比较其强项，并帮助您了解何时使用哪一个。 主题：Redis RDB 与 AOF 持久化当谈到 Redis 和数据持久性时，RDB 和 AOF 是两个英雄。然而，他们各有自己的优势和劣势。 首先，RDB 持久化创建在特定时间间隔内定期创建的数据集的快照。因此，在意外关闭时，您可以还原数据到最后一次快照。 然而，这可能意味着写入后的数据将永远丢失！虽然 RDB 文件创建快速并不消耗太多内存，但处理较大数据库时可能会导致输入/输出操作的减慢。 另一方面，AOF 持久化记录每次收到的写命令。这可能有好处。因为所有数据都会立即记录下来，所以没有丢失的数据。但是，日志文件可能会变得非常大，并且可能会引入延迟。 最终，RDB 和 AOF 之间的选择取决于您的使用场景。如果您不能忍受任何数据丢失，AOF 是最好的选择。但是，如果数据可以轻松重建并且需要更快的备份和恢复，那么 RDB 可能是更好的选择。 在许多情况下，同时使用 RDB 和 AOF 可能会为您提供两者的好处。您将获得 AOF 持久性和 RDB 快速备份和数据恢复的好处。 中文翻译： 主题：实现 Redis 持久化Redis 的持久化配置灵活性是其强项之一。根据需要，您可以选择 RDB、AOF 或者两者。下面是如何实现它们： 实现 RDB 持久化：启用 RDB 持久化主要涉及配置 Redis 配置文件（redis.conf）中保存数据的频率。这是通过 save 配置直接指令来控制的。语法是 save &lt;seconds&gt; &lt;changes&gt;，其中 &lt;seconds&gt; 指定了一定数量的秒数，&lt;changes&gt; 指定了最小数量的更改。您可以在 redis.conf 文件中为更细的控制具有多个 save 直接指令。 实现 AOF 持久化：要启用 AOF 持久化，您需要更新 appendonly 配置直接指令在 redis.conf 文件中为 yes。另一个重要的直接指令是 appendfsync，它定义了数据写入 AOF 文件的频率。它可以设置为 always（每次写入时 fsync）、everysec（每秒 fsync）或 no（只有 Redis 决定 fsync）。 使用 RDB 和 AOF 同时：两种持久性方法可以同时使用，只需在 redis.conf 文件中启用其相应的直接指令。您将获得 RDB 的点到时快照和 AOF 的持久性。 而且，就是这样！根据应用程序的需要，您已经配置了 Redis 持久性。在困惑时，请记住 RDB 和 AOF 持久性之间的主要差异和其应用场景。 主题：回和评估我们在这些课程中讨论了许多内容： Redis 架构：我们深入探讨了 Redis，特别是作为内存数据结构存储的情况。 Redis 持久化概述：我们讨论了 Redis 处理数据持久化的方式并讨论了其中的一些交换。 Redis RDB 持久化：我们探讨了 RDB 持久化方案，其工作原理和其可能的优势。 Redis AOF 持久化：我们类似地研究了 AOF 持久化方案和其应用场景。 Redis RDB vs. AOF：我们比较了这两种持久性方法，特别是在性能、数据安全和应用场景方面。 实现 Redis 持久化：我们将我们的知识应用到不同的场景中，链接了不同类型的持久性。 我希望这些课程清楚地解释了 Redis、RDB 和 AOF。现在，是时候看看你已经学到了。请耐心地回答以下问题。不要担心，如果你不能回答所有问题，真正的学习通常发生在找答案的过程中，而不是展示你已经知道的！ 描述 AOF 和 RDB 持久化之间的基本差异。 在哪些情况下您会更喜欢使用 AOF，并在哪些情况下会选择 RDB？请提供具体的例子。 使用这些持久性方法可能会遇到哪些潜在的缺点？ 请慢下来并输入答案。 描述AOF和RDB持久性之间的基本差异。 Redis提供了两种持久性方法：RDB（Redis数据库）和AOF（追加只写文件）。它们在保存数据方面的主要差异在于何时和如何保存数据。 _RDB_：这种方法在特定时间间隔内捕获数据集的一次快照。这种方法对备份和重新启动时的快速恢复很有帮助。 _AOF_：这种方法记录每次服务器接收到的写操作，提供了更耐久的持久性方法。AOF日志记录使Redis更具耐力性，因为它维护了所有操作的完整日志。 在哪些情况下会更倾向于使用AOF，在哪些情况下会更倾向于使用RDB？请提供具体的例子。 你的选择取决于特定的项目和你所倾向的权衡。 _RDB_：如果你正在构建一个缓存层，其中数据可以被重新缓存或重新计算从另一个存储中，RDB的更快的备份和恢复时间是明显的优势。 _AOF_：如果你正在构建一个应用程序，其中每次写操作都是关键的——例如，一个消息或合作应用程序——AOF的增加耐力性将是更合适的选择。 使用这些持久性方法可能会有哪些潜在的缺点？ 每种持久性方法都有自己的缺点： _RDB_：在捕获快照时，Redis会复制服务器进程，这可能会对系统造成负担。此外，如果Redis在快照之间发生崩溃，可能会丢失重要的数据。此外，更大的数据库可能需要更长的时间和更多的I/O来创建RDB快照。 _AOF_：日志文件可能会变得非常大，因为它记录了每个操作。此外，AOF日志通常要比等效的RDB快照更大，并且在Redis重新启动时可能会更慢。 请记，这些答案只是指导。在处理真实的项目时，您的特定上下文和要求可能会导致不同的结论。 English post: https://programmerscareer.com/redis-interview5/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/redis-interview5/"},{"title":"Redis 面试：Redis 有几种数据结构？Zset 是如何实现的？","text":"你曾被提过类似问题在面试中问过吗？或者将来会遇到，让我们一起探索和掌握它！ 感谢您阅读这篇文章。更多面试问题:https://programmerscareer.com/zh-cn/software-interview-set/ 主题：1.1 详细研究 Redis 数据结构Redis 是一个开源的内存数据结构存储，为我们提供了一组强大和高性能的数据结构。今天的旅程开始于深入探索这些多样的数据结构并了解其功能。 Redis 中的数据结构是预构建的模式，用于管理和组织数据，并允许快速的读写操作。 Redis 提供了多种类型的数据结构，每一种数据结构都适合不同类型的数据管理需求。这些包括： 字符串：最简单的 Redis 数据结构。它们是二进制安全的，可以包含任何类型的数据。 列表：这些是简单的字符串列表，按插入顺序排序。 集合：这是一个不重复的字符串集合。 哈希：哈希是表示对象的完美选择。它们是字符串字段和字符串值的映射。 排序集（Zsets）：每个 Zset 成员都与一个分数相关，该分数用于排序集元素从最小到最大分数。 位数组（Bitmaps）：它们提供了操作数组的位的功能。 HyperLogLogs：这是一个概率数据结构，用于估计集合的卡inality。 地理空间数据（Geosets）：它们允许您存储纬度、经度和相关名称。 流：它们是日志数据类型，用于追加新项目，例如日志或消息。 数据结构的选择取决于数据的性质和有效地操作数据的类型。 了解数据结构并选择正确的一种可以大大提高应用的性能，使 Redis 成为我们的技术堆栈中的一个不可或缺的工具。 主题：1.2 Redis 支持多少数据结构我们先学习了，Redis 不仅仅是一个简单的键值存储，它更像是数据结构服务器。可能会问，Redis 实际上支持多少种数据结构呢？ 答案是，Redis 重要地支持八种不同类型的数据结构： 字符串 列表 集合 排序集（Zsets） 哈希 Bitmaps HyperLogLogs 地理空间数据（Geosets） 流 每种这些数据结构都有其独特的身份，为特定的目的服务，并提供不同的功能，因此允许 Redis 处理一系列数据管理任务的宽范围，具有出色的速度和一致性。 主题：1.3 了解 Redis 中的有序集（Zset）在 Redis 中，排序集（Zset） 是 Set 和 Hash 的合成体。它们采用这两种数据类型的独特方面，使这种混合结构变得非常灵活。 有序集是，本质上说，是一个 Set，它确保每个元素都是唯一的。然而，它还与每个元素相关联的分数，就像是一个哈希。这些分数用于排序集元素，从最小分数到最大分数。 这可能听起来很简单，但它有重要的后果。Redis 可以为有序集的元素按分数顺序提供有用的资源，为数据范围查询提供了值得的帮助。 想象一下游戏中的排行榜，其中你必须显示顶级表现者以升序或降序顺序排列。有序集是这种用例的理想数据结构，因为你可以直接获取排序的数据。 这就是有序集的概述！随着我们进一步的探索，我们将为您展示如何在 Redis 中实现和操作有序集！ 主题：1.4 在 Redis 中实现有序集我们先学习，有序集在 Redis 中是如何工作的。有序集是通过与每个元素相关联的分数相关联的方式来区分的。然而，我们还没有深入研究它们在 Redis 中的实现。所以让我们来解开这个谜题！ Redis 在内部使用两种数据结构来存储有序集： HashTable，其中元素是键，分数是值。 跳表或排序集，其中每个节点是我们的有序集中的元素。 当有序集非常小，其长度最多为 128 项，并且每个集合中的每个元素都在一个小整数范围内时，有序集被存储为ziplist的列表表示。 值得注意的是，决定使用 HashTable 还是跳表/排序集并不会影响有序集的功能；它只是为了性能的交换。 Redis 根据有序集的内容自动切换这些内部数据结构，优化读取、写入或两者的组合，根据需要！ 主题：1.5 Redis 中的 Zset 实践在 Redis 中，可以对 Zset 进行各种操作： zadd：此命令允许向 Zset 中添加元素，并为每个元素分配一个分数。下面是如何使用它的示例： 1zadd myZset 1 \"a\" zrange：此命令检索有序的元素，根据其分数进行排序。下面是如何使用它的示例： 1zrange myZset 0 -1 zrem：此命令用于从 Zset 中删除特定的元素： 1zrem myZset \"a\" zrank：此命令返回元素的排名，从 0 开始计数。要找到元素 “a” 的排名，请执行以下操作： 1zrank myZset \"a\" 请记住，Redis 对语法非常宽容。它不区分大小写并且在某些情况下甚至不需要关闭引号！ 主题：1.6 Redis 高级主题经过了解各种数据结构和命令后，现在是时候深入探讨 Redis 的高级主题了！💪 让我们先讨论 Redis 的 持久性。Redis 提供两种持久性方法： RDB（Redis 数据库备份）：此持久性方法定期创建数据集的快照。 AOF（追加只写文件）：此持久性方法记录每次写操作接收到的服务器，重新运行它们可以重新创建数据集。 两种持久性方法都有其优缺点，并且选择通常取决于使用场景的要求。 接下来是 Redis 事务。Redis 事务允许执行一组命令作为一个单步。它使用 ‘MULTI’ 来指示开始和 ‘EXEC’ 来指示结束。 另一个值得讨论的重要方面是 Redis 安全性。默认情况下，Redis 没有身份验证或安全层。然而，Redis 允许设置密码，客户必须使用它来进行身份验证并被授予访问权限。 请记住，Redis 不支持加密连接，并建议在需要数据加密时使用 SSL 代理。 最后，让我们讨论 Redis 发布/订阅 模型。在这种模型中，发布者发送消息到特定的频道，不关心或者不在乎订阅者。相反，订阅者侦听特定的频道，不关心或者不在乎发布者。这导致了高度解耦合和可伸缩的系统。 主题：1.7 Redis 在实际应用中的应用Redis 在各种实际应用中发，由于其出色的特性，是一个理想的选择。让我们来看看一些例子： 缓存：由于其高速和丰富的数据类型，Redis 是为网站应用程序实现缓存的理想选择。它显著加快了应用程序的响应时间。 会话存储：需要在多个用户请求之间维护网站的信息的网站通常使用 Redis 进行会话存储。Redis 提供的数据类型使它成为一个理想的候选者。 消息队列系统：使用 Redis 的列表和发布/订阅模型可以创建消息队列系统。列表在 Redis 中可以用作队列，在其中您可以使用原子操作，例如 LPUSH 和 RPOP，来推和弹出元素。 排行榜和计数：Redis 非常适合管理排行榜，特别是如果您需要在实时中管理它们。排序集数据结构是为解决这些问题而设计的。 实时分析：您可以使用 Redis 进行实时分析，例如计算或分析统计数据以进行即时查看。 请记住，Redis 的灵活性不限于这些应用。它还可以用作主数据库、作业管理系统、搜索引擎等等！ 主题：1.8 回顾和评估让我们花些时间来回顾和练习我们在前面几节中学到的内容。总是有好处的重新访问主题并开始实施它们，以巩固我们的理解。 直到现在，我们学习了 Redis 中各种数据类型，为每种数据结构执行了手动操作，深入探讨了高级主题，并看到了 Redis 在实际应用中的应用。 一个好的方法是为我们选择一个实际问题并试图使用 Redis 来解决它。您可以试图为网站应用程序实现一个缓存解决方案或设置一个简单的消息队列系统。使用我们学习的 Redis 命令与不同的数据类型和结构交互。 现在让我们测试你的 Redis 知识！ 1️⃣ 基本问题（难度：3/10）：Redis 支持六种数据类型，它们分别是 STRING、LIST、SET、ZSET（有序集合）、HASH、和 STREAM。 2️⃣ 中级问题（难度：6/10）：在哪种情况下会使用 Redis List 而不是 Redis Set？当数据的顺序重要时，你会使用 Redis List，因为 Redis List 会根据元素被添加的顺序来维护元素的顺序。在另一方面，Redis Set 是一个无序的集合。例如，如果你需要存储一系列的项目并希望它们按时间顺序显示（例如，博文的评论时间线），你会使用 Redis List。 3️⃣ 高级问题（难度：9/10）：如何在网站应用程序中使用 Redis 进行缓存？请简要描述一下它的工作原理： 当请求被发送到你的网站应用程序时，先检查请求的数据是否在 Redis 缓存中可用，通过请求参数作为键来尝试检索它。 如果数据在 Redis 缓存中可用（命中缓存），则从缓存中检索数据并返回它作为响应。 如果数据不在 Redis 缓存中可用（未命中缓存），则从主数据库中检索数据。 在从主数据库中检索数据后，将其保存到 Redis 缓存中，并为其设置过期时间，以防止它无限地占用缓存的内存。然后返回数据作为响应。 如果正确地执行，这允许经常请求的数据来自 Redis 缓存，显著缩短响应时间并降低主数据库的负载。 English post: https://programmerscareer.com/redis-interview6/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/redis-interview6/"},{"title":"常见(20+)软件面试问题(+答案)关于MySQL/Redis/Kafka","text":"收集了关于MySQL/Redis/Kafka的软件面试问题，这篇文章会持续更新 **如果这真的对你有帮助，请我喝杯咖啡，感谢我的辛勤工作，这会激励我创造更多。: D * *给我买杯咖啡 MySQL 面试：为什么MySQL使用B+树进行索引? https://programmerscareer.com/zh-cn/mysql-interview4/ MySQL 面试：数据库的事务隔离级别有哪些？各有哪些优缺点 https://programmerscareer.com/zh-cn/mysql-interview15/ MySQL 面试：什么是数据库事务，MySQL 为什么会使用 InnoDB 作为默认选项？ https://programmerscareer.com/zh-cn/mysql-interview14/ MySQL 面试：简述乐观锁以及悲观锁的区别以及使用场景 https://programmerscareer.com/mysql-interview5/ MySQL 面试：产生死锁的必要条件有哪些？如何解决死锁？ https://programmerscareer.com/zh-cn/mysql-interview6/ Redis 面试：Redis 有几种数据结构？Zset 是如何实现的？ https://programmerscareer.com/zh-cn/redis-interview6/ MySQL 面试：聚簇索引和非聚簇索引有什么区别？ https://programmerscareer.com/zh-cn/mysql-interview13/ MySQL 面试：简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的？ https://programmerscareer.com/zh-cn/mysql-interview12/ MySQL 面试：唯一索引与普通索引的区别是什么？使用索引会有哪些优缺点？ https://programmerscareer.com/zh-cn/mysql-interview11/ Redis 面试：简述 Redis 持久化中 RDB 以及 AOF 方案的优缺点 https://programmerscareer.com/zh-cn/redis-interview5/ MySQL 面试：简述 MySQL 的间隙锁 https://programmerscareer.com/zh-cn/mysql-interview10/ Redis 面试：如何用Redis实现分布式锁 https://programmerscareer.com/zh-cn/redis-interview2/ Redis 面试：简述 Redis 中如何防止缓存雪崩和缓存击穿 https://programmerscareer.com/zh-cn/redis-interview4/ MySQL 面试：MySQL 有什么调优的方式？ https://programmerscareer.com/zh-cn/mysql-interview9/ MySQL 面试：简述 MySQL 的主从同步机制，如果同步失败会怎么样？ https://programmerscareer.com/zh-cn/mysql-interview1/ MySQL 面试：MySQL 的索引什么情况下会失效？ https://programmerscareer.com/zh-cn/mysql-interview8/ MySQL 面试：什么是 SQL 注入攻击？如何防止这类攻击？ https://programmerscareer.com/zh-cn/mysql-interview7/ MySQL 面试：简述数据库中的 ACID 分别是什么？ https://programmerscareer.com/zh-cn/mysql-interview2/ Redis 面试：简述 Redis 中跳表的应用以及优缺点 https://programmerscareer.com/zh-cn/redis-interview1/ Kafka 面试：Kafka 发送消息是如何保证可靠性的？ https://programmerscareer.com/zh-cn/kafka-interview1/ MySQL 面试：MySQL 如何设计索引，如何优化查询？ https://programmerscareer.com/zh-cn/mysql-interview3/ Redis 面试：假设 Redis 的 master 节点宕机了，你会怎么进行数据恢复？ https://programmerscareer.com/zh-cn/redis-interview3/ MySQL 面试：假设建立联合索引 (a, b, c) 如果对字段 a 和 c 查询，会用到这个联合索引吗？ https://programmerscareer.com/zh-cn/redis-interview19/ MySQL 面试：MySQL 有哪些常见的存储引擎？它们的区别是什么？ https://programmerscareer.com/zh-cn/redis-interview18/ MySQL 面试：简述 MySQL MVCC 的实现原理 https://programmerscareer.com/zh-cn/redis-interview17/ MySQL 面试：数据库中什么情况下进行分库，什么情况下进行分表？ https://programmerscareer.com/zh-cn/redis-interview16/ **如果这真的对你有帮助，请我喝杯咖啡，感谢我的辛勤工作，这会激励我创造更多。: D * *给我买杯咖啡 English post: https://programmerscareer.com/software-interview-set/作者：Wesley Wei – Twitter Wesley Wei – Medium注意：本文为作者原创，转载请注明出处。","link":"/zh-cn/software-interview-set/"},{"title":"use-channel","text":"单并发控制在Go语言中，判断channel是否关闭并不能直接保证channel中的数据已经全部消费完毕。当你从一个channel接收数据时，你会得到两个值：接收到的数据和一个布尔值。布尔值为false时表示channel已经被关闭且没有更多的数据可接收。但是，仅凭这个机制并不能保证在channel关闭时已经消费了所有发送到channel的数据。 为了确保在关闭channel之前所有的数据都被消费完毕，你需要更细致的控制发送和接收的过程。以下是一个推荐的做法： 使用 for range 循环和同步原语 发送端：发送数据到channel。 接收端：使用for range循环来接收channel上的数据。这个循环会持续接收数据直到channel被关闭。 123for msg := range ch { // 处理msg} 同步原语：使用sync.WaitGroup来确保所有的数据都被发送并且在关闭channel之前都被接收处理。 123456789101112131415var wg sync.WaitGroup// 发送数据for _, msg := range messages { wg.Add(1) go func(m string) { defer wg.Done() // 发送消息 ch &lt;- m }(msg)}// 等待所有消息发送完毕wg.Wait()close(ch) **关闭channel**：当所有的数据都被发送并且WaitGroup的计数器归零后，关闭channel。此时，for range循环将退出。 这种方法利用for range循环的特性，在channel关闭后自动结束循环，这确保了在channel关闭之前所有的数据都已经被接收并处理。 注意事项 确保在所有数据发送完成后关闭channel。否则，发送到已关闭的channel将会导致panic。 在多个发送者的情况下，需要小心协调以避免在数据发送完毕之前关闭channel。 使用sync.WaitGroup时，确保正确地使用Add、Done和Wait方法来避免死锁。 通过上述方法，你可以确保channel在所有数据都被正确消费后才关闭，这是在并发编程中确保数据完整性的一种有效方式。","link":"/zh-cn/use-channel/"}],"tags":[{"name":"interview","slug":"interview","link":"/zh-cn/tags/interview/"},{"name":"code","slug":"code","link":"/zh-cn/tags/code/"},{"name":"随笔","slug":"anything","link":"/zh-cn/tags/anything/"}],"categories":[{"name":"kafka","slug":"kafka","link":"/zh-cn/categories/kafka/"},{"name":"mysql","slug":"mysql","link":"/zh-cn/categories/mysql/"},{"name":"redis","slug":"redis","link":"/zh-cn/categories/redis/"},{"name":"golang","slug":"golang","link":"/zh-cn/categories/golang/"},{"name":"set","slug":"set","link":"/zh-cn/categories/set/"},{"name":"测试","slug":"测试","link":"/zh-cn/categories/%E6%B5%8B%E8%AF%95/"}]}